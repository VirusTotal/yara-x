#ifndef YARA_X
#define YARA_X

#pragma once

/* Generated with cbindgen:0.26.0 */

// This file is autogenerated by cbindgen. Don't modify it manually.

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>


typedef enum YRX_RESULT {
  SUCCESS,
  PANIC,
  SYNTAX_ERROR,
  VARIABLE_ERROR,
  SCAN_ERROR,
  SCAN_TIMEOUT,
  INVALID_IDENTIFIER,
  INVALID_ARGUMENT,
} YRX_RESULT;

// A compiler that takes YARA source code and produces compiled rules.
typedef struct YRX_COMPILER YRX_COMPILER;

// A single YARA rule.
typedef struct YRX_RULE YRX_RULE;

// A set of compiled YARA rules.
typedef struct YRX_RULES YRX_RULES;

// A scanner that scans data with a set of compiled YARA rules.
typedef struct YRX_SCANNER YRX_SCANNER;

// Contains information about a pattern match.
typedef struct YRX_MATCH {
  size_t offset;
  size_t length;
} YRX_MATCH;

// A pattern within a rule.
typedef struct YRX_PATTERN {
  // Pattern's identifier (i.e: $a, $foo)
  char *identifier;
  // Number of matches found for this pattern.
  size_t num_matches;
  // Pointer to an array of YRX_MATCH structures describing the matches
  // for this pattern. The array has num_matches items. If num_matches is
  // zero this pointer is invalid and should not be de-referenced.
  struct YRX_MATCH *matches;
} YRX_PATTERN;

// A set of patterns declared in a YARA rule.
typedef struct YRX_PATTERNS {
  // Number of patterns.
  size_t num_patterns;
  // Pointer to an array of YRX_PATTERN structures. The array has
  // num_patterns items. If num_patterns is zero this pointer is invalid
  // and should not be de-referenced.
  struct YRX_PATTERN *patterns;
} YRX_PATTERNS;

// Callback function passed to the scanner via [`yrx_scanner_on_matching_rule`]
// which receives notifications about matching rules.
//
// The callback receives a pointer to the matching rule, represented by a
// [`YRX_RULE`] structure. This pointer is guaranteed to be valid while the
// callback function is being executed, but it may be freed after the callback
// function returns, so you cannot use the pointer outside the callback.
//
// It also receives the `user_data` pointer that was passed to the
// [`yrx_scanner_on_matching_rule`] function, which can point to arbitrary
// data owned by the user.
typedef void (*YRX_ON_MATCHING_RULE)(const struct YRX_RULE *rule,
                                     void *user_data);

// Compiles YARA source code and creates a [`YRX_RULES`] object that contains
// the compiled rules.
//
// The rules must be destroyed with [`yrx_rules_destroy`].
enum YRX_RESULT yrx_compile(const char *src,
                            struct YRX_RULES **rules);

// Destroys a [`YRX_RULES`] object.
void yrx_rules_destroy(struct YRX_RULES *rules);

// Returns the name of the rule represented by [`YRX_RULE`].
//
// Arguments `ident` and `len` are output parameters that receive pointers
// to a `const uint8_t*` and `size_t`, where this function will leave a pointer
// to the rule's name and its length, respectively. The rule's name is *NOT*
// null-terminated, and the pointer will be valid as long as the [`YRX_RULES`]
// object that contains the rule is not freed. The name is guaranteed to be a
// valid UTF-8 string.
enum YRX_RESULT yrx_rule_identifier(const struct YRX_RULE *rule,
                                    const uint8_t **ident,
                                    size_t *len);

// Returns the namespace of the rule represented by [`YRX_RULE`].
//
// Arguments `ns` and `len` are output parameters that receive pointers to a
// `const uint8_t*` and `size_t`, where this function will leave a pointer
// to the rule's namespace and its length, respectively. The namespace is *NOT*
// null-terminated, and the pointer will be valid as long as the [`YRX_RULES`]
// object that contains the rule is not freed. The namespace is guaranteed to
// be a valid UTF-8 string.
enum YRX_RESULT yrx_rule_namespace(const struct YRX_RULE *rule,
                                   const uint8_t **ns,
                                   size_t *len);

// Returns all the patterns defined by a rule.
//
// Each pattern contains information about whether it matched or not, and where
// in the data it matched. The patterns are represented by a [`YRX_PATTERNS`]
// object that must be destroyed with [`yrx_patterns_destroy`] when not needed
// anymore.
struct YRX_PATTERNS *yrx_rule_patterns(const struct YRX_RULE *rule);

// Destroys a [`YRX_PATTERNS`] object.
void yrx_patterns_destroy(struct YRX_PATTERNS *patterns);

// Creates a [`YRX_COMPILER`] object.
enum YRX_RESULT yrx_compiler_create(struct YRX_COMPILER **compiler);

// Destroys a [`YRX_COMPILER`] object.
void yrx_compiler_destroy(struct YRX_COMPILER *compiler);

// Adds a YARA source code to be compiled.
//
// This function can be called multiple times.
enum YRX_RESULT yrx_compiler_add_source(struct YRX_COMPILER *compiler,
                                        const char *src);

// Returns the error message for the most recent error returned by the
// compiler.
//
// The returned pointer is only valid until the next call to any of the
// yrx_compiler_xxxx functions. A call any of these functions can modify
// the last error, rendering the pointer to a previous error message
// invalid. Also, the pointer will be null if the compiler hasn't returned
// any error.
const char *yrx_compiler_last_error(const struct YRX_COMPILER *compiler);

// Creates a new namespace.
//
// Further calls to `yrx_compiler_add_source` will put the rules under the
// newly created namespace.
//
// The `namespace` argument must be pointer to null-terminated UTF-8 string.
// If the string is not valid UTF-8 the result is an `INVALID_ARGUMENT` error.
enum YRX_RESULT yrx_compiler_new_namespace(struct YRX_COMPILER *compiler,
                                           const char *namespace_);

// Defines a global variable of string type and sets its initial value.
enum YRX_RESULT yrx_compiler_define_global_str(struct YRX_COMPILER *compiler,
                                               const char *ident,
                                               const char *value);

// Defines a global variable of bool type and sets its initial value.
enum YRX_RESULT yrx_compiler_define_global_bool(struct YRX_COMPILER *compiler,
                                                const char *ident,
                                                bool value);

// Defines a global variable of integer type and sets its initial value.
enum YRX_RESULT yrx_compiler_define_global_int(struct YRX_COMPILER *compiler,
                                               const char *ident,
                                               int64_t value);

// Defines a global variable of float type and sets its initial value.
enum YRX_RESULT yrx_compiler_define_global_float(struct YRX_COMPILER *compiler,
                                                 const char *ident,
                                                 double value);

// Builds the source code previously added to the compiler.
//
// After calling this function the compiler is reset to its initial state,
// you can keep using it by adding more sources and calling this function
// again.
struct YRX_RULES *yrx_compiler_build(struct YRX_COMPILER *compiler);

// Creates a [`YRX_SCANNER`] object that can be used for scanning data with
// the provided [`YRX_RULES`].
//
// It's ok to pass the same [`YRX_RULES`] to multiple scanners, and use each
// scanner from a different thread. The scanner can be used as many times as
// you want, and it must be destroyed with [`yrx_scanner_destroy`]. Also, the
// scanner is valid as long as the rules are not destroyed, so, always destroy
// the [`YRX_SCANNER`] object before the [`YRX_RULES`] object.
enum YRX_RESULT yrx_scanner_create(const struct YRX_RULES *rules,
                                   struct YRX_SCANNER **scanner);

// Destroys a [`YRX_SCANNER`] object.
void yrx_scanner_destroy(struct YRX_SCANNER *scanner);

// Sets a timeout (in seconds) for scan operations.
//
// The scan functions will return a timeout error once the provided timeout
// duration has elapsed. The scanner will make every effort to stop promptly
// after the designated timeout duration. However, in some cases, particularly
// with rules containing only a few patterns, the scanner could potentially
// continue running for a longer period than the specified timeout.
enum YRX_RESULT yrx_scanner_timeout(struct YRX_SCANNER *scanner,
                                    uint64_t timeout);

// Scans a data buffer.
//
// `data` can be null as long as `len` is 0. In such cases its handled as
// empty data. Some YARA rules (i.e: `rule dummy { condition: true }`) can
// match even with empty data.
enum YRX_RESULT yrx_scanner_scan(struct YRX_SCANNER *scanner,
                                 const uint8_t *data,
                                 size_t len);

// Sets a callback function that is called by the scanner for each rule that
// matched during a scan.
//
// The `user_data` pointer can be used to provide additional context to your
// callback function. If the callback is not set, the scanner doesn't notify
// about matching rules.
//
// See [`YRX_ON_MATCHING_RULE`] for more details.
enum YRX_RESULT yrx_scanner_on_matching_rule(struct YRX_SCANNER *scanner,
                                             YRX_ON_MATCHING_RULE callback,
                                             void *user_data);

// Specifies the output data structure for a module.
//
// Each YARA module generates an output consisting of a data structure that
// contains information about the scanned file. This data structure is represented
// by a Protocol Buffer. Typically, you won't need to provide this output data
// yourself, as the YARA module automatically generates different outputs for
// each file it scans.
//
// However, there are two scenarios in which you may want to provide the output
// for a module yourself:
//
// 1) When the module does not produce any output on its own.
// 2) When you already know the output of the module for the upcoming file to
// be scanned, and you prefer to reuse this data instead of generating it again.
//
// Case 1) applies to certain modules lacking a main function, thus incapable of
// producing any output on their own. For such modules, you must set the output
// before scanning the associated data. Since the module's output typically varies
// with each scanned file, you need to call [yrx_scanner_set_module_output] prior
// to each invocation of [yrx_scanner_scan]. Once [yrx_scanner_scan] is executed,
// the module's output is consumed and will be empty unless set again before the
// subsequent call.
//
// Case 2) applies when you have previously stored the module's output for certain
// scanned data. In such cases, when rescanning the data, you can utilize this
// function to supply the module's output, thereby preventing redundant computation
// by the module. This optimization enhances performance by eliminating the need
// for the module to reparse the scanned data.
//
// The `name` argument is either a YARA module name (i.e: "pe", "elf", "dotnet",
// etc.) or the fully-qualified name of the protobuf message associated to
// the module.
enum YRX_RESULT yrx_scanner_set_module_output(struct YRX_SCANNER *scanner,
                                              const char *name,
                                              const uint8_t *data,
                                              size_t len);

// Returns the error message for the most recent error returned by the
// scanner.
//
// The returned pointer is only valid until the next call to any of the
// yrx_scanner_xxxx functions. A call any of these functions can modify
// the last error, rendering the pointer to a previous error message
// invalid. Also, the pointer will be null if the scanner hasn't returned
// any error.
const char *yrx_scanner_last_error(const struct YRX_SCANNER *scanner);

#endif /* YARA_X */
