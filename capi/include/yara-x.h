#ifndef YARA_X
#define YARA_X

#pragma once

/* Generated with cbindgen:0.26.0 */

// This file is autogenerated by cbindgen. Don't modify it manually.

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>


typedef enum YRX_ERROR {
  SUCCESS,
  PANIC,
  SYNTAX_ERROR,
  INVALID_ARGUMENT,
} YRX_ERROR;

// A pattern within a rule.
typedef struct YRX_PATTERN YRX_PATTERN;

// The set of patterns declared in a YARA rule.
typedef struct YRX_PATTERNS YRX_PATTERNS;

// A single YARA rule.
typedef struct YRX_RULE YRX_RULE;

// A set of compiled YARA rules.
typedef struct YRX_RULES YRX_RULES;

// A scanner that scans data with a set of compiled YARA rules.
typedef struct YRX_SCANNER YRX_SCANNER;

// Callback function passed to the scanner via [`yrx_scanner_on_matching_rule`]
// which receives notifications about matching rules.
//
// The callback receives a pointer to the matching rule, represented by a
// [`YRX_RULE`] structure. This pointer is guaranteed to be valid while the
// callback function is being executed, but it may be freed after the callback
// function returns, so you cannot use the pointer outside the callback.
//
// It also receives the `user_data` pointer that was passed to the
// [`yrx_scanner_on_matching_rule`] function, which can point to arbitrary
// data owned by the user.
typedef void (*YRX_ON_MATCHING_RULE)(const struct YRX_RULE *rule,
                                     void *user_data);

// Contains information about a pattern match.
typedef struct YRX_MATCH {
  size_t offset;
  size_t length;
} YRX_MATCH;

// Compiles YARA source code and creates a [`YRX_RULES`] object that contains
// the compiled rules.
//
// The rules must be destroyed with [`yrx_rules_destroy`].
enum YRX_ERROR yrx_compile(const char *src,
                           struct YRX_RULES **rules);

// Creates a [`YRX_SCANNER`] object that can be used for scanning data with
// the provided [`YRX_RULES`].
//
// It's ok to pass the same [`YRX_RULES`] to multiple scanners, and use each
// scanner from a different thread. The scanner can be used as many times as
// you want, and it must be destroyed with [`yrx_scanner_destroy`]. Also, the
// scanner is valid as long as the rules are not destroyed, so, always destroy
// the [`YRX_SCANNER`] object before the [`YRX_RULES`] object.
enum YRX_ERROR yrx_scanner_create(const struct YRX_RULES *rules,
                                  struct YRX_SCANNER **scanner);

// Scans a data buffer.
enum YRX_ERROR yrx_scanner_scan(struct YRX_SCANNER *scanner,
                                const uint8_t *data,
                                size_t len);

// Sets a callback function that is called by the scanner for each rule that
// matched during a scan.
//
// The `user_data` pointer can be used to provide additional context to your
// callback function. If the callback is not set, the scanner doesn't notify
// about matching rules.
//
// See [`YRX_ON_MATCHING_RULE`] for more details.
enum YRX_ERROR yrx_scanner_on_matching_rule(struct YRX_SCANNER *scanner,
                                            YRX_ON_MATCHING_RULE callback,
                                            void *user_data);

// Destroys a [`YRX_SCANNER`] object.
void yrx_scanner_destroy(struct YRX_SCANNER *scanner);

// Destroys a [`YRX_RULES`] object.
void yrx_rules_destroy(struct YRX_RULES *rules);

// Returns the name of the rule represented by [`YRX_RULE`].
//
// Arguments `ident` and `len` are output parameters that receive pointers
// to a `const uint8_t*` and `size_t`, where this function will leave a pointer
// to the rule's name and its length, respectively. The rule's name is *NOT*
// null-terminated, and the pointer will be valid as long as the [`YRX_RULES`]
// object that contains the rule is not freed. The name is guaranteed to be a
// valid UTF-8 string.
enum YRX_ERROR yrx_rule_identifier(const struct YRX_RULE *rule,
                                   const uint8_t **ident,
                                   size_t *len);

// Returns the namespace of the rule represented by [`YRX_RULE`].
//
// Arguments `ns` and `len` are output parameters that receive pointers to a
// `const uint8_t*` and `size_t`, where this function will leave a pointer
// to the rule's namespace and its length, respectively. The namespace is *NOT*
// null-terminated, and the pointer will be valid as long as the [`YRX_RULES`]
// object that contains the rule is not freed. The namespace is guaranteed to
// be a valid UTF-8 string.
enum YRX_ERROR yrx_rule_namespace(const struct YRX_RULE *rule,
                                  const uint8_t **ns,
                                  size_t *len);

// Returns the all patterns defined by a rule, each pattern contains
// information about whether it matched or not, and where in the data it
// matched.
//
// The [`YRX_PATTERNS`] object must be destroyed with [`yrx_patterns_destroy`].
const struct YRX_PATTERNS *yrx_rule_patterns(const struct YRX_RULE *rule);

// Returns the number of patterns in a given [`YRX_PATTERNS`] object.
int32_t yrx_patterns_count(const struct YRX_PATTERNS *patterns);

// Returns the pattern with the give `index`, from a set of patterns represented
// by a [`YRX_PATTERNS`] object.
//
// The index must be between 0 and the value returned by [`yrx_patterns_count`],
// otherwise the result will be a null pointer. The result is also a null
// pointer if `patterns` is null.
const struct YRX_PATTERN *yrx_patterns_get(struct YRX_PATTERNS *patterns,
                                           size_t index);

// Destroys a [`YRX_PATTERNS`] object.
void yrx_patterns_destroy(struct YRX_PATTERNS *patterns);

// Returns the identifier of rule's pattern represented by [`YRX_PATTERN`].
//
// Arguments `ident` and `len` are output parameters that receive pointers to a
// `const uint8_t*` and `size_t`, where this function will leave a pointer
// to the rule's name and its length, respectively. The identifier is *NOT*
// null-terminated, and the pointer will be valid as long as the [`YRX_RULES`]
// object that contains the rule is not freed. The name is guaranteed to be a
// valid UTF-8 string.
enum YRX_ERROR yrx_pattern_identifier(const struct YRX_PATTERN *pattern,
                                      const uint8_t **ident,
                                      size_t *len);

enum YRX_ERROR yrx_pattern_matches(const struct YRX_PATTERN *pattern,
                                   const struct YRX_MATCH **matches,
                                   size_t *len);

#endif /* YARA_X */
