#ifndef YARA_X
#define YARA_X

#pragma once

/* Generated with cbindgen:0.27.0 */

// This file is autogenerated by cbindgen. Don't modify it manually.

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>


// Flag passed to [`yrx_compiler_create`] for producing colorful error
// messages.
#define YRX_COLORIZE_ERRORS 1

// Flag passed to [`yrx_compiler_create`] that enables a more relaxed
// syntax check for regular expressions.
//
// YARA-X enforces stricter regular expression syntax compared to YARA.
// For instance, YARA accepts invalid escape sequences and treats them
// as literal characters (e.g., \R is interpreted as a literal 'R'). It
// also allows some special characters to appear unescaped, inferring
// their meaning from the context (e.g., `{` and `}` in `/foo{}bar/` are
// literal, but in `/foo{0,1}bar/` they form the repetition operator
// `{0,1}`).
//
// When this flag is set, YARA-X mimics YARA's behavior, allowing
// constructs that YARA-X doesn't accept by default.
#define YRX_RELAXED_RE_SYNTAX 2

// Flag passed to [`yrx_compiler_create`] for treating slow patterns as
// errors instead of warnings.
#define YRX_ERROR_ON_SLOW_PATTERN 4

// Flag passed to [`yrx_compiler_create`] for treating slow loops as
// errors instead of warnings.
#define YRX_ERROR_ON_SLOW_LOOP 8

// Types of metadata values.
typedef enum YRX_METADATA_TYPE {
  I64,
  F64,
  BOOLEAN,
  STRING,
  BYTES,
} YRX_METADATA_TYPE;

// Error codes returned by functions in this API.
typedef enum YRX_RESULT {
  // Everything was OK.
  SUCCESS,
  // A syntax error occurred while compiling YARA rules.
  SYNTAX_ERROR,
  // An error occurred while defining or setting a global variable. This may
  // happen when a variable is defined twice and when you try to set a value
  // that doesn't correspond to the variable's type.
  VARIABLE_ERROR,
  // An error occurred during a scan operation.
  SCAN_ERROR,
  // A scan operation was aborted due to a timeout.
  SCAN_TIMEOUT,
  // An error indicating that some of the arguments passed to a function is
  // invalid. Usually indicates a nil pointer to a scanner or compiler.
  INVALID_ARGUMENT,
  // An error indicating that some of the strings passed to a function is
  // not valid UTF-8.
  INVALID_UTF8,
  // An error occurred while serializing/deserializing YARA rules.
  SERIALIZATION_ERROR,
  // An error returned when a rule doesn't have any metadata.
  NO_METADATA,
} YRX_RESULT;

// A compiler that takes YARA source code and produces compiled rules.
typedef struct YRX_COMPILER YRX_COMPILER;

// A pattern defined in a rule.
typedef struct YRX_PATTERN YRX_PATTERN;

// A single YARA rule.
typedef struct YRX_RULE YRX_RULE;

// A set of compiled YARA rules.
typedef struct YRX_RULES YRX_RULES;

// A scanner that scans data with a set of compiled YARA rules.
typedef struct YRX_SCANNER YRX_SCANNER;

// Represents a buffer with arbitrary data.
typedef struct YRX_BUFFER {
  // Pointer to the data contained in the buffer.
  uint8_t *data;
  // Length of data in bytes.
  size_t length;
} YRX_BUFFER;

// Contains information about a pattern match.
typedef struct YRX_MATCH {
  // Offset within the data where the match occurred.
  size_t offset;
  // Length of the match.
  size_t length;
} YRX_MATCH;

// Callback function passed to [`yrx_pattern_iter_matches`].
//
// The callback is called by all matches found for a pattern, and it receives
// a pointer to a [`YRX_MATCH`] structure. This pointer is guaranteed to be
// valid while the callback function is being executed, but it will be freed
// after the callback function returns, so you cannot use the pointer, or any
// other pointer contained in the structure, outside the callback.
//
// The callback also receives a `user_data` pointer that can point to arbitrary
// data owned by the user.
typedef void (*YRX_MATCH_CALLBACK)(const struct YRX_MATCH *match_,
                                   void *user_data);

// Represents a metadata value that contains raw bytes.
typedef struct YRX_METADATA_BYTES {
  // Number of bytes.
  size_t length;
  // Pointer to the bytes.
  const uint8_t *data;
} YRX_METADATA_BYTES;

// A metadata value.
typedef union YRX_METADATA_VALUE {
  // Value if the metadata is I64.
  int64_t i64;
  // Value if the metadata is F64.
  double f64;
  // Value if the metadata is BOOLEAN.
  bool boolean;
  // Value if the metadata is STRING.
  const char *string;
  // Value if the metadata is BYTES.
  struct YRX_METADATA_BYTES bytes;
} YRX_METADATA_VALUE;

// A metadata entry.
typedef struct YRX_METADATA {
  // Metadata identifier.
  const char *identifier;
  // Metadata type.
  enum YRX_METADATA_TYPE value_type;
  // Metadata value.
  //
  // This a union type, the variant that should be used is determined by the
  // type indicated in `value_type`.
  union YRX_METADATA_VALUE value;
} YRX_METADATA;

// Callback function passed to [`yrx_rule_iter_metadata`].
//
// The callback is called for each metadata in the rule, and receives a pointer
// to a [`YRX_METADATA`] structure. This pointer is guaranteed to be valid
// while the callback function is being executed, but it will be freed after
// the callback function returns, so you cannot use the pointer, or any other
// pointer contained in this structure, outside the callback.
//
// The callback also receives a `user_data` pointer that can point to arbitrary
// data owned by the user.
typedef void (*YRX_METADATA_CALLBACK)(const struct YRX_METADATA *metadata,
                                      void *user_data);

// Callback function passed to [`yrx_rule_iter_patterns`].
//
// The callback is called for each pattern defined in the rule, and it receives
// a pointer to a [`YRX_PATTERN`] structure. This pointer is guaranteed to be
// valid while the callback function is being executed, but it will be freed
// after the callback function returns, so you cannot use this pointer, or
// any other pointer contained in the structure, outside the callback.
//
// The callback also receives a `user_data` pointer that can point to arbitrary
// data owned by the user.
typedef void (*YRX_PATTERN_CALLBACK)(const struct YRX_PATTERN *pattern,
                                     void *user_data);

// Callback function passed to [`yrx_scanner_on_matching_rule`] or
// [`yrx_rules_iter`].
//
// The callback receives a pointer to a rule, represented by a [`YRX_RULE`]
// structure. This pointer is guaranteed to be valid while the callback
// function is being executed, but it may be freed after the callback function
// returns, so you cannot use the pointer outside the callback.
//
// It also receives the `user_data` pointer that can point to arbitrary data
// owned by the user.
typedef void (*YRX_RULE_CALLBACK)(const struct YRX_RULE *rule,
                                  void *user_data);

// Callback function passed to [`yrx_rules_iter_imports`].
//
// The callback is called for every module imported by the rules, and it
// receives a pointer to the module's name. This pointer is guaranteed to be
// valid while the callback function is being executed, but it will be freed
// after the callback function returns, so you cannot use the pointer outside
// the callback.
//
// The callback also receives a `user_data` pointer that can point to arbitrary
// data owned by the user.
typedef void (*YRX_IMPORT_CALLBACK)(const char *module_name,
                                    void *user_data);

// Returns the error message for the most recent function in this API
// invoked by the current thread.
//
// The returned pointer is only valid until this thread calls some other
// function, as it can modify the last error and render the pointer to
// a previous error message invalid. Also, the pointer will be null if
// the most recent function was successfully.
const char *yrx_last_error(void);

// Destroys a [`YRX_BUFFER`] object.
void yrx_buffer_destroy(struct YRX_BUFFER *buf);

// Compiles YARA source code and creates a [`YRX_RULES`] object that contains
// the compiled rules.
//
// The rules must be destroyed with [`yrx_rules_destroy`].
enum YRX_RESULT yrx_compile(const char *src,
                            struct YRX_RULES **rules);

// Creates a [`YRX_COMPILER`] object.
enum YRX_RESULT yrx_compiler_create(uint32_t flags,
                                    struct YRX_COMPILER **compiler);

// Destroys a [`YRX_COMPILER`] object.
void yrx_compiler_destroy(struct YRX_COMPILER *compiler);

// Adds a YARA source code to be compiled.
//
// This function can be called multiple times.
enum YRX_RESULT yrx_compiler_add_source(struct YRX_COMPILER *compiler,
                                        const char *src);

// Adds a YARA source code to be compiled, specifying an origin for the
// source code.
//
// This function is similar to [`yrx_compiler_add_source`], but in addition
// to the source code itself it provides a string that identifies the origin
// of the code, usually the file path from where the source was obtained.
//
// This origin is shown in error reports.
enum YRX_RESULT yrx_compiler_add_source_with_origin(struct YRX_COMPILER *compiler,
                                                    const char *src,
                                                    const char *origin);

// Tell the compiler that a YARA module is not supported.
//
// Import statements for ignored modules will be ignored without errors but a
// warning will be issued. Any rule that make use of an ignored module will be
// ignored, while the rest of rules that don't rely on that module will be
// correctly compiled.
enum YRX_RESULT yrx_compiler_ignore_module(struct YRX_COMPILER *compiler,
                                           const char *module);

// Tell the compiler that a YARA module can't be used.
//
// Import statements for the banned module will cause an error. The error
// message can be customized by using the given error title and message.
//
// If this function is called multiple times with the same module name,
// the error title and message will be updated.
enum YRX_RESULT yrx_compiler_ban_module(struct YRX_COMPILER *compiler,
                                        const char *module,
                                        const char *error_title,
                                        const char *error_msg);

// Creates a new namespace.
//
// Further calls to `yrx_compiler_add_source` will put the rules under the
// newly created namespace.
//
// The `namespace` argument must be pointer to null-terminated UTF-8 string.
// If the string is not valid UTF-8 the result is an `INVALID_ARGUMENT` error.
enum YRX_RESULT yrx_compiler_new_namespace(struct YRX_COMPILER *compiler,
                                           const char *namespace_);

// Defines a global variable of string type and sets its initial value.
enum YRX_RESULT yrx_compiler_define_global_str(struct YRX_COMPILER *compiler,
                                               const char *ident,
                                               const char *value);

// Defines a global variable of bool type and sets its initial value.
enum YRX_RESULT yrx_compiler_define_global_bool(struct YRX_COMPILER *compiler,
                                                const char *ident,
                                                bool value);

// Defines a global variable of integer type and sets its initial value.
enum YRX_RESULT yrx_compiler_define_global_int(struct YRX_COMPILER *compiler,
                                               const char *ident,
                                               int64_t value);

// Defines a global variable of float type and sets its initial value.
enum YRX_RESULT yrx_compiler_define_global_float(struct YRX_COMPILER *compiler,
                                                 const char *ident,
                                                 double value);

// Returns the errors encountered during the compilation in JSON format.
//
// In the address indicated by the `buf` pointer, the function will copy a
// `YRX_BUFFER*` pointer. The `YRX_BUFFER` structure represents a buffer
// that contains the JSON representation of the compilation errors.
//
// The JSON consists on an array of objects, each object representing a
// compilation error. The object has the following fields:
//
// * type: A string that describes the type of error.
// * code: Error code (e.g: "E009").
// * title: Error title (e.g: "unknown identifier `foo`").
// * labels: Array of labels.
// * text: The full text of the error report, as shown by the command-line tool.
//
// Here is an example:
//
// ```json
// [
//     {
//         "type": "UnknownIdentifier",
//         "code": "E009",
//         "title": "unknown identifier `foo`",
//         "labels": [
//             {
//                 "level": "error",
//                 "code_origin": null,
//                 "span": {"start":25,"end":28},
//                 "text": "this identifier has not been declared"
//             }
//         ],
//         "text": "... <full report here> ..."
//     }
// ]
// ```
//
// The [`YRX_BUFFER`] must be destroyed with [`yrx_buffer_destroy`].
enum YRX_RESULT yrx_compiler_errors_json(struct YRX_COMPILER *compiler,
                                         struct YRX_BUFFER **buf);

// Returns the warnings encountered during the compilation in JSON format.
//
// In the address indicated by the `buf` pointer, the function will copy a
// `YRX_BUFFER*` pointer. The `YRX_BUFFER` structure represents a buffer
// that contains the JSON representation of the warnings.
//
// The JSON consists on an array of objects, each object representing a
// warning. The object has the following fields:
//
// * type: A string that describes the type of warning.
// * code: Warning code (e.g: "slow_pattern").
// * title: Error title (e.g: "slow pattern").
// * labels: Array of labels.
// * text: The full text of the warning report, as shown by the command-line tool.
//
// Here is an example:
//
// ```json
// [
//     {
//         "type": "SlowPattern",
//         "code": "slow_pattern",
//         "title": "slow pattern",
//         "labels": [
//             {
//                 "level": "warning",
//                 "code_origin": null,
//                 "span": {"start":25,"end":28},
//                 "text": "this pattern may slow down the scan"
//             }
//         ],
//         "text": "... <full report here> ..."
//     }
// ]
// ```
//
// The [`YRX_BUFFER`] must be destroyed with [`yrx_buffer_destroy`].
enum YRX_RESULT yrx_compiler_warnings_json(struct YRX_COMPILER *compiler,
                                           struct YRX_BUFFER **buf);

// Builds the source code previously added to the compiler.
//
// After calling this function the compiler is reset to its initial state,
// (i.e: the state it had after returning from yrx_compiler_create) you can
// keep using it by adding more sources and calling this function again.
struct YRX_RULES *yrx_compiler_build(struct YRX_COMPILER *compiler);

// Returns the name of the pattern represented by [`YRX_PATTERN`].
//
// Arguments `ident` and `len` are output parameters that receive pointers
// to a `const uint8_t*` and `size_t`, where this function will leave a pointer
// to the rule's name and its length, respectively. The rule's name is *NOT*
// null-terminated, and the pointer will be valid as long as the [`YRX_RULES`]
// object that contains the pattern is not freed. The name is guaranteed to be
// a valid UTF-8 string.
enum YRX_RESULT yrx_pattern_identifier(const struct YRX_PATTERN *pattern,
                                       const uint8_t **ident,
                                       size_t *len);

// Iterates over the matches of a pattern, calling the callback with a pointer
// to a [`YRX_MATCH`] structure for each pattern.
//
// The `user_data` pointer can be used to provide additional context to your
// callback function.
//
// See [`YRX_MATCH_CALLBACK`] for more details.
enum YRX_RESULT yrx_pattern_iter_matches(const struct YRX_PATTERN *pattern,
                                         YRX_MATCH_CALLBACK callback,
                                         void *user_data);

// Returns the name of the rule represented by [`YRX_RULE`].
//
// Arguments `ident` and `len` are output parameters that receive pointers
// to a `const uint8_t*` and `size_t`, where this function will leave a pointer
// to the rule's name and its length, respectively. The rule's name is *NOT*
// null-terminated, and the pointer will be valid as long as the [`YRX_RULES`]
// object that contains the rule is not freed. The name is guaranteed to be a
// valid UTF-8 string.
enum YRX_RESULT yrx_rule_identifier(const struct YRX_RULE *rule,
                                    const uint8_t **ident,
                                    size_t *len);

// Returns the namespace of the rule represented by [`YRX_RULE`].
//
// Arguments `ns` and `len` are output parameters that receive pointers to a
// `const uint8_t*` and `size_t`, where this function will leave a pointer
// to the rule's namespace and its length, respectively. The namespace is *NOT*
// null-terminated, and the pointer will be valid as long as the [`YRX_RULES`]
// object that contains the rule is not freed. The namespace is guaranteed to
// be a valid UTF-8 string.
enum YRX_RESULT yrx_rule_namespace(const struct YRX_RULE *rule,
                                   const uint8_t **ns,
                                   size_t *len);

// Iterates over the metadata of a rule, calling the callback with a pointer
// to a [`YRX_METADATA`] structure for each metadata in the rule.
//
// The `user_data` pointer can be used to provide additional context to your
// callback function.
//
// See [`YRX_METADATA_CALLBACK`] for more details.
enum YRX_RESULT yrx_rule_iter_metadata(const struct YRX_RULE *rule,
                                       YRX_METADATA_CALLBACK callback,
                                       void *user_data);

// Iterates over the patterns in a rule, calling the callback with a pointer
// to a [`YRX_PATTERN`] structure for each pattern.
//
// The `user_data` pointer can be used to provide additional context to your
// callback function.
//
// See [`YRX_PATTERN_CALLBACK`] for more details.
enum YRX_RESULT yrx_rule_iter_patterns(const struct YRX_RULE *rule,
                                       YRX_PATTERN_CALLBACK callback,
                                       void *user_data);

// Iterates over the compiled rules, calling the callback function for each
// rule.
//
// The `user_data` pointer can be used to provide additional context to your
// callback function.
//
// See [`YRX_RULE_CALLBACK`] for more details.
enum YRX_RESULT yrx_rules_iter(const struct YRX_RULES *rules,
                               YRX_RULE_CALLBACK callback,
                               void *user_data);

// Returns the total number of rules.
//
// Returns -1 in case of error.
int yrx_rules_count(struct YRX_RULES *rules);

// Serializes the rules as a sequence of bytes.
//
// In the address indicated by the `buf` pointer, the function will copy a
// `YRX_BUFFER*` pointer. The `YRX_BUFFER` structure represents a buffer
// that contains the serialized rules. This structure has a pointer to the
// data itself, and its length.
//
// The [`YRX_BUFFER`] must be destroyed with [`yrx_buffer_destroy`].
enum YRX_RESULT yrx_rules_serialize(const struct YRX_RULES *rules,
                                    struct YRX_BUFFER **buf);

// Deserializes the rules from a sequence of bytes produced by
// [`yrx_rules_serialize`].
enum YRX_RESULT yrx_rules_deserialize(const uint8_t *data,
                                      size_t len,
                                      struct YRX_RULES **rules);

// Iterates over the modules imported by the rules, calling the callback with
// the name of each imported module.
//
// The `user_data` pointer can be used to provide additional context to your
// callback function.
//
// See [`YRX_IMPORT_CALLBACK`] for more details.
enum YRX_RESULT yrx_rules_iter_imports(const struct YRX_RULES *rules,
                                       YRX_IMPORT_CALLBACK callback,
                                       void *user_data);

// Destroys a [`YRX_RULES`] object.
void yrx_rules_destroy(struct YRX_RULES *rules);

// Creates a [`YRX_SCANNER`] object that can be used for scanning data with
// the provided [`YRX_RULES`].
//
// It's ok to pass the same [`YRX_RULES`] to multiple scanners, and use each
// scanner from a different thread. The scanner can be used as many times as
// you want, and it must be destroyed with [`yrx_scanner_destroy`]. Also, the
// scanner is valid as long as the rules are not destroyed, so, always destroy
// the [`YRX_SCANNER`] object before the [`YRX_RULES`] object.
enum YRX_RESULT yrx_scanner_create(const struct YRX_RULES *rules,
                                   struct YRX_SCANNER **scanner);

// Destroys a [`YRX_SCANNER`] object.
void yrx_scanner_destroy(struct YRX_SCANNER *scanner);

// Sets a timeout (in seconds) for scan operations.
//
// The scan functions will return a timeout error once the provided timeout
// duration has elapsed. The scanner will make every effort to stop promptly
// after the designated timeout duration. However, in some cases, particularly
// with rules containing only a few patterns, the scanner could potentially
// continue running for a longer period than the specified timeout.
enum YRX_RESULT yrx_scanner_set_timeout(struct YRX_SCANNER *scanner,
                                        uint64_t timeout);

// Scans a data buffer.
//
// `data` can be null as long as `len` is 0. In such cases its handled as
// empty data. Some YARA rules (i.e: `rule dummy { condition: true }`) can
// match even with empty data.
enum YRX_RESULT yrx_scanner_scan(struct YRX_SCANNER *scanner,
                                 const uint8_t *data,
                                 size_t len);

// Sets a callback function that is called by the scanner for each rule that
// matched during a scan.
//
// The `user_data` pointer can be used to provide additional context to your
// callback function. If the callback is not set, the scanner doesn't notify
// about matching rules.
//
// See [`YRX_RULE_CALLBACK`] for more details.
enum YRX_RESULT yrx_scanner_on_matching_rule(struct YRX_SCANNER *scanner,
                                             YRX_RULE_CALLBACK callback,
                                             void *user_data);

// Specifies the output data structure for a module.
//
// Each YARA module generates an output consisting of a data structure that
// contains information about the scanned file. This data structure is represented
// by a Protocol Buffer. Typically, you won't need to provide this output data
// yourself, as the YARA module automatically generates different outputs for
// each file it scans.
//
// However, there are two scenarios in which you may want to provide the output
// for a module yourself:
//
// 1) When the module does not produce any output on its own.
// 2) When you already know the output of the module for the upcoming file to
//    be scanned, and you prefer to reuse this data instead of generating it
//    again.
//
// Case 1) applies to certain modules lacking a main function, thus incapable of
// producing any output on their own. For such modules, you must set the output
// before scanning the associated data. Since the module's output typically varies
// with each scanned file, you need to call [yrx_scanner_set_module_output] prior
// to each invocation of [yrx_scanner_scan]. Once [yrx_scanner_scan] is executed,
// the module's output is consumed and will be empty unless set again before the
// subsequent call.
//
// Case 2) applies when you have previously stored the module's output for certain
// scanned data. In such cases, when rescanning the data, you can utilize this
// function to supply the module's output, thereby preventing redundant computation
// by the module. This optimization enhances performance by eliminating the need
// for the module to reparse the scanned data.
//
// The `name` argument is either a YARA module name (i.e: "pe", "elf", "dotnet",
// etc.) or the fully-qualified name of the protobuf message associated to
// the module. It must be a valid UTF-8 string.
enum YRX_RESULT yrx_scanner_set_module_output(struct YRX_SCANNER *scanner,
                                              const char *name,
                                              const uint8_t *data,
                                              size_t len);

// Sets the value of a global variable of type string.
enum YRX_RESULT yrx_scanner_set_global_str(struct YRX_SCANNER *scanner,
                                           const char *ident,
                                           const char *value);

// Sets the value of a global variable of type bool.
enum YRX_RESULT yrx_scanner_set_global_bool(struct YRX_SCANNER *scanner,
                                            const char *ident,
                                            bool value);

// Sets the value of a global variable of type int.
enum YRX_RESULT yrx_scanner_set_global_int(struct YRX_SCANNER *scanner,
                                           const char *ident,
                                           int64_t value);

// Sets the value of a global variable of type float.
enum YRX_RESULT yrx_scanner_set_global_float(struct YRX_SCANNER *scanner,
                                             const char *ident,
                                             double value);

#endif  /* YARA_X */
