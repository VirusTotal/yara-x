Scan a file or directory

<RULES_PATH> can be the path to a file containing YARA rules, or the path to a directory
containing *.yar or *.yara files. When <RULES_PATH> is a directory, it will be traversed
recursively. Multiple <RULES_PATH> can be specified.

Each path can be prefixed with a namespace, the namespace and the path are separated by
a semicolon (`:`), like in `namespace:rules_file.yar`. All rules in the path will be put
under the specified namespace, isolated from rules in other namespaces.

<TARGET_PATH> is the file or directory that will be scanned.

Examples:

yr scan rules_file.yar scanned_file
yr scan rules_dir scanned_file
yr scan namespace:rules_file.yar scanned_file
yr scan namespace:rules_dir scanned_file

Usage:
  yr scan [OPTIONS] <[NAMESPACE:]RULES_PATH>... <TARGET_PATH>

Arguments:
  <[NAMESPACE:]RULES_PATH>...
          Path to a YARA source file or directory (optionally prefixed with a namespace)

  <TARGET_PATH>
          Path to the file or directory that will be scanned

Options:
  -C, --compiled-rules
          Indicate that <RULES_PATH> is a file containing compiled rules
          
          YARA rules can be compiled with the `yr compile` command. The file produced by
          this command can be passed later to `yr scan` by using this flag.

  -c, --count
          Print only the number of matches per file

  -d, --define <VAR=VALUE>
          Define external variable
          
          Examples:
          
          --define some_int=1
          --define some_float=3.14
          --define some_bool=true
          --define some_str=\"foobar\"

      --disable-console-logs
          Disable printing console log messages

  -w, --disable-warnings[=<WARNING_ID>...]
          Disable warnings
          
          When used alone all warnings are disabled. It can receive a comma-separated
          list of with the names of the warnings to disable.
          
          Examples:
          
          --disable-warnings
          --disable-warnings=slow_patterns
          --disable-warnings=slow_rules,redundant_modifier"
          --disable-warnings=slow_rules --disable-warnings=redundant_modifier

      --ignore-module <MODULE>
          Ignore rules that use the specified module
          
          Rules that use the specified module will be ignored, as well as any rules that
          depends directly or indirectly on such rules.
          
          This option can be used more than once for ignored different modules.

  -x, --module-data <MODULE=FILE>
          Pass FILE's content as extra data to MODULE
          
          Some modules require supplementary data to work, in addition to the scanned
          file. This option allows you to provide that extra data. The flag can be used
          multiple times to supply data to different modules. The content of the FILE is
          loaded and interpreted by the respective module.
          
          Examples:
          
          --module-data=mymodule0=./example0.json --module-data=mymodule1=./example1.json
          
          In this example, the contents of example0.json and example1.json will be passed
          to mymodule0 and mymodule1, respectively.

  -n, --negate
          Print non-satisfied rules only

  -o, --output-format <FORMAT>
          Output format
          
          The format in which results will be displayed. Any errors or warnings will not
          be in this format, only results.
          
          Examples:
          
          --output-format=ndjson

          Possible values:
          - text:   Default output format
          - ndjson: Newline delimited JSON (i.e: one JSON object per line)
          - json:   JSON output (i.e: one JSON object for all results, only printed out at the end)

      --path-as-namespace
          Use file path as rule namespace

      --profiling
          Show profiling information

  -m, --print-meta
          Print rule metadata

  -e, --print-namespace
          Print rule namespace

  -s, --print-strings[=<N>]
          Print matching patterns
          
          The printed patterns can be optionally limited to <N> characters. By default they are limited
          to 120 characters.
          
          Examples:
          
          --print-strings
          --print-strings=50

  -g, --print-tags
          Print rule tags

  -r, --recursive[=<MAX_DEPTH>]
          Scan directories recursively
          
          When <TARGET_PATH> is a directory, this option enables recursive scanning of its contents.
          An optional <MAX_DEPTH> parameter can be specified to limit the scan depth. A MAX_DEPTH=1
          value restricts the scan to direct child directories of <TARGET_PATH>. If this option is
          not used, only the files within <TARGET_PATH> will be scanned, excluding its subdirectories.
          
          Examples:
          
          --recursive
          --recursive=3

      --relaxed-re-syntax
          Use a more relaxed syntax check while parsing regular expressions

      --scan-list
          Indicate that TARGET_PATH is a file containing the paths to be scanned
          
          <TARGET_PATH> must be a text file containing one path per line. The paths must
          be either absolute paths, or relative to the current directory.

  -z, --skip-larger <FILE_SIZE>
          Skip files larger than the given size

  -t, --tag <TAG>
          Print only rules tagged as TAG

  -p, --threads <NUM_THREADS>
          Use the specified number of threads
          
          The default value is automatically determined based on the number of CPU cores.

  -a, --timeout <SECONDS>
          Abort scanning after the given number of seconds

  -h, --help
          Print help (see a summary with '-h')
