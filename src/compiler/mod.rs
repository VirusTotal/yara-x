/*! Compiles YARA source code into binary form.

YARA rules must be compiled before they can be used for scanning data. This
module implements the YARA compiler.
*/
use std::fmt;
use std::path::Path;
use string_interner::symbol::SymbolU32;
use string_interner::{DefaultBackend, StringInterner};
use walrus::ValType::{I32, I64};
use walrus::{FunctionBuilder, FunctionId, Module, ModuleConfig};

use crate::ast::*;
use crate::compiler::emit::emit_expr;
use crate::compiler::semcheck::semcheck;
use crate::parser::{Error as ParserError, Parser, SourceCode};
use crate::report::ReportBuilder;
use crate::warnings::Warning;
use crate::Struct;

#[doc(inline)]
pub use crate::compiler::errors::*;

mod emit;
mod errors;
mod semcheck;

#[cfg(test)]
mod tests;

/// A YARA compiler.
pub struct Compiler<'a> {
    sym_tbl: Struct<'a>,
    colorize_errors: bool,
    report_builder: ReportBuilder,

    main_fn: FunctionBuilder,

    /// Pool that contains all the identifiers used in the rules. Each
    /// identifier appears only once, even if they are used by multiple
    /// rules. For example, the pool contains a single copy of the common
    /// identifier `$a`. Identifiers have an unique 32-bits ID that can
    /// be used for retrieving it from the pool.
    ident_pool: StringInterner<DefaultBackend<IdentID>>,

    /// The WebAssembly module containing the code for all rule conditions.
    wasm_mod: Module,

    /// Functions imported by the WebAssembly module.
    builtin_fn: BuiltinFnTable,

    /// A vector with the all the rules that has been compiled. A [`RuleID`]
    /// is an index in this vector.
    rules: Vec<CompiledRule>,

    /// A vector with all the patterns from all the rules. A [`PatternID`]
    /// is an index in this vector.
    patterns: Vec<Pattern>,

    /// Warnings generated while compiling the rules.
    warnings: Vec<Warning>,
}

impl<'a> Compiler<'a> {
    /// Creates a new YARA compiler.
    pub fn new() -> Self {
        let config = ModuleConfig::new();
        let mut wasm_mod = Module::with_config(config);

        let builtin_fn = Self::init_wasm_mod(&mut wasm_mod);

        let main_fn =
            walrus::FunctionBuilder::new(&mut wasm_mod.types, &[], &[]);

        Self {
            colorize_errors: false,
            warnings: vec![],
            rules: vec![],
            patterns: vec![],
            sym_tbl: Struct::new(),
            report_builder: ReportBuilder::new(),
            ident_pool: StringInterner::default(),
            builtin_fn,
            main_fn,
            wasm_mod,
        }
    }

    /// Specifies whether the compiler should produce colorful error messages.
    ///
    /// Colorized error messages contain ANSI escape sequences that make them
    /// look nicer on compatible consoles. The default setting is `false`.
    pub fn colorize_errors(mut self, b: bool) -> Self {
        self.colorize_errors = b;
        self
    }

    /// Adds a YARA source code to be compiled.
    ///
    /// This function can be called multiple times.
    pub fn add_source<'src, S>(mut self, src: S) -> Result<Self, Error>
    where
        S: Into<SourceCode<'src>>,
    {
        self.report_builder.with_colors(self.colorize_errors);

        let src = src.into();

        let mut ast = Parser::new()
            .set_report_builder(&self.report_builder)
            .build_ast(src.clone())?;

        // Transfer to the compiler the warnings generated by the parser.
        self.warnings.append(&mut ast.warnings);

        let mut rule_idx = 0;

        // TODO: make the iteration of namespaces and rule stable.
        for ns in ast.namespaces.values() {
            for module_name in ns.imports.iter() {
                // insert module_name in arena.
            }

            for rule in ns.rules.values() {
                // Create array with pairs (IdentID, PatternID) that describe
                // the patterns in a compiled rule.
                let pairs = if let Some(patterns) = &rule.patterns {
                    let mut pairs = Vec::with_capacity(patterns.len());
                    for pattern in patterns {
                        let ident_id = self
                            .ident_pool
                            .get_or_intern(pattern.identifier().as_str());

                        // The PatternID is the index of the pattern in
                        // `self.patterns`.
                        let pattern_id = self.patterns.len() as PatternID;

                        self.patterns.push(Pattern {});

                        pairs.push((ident_id, pattern_id));
                    }
                    pairs
                } else {
                    vec![]
                };

                let rule_id = self.rules.len() as RuleID;

                self.rules.push(CompiledRule {
                    ident: self
                        .ident_pool
                        .get_or_intern(rule.identifier.as_str()),
                    patterns: pairs,
                });

                let mut ctx = Context {
                    src: &src,
                    sym_tbl: &self.sym_tbl,
                    builtin_fn: &self.builtin_fn,
                    ident_pool: &self.ident_pool,
                    report_builder: &self.report_builder,
                    current_rule: self.rules.last().unwrap(),
                    warnings: &mut self.warnings,
                };

                // Check that the condition is boolean expression. This traverses
                // the condition's AST recursively checking the semantic validity
                // of all AST nodes.
                semcheck!(&mut ctx, Type::Bool, &rule.condition)?;

                // TODO: add rule name to declared identifiers.

                self.main_fn.func_body().block(None, |block| {
                    // The RuleID is the first argument to `rule_match`.
                    block.i32_const(rule_id as i32);

                    // The condition's result is the second argument to
                    // `rule_match`.
                    emit_expr(&ctx, block, &rule.condition);

                    // Emit call instruction for calling `rule_match`.
                    block.call(self.builtin_fn.rule_result);
                });
            }
        }

        Ok(self)
    }

    pub fn build(mut self) -> Result<CompiledRules, Error> {
        let main_fn = self.main_fn.finish(vec![], &mut self.wasm_mod.funcs);
        self.wasm_mod.exports.add("main", main_fn);

        Ok(CompiledRules {
            wasm_mod: self.wasm_mod,
            ident_pool: self.ident_pool,
            patterns: vec![],
            rules: vec![],
        })
    }
}

impl fmt::Debug for Compiler<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Compiler")
    }
}

impl Default for Compiler<'_> {
    fn default() -> Self {
        Self::new()
    }
}

impl Compiler<'_> {
    /// Initializes the WebAssembly module, creating all the required types and
    /// functions.
    fn init_wasm_mod(module: &mut Module) -> BuiltinFnTable {
        let ty = module.types.add(&[I32, I32], &[]);
        let (rule_result, _) =
            module.add_import_func("internal", "rule_result", ty);

        let ty = module.types.add(&[I32], &[I32]);
        let (is_pat_match, _) =
            module.add_import_func("internal", "is_pat_match", ty);

        let ty = module.types.add(&[I32, I64], &[I32]);
        let (is_pat_match_at, _) =
            module.add_import_func("internal", "is_pat_match_at", ty);

        let ty = module.types.add(&[I32, I64, I64], &[I32]);
        let (is_pat_match_in, _) =
            module.add_import_func("internal", "is_pat_match_in", ty);

        BuiltinFnTable {
            rule_result,
            is_pat_match,
            is_pat_match_at,
            is_pat_match_in,
        }
    }
}

/// ID associated to each identifier in the identifiers pool.
type IdentID = SymbolU32;

/// ID associated to each pattern.
type PatternID = i32;

/// ID associated to each rule.
type RuleID = i32;

/// Table with built-in functions used by the WebAssembly module.
///
/// The WebAssembly module generated for evaluating rule conditions needs to
/// call back to YARA for multiple tasks. For example, it calls YARA for
/// reporting rule matches, for asking if a pattern matches at a given offset,
/// for executing functions like `uint32()`, etc.
///
/// This table contains the [`FunctionId`] for such functions, which are
/// imported by the WebAssembly module and implemented by YARA.
struct BuiltinFnTable {
    /// Called for reporting whether a rule matches or not.
    /// Signature: (rule_id: i32, match: i32) -> ()
    rule_result: FunctionId,

    /// Ask YARA whether a pattern matched or not.
    /// Signature: (pattern_id: i32) -> (i32)
    is_pat_match: FunctionId,

    /// Ask YARA whether a pattern matched at a specific offset.
    /// Signature: (pattern_id: i32, offset: i64) -> (i32)
    is_pat_match_at: FunctionId,

    /// Ask YARA whether a pattern matched within a range of offsets.
    /// Signature: (pattern_id: i32, lower_bound: i64, upper_bound: i64) -> (i32)
    is_pat_match_in: FunctionId,
}

/// Structure that contains information and data structures required during the
/// the current compilation process.
struct Context<'a> {
    report_builder: &'a ReportBuilder,

    sym_tbl: &'a Struct<'a>,

    /// Source code that is being compiled.
    src: &'a SourceCode<'a>,

    /// Rule that is being compiled.
    current_rule: &'a CompiledRule,

    /// Warnings generated during the compilation.
    warnings: &'a mut Vec<Warning>,

    /// Pool with identifiers used in the rules.
    ident_pool: &'a StringInterner<DefaultBackend<IdentID>>,

    builtin_fn: &'a BuiltinFnTable,
}

impl<'a> Context<'a> {
    /// Given an [`IdentID`] returns the identifier as `&str`.
    ///
    /// Panics if no identifier has the provided [`IdentID`].
    #[inline]
    fn resolve_ident(&self, ident_id: IdentID) -> &str {
        self.ident_pool.resolve(ident_id).unwrap()
    }

    /// Given a pattern identifier (e.g. `$a`) search for it in the current
    /// rule and return its [`PatternID`]. Panics if the current rule does not
    /// have the requested pattern.
    fn get_pattern_from_current_rule(&self, ident: &Ident) -> PatternID {
        for (ident_id, pattern_id) in &self.current_rule.patterns {
            if self.resolve_ident(*ident_id) == ident.as_str() {
                return *pattern_id;
            }
        }
        panic!(
            "rule `{}` does not have pattern `{}` ",
            self.resolve_ident(self.current_rule.ident),
            ident.as_str()
        );
    }
}

/// A set of YARA rules in compiled form.
///
/// This is the result from [`Compiler::build`].
pub struct CompiledRules {
    /// Pool with identifiers used in the rules. Each identifier has its
    /// own [`IdentID`], which can be used for retrieving the identifier
    /// from the pool as a `&str`.
    ident_pool: StringInterner<DefaultBackend<IdentID>>,

    /// The WebAssembly module containing the code for all rule conditions.
    wasm_mod: Module,

    /// Vector containing all the compiled rules. A [`RuleID`] is an index
    /// in this vector.
    rules: Vec<CompiledRule>,

    /// Vector with all the patterns used in the rules. This vector has not
    /// duplicated items, if two different rules use the "MZ" pattern, it
    /// appears in this list once. A [`PatternID`] is an index in this
    /// vector.
    patterns: Vec<Pattern>,
}

/// A compiled rule.
struct CompiledRule {
    /// The ID of the rule identifier in the identifiers pool.
    ident: IdentID,

    /// Vector with all the patterns defined by this rule.
    patterns: Vec<(IdentID, PatternID)>,
}

/// A pattern in the compiled rules.
struct Pattern {}

impl CompiledRules {
    /// Emits a `.wasm` file with the WebAssembly module generated for the
    /// rules.
    ///
    /// When YARA rules are compiled their conditions are translated to
    /// WebAssembly. This function emits the WebAssembly module that contains
    /// the code produced for these rules. The module can be inspected or
    /// disassembled with third-party [tooling](https://github.com/WebAssembly/wabt).
    pub fn emit_wasm_file<P>(&mut self, path: P) -> Result<(), Error>
    where
        P: AsRef<Path>,
    {
        Ok(self.wasm_mod.emit_wasm_file(path)?)
    }
}
