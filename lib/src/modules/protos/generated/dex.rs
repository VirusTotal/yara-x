// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `dex.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

// @@protoc_insertion_point(message:dex.Dex)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Dex {
    // message fields
    // @@protoc_insertion_point(field:dex.Dex.is_dex)
    pub is_dex: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:dex.Dex.header)
    pub header: ::protobuf::MessageField<DexHeader>,
    // @@protoc_insertion_point(field:dex.Dex.strings)
    pub strings: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:dex.Dex.types)
    pub types: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:dex.Dex.protos)
    pub protos: ::std::vec::Vec<ProtoItem>,
    // @@protoc_insertion_point(field:dex.Dex.fields)
    pub fields: ::std::vec::Vec<FieldItem>,
    // @@protoc_insertion_point(field:dex.Dex.methods)
    pub methods: ::std::vec::Vec<MethodItem>,
    // @@protoc_insertion_point(field:dex.Dex.class_defs)
    pub class_defs: ::std::vec::Vec<ClassItem>,
    // @@protoc_insertion_point(field:dex.Dex.map_list)
    pub map_list: ::protobuf::MessageField<MapList>,
    // special fields
    // @@protoc_insertion_point(special_field:dex.Dex.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Dex {
    fn default() -> &'a Dex {
        <Dex as ::protobuf::Message>::default_instance()
    }
}

impl Dex {
    pub fn new() -> Dex {
        ::std::default::Default::default()
    }

    // optional bool is_dex = 1;

    pub fn is_dex(&self) -> bool {
        self.is_dex.unwrap_or(false)
    }

    pub fn clear_is_dex(&mut self) {
        self.is_dex = ::std::option::Option::None;
    }

    pub fn has_is_dex(&self) -> bool {
        self.is_dex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_dex(&mut self, v: bool) {
        self.is_dex = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_dex",
            |m: &Dex| { &m.is_dex },
            |m: &mut Dex| { &mut m.is_dex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DexHeader>(
            "header",
            |m: &Dex| { &m.header },
            |m: &mut Dex| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "strings",
            |m: &Dex| { &m.strings },
            |m: &mut Dex| { &mut m.strings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "types",
            |m: &Dex| { &m.types },
            |m: &mut Dex| { &mut m.types },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "protos",
            |m: &Dex| { &m.protos },
            |m: &mut Dex| { &mut m.protos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fields",
            |m: &Dex| { &m.fields },
            |m: &mut Dex| { &mut m.fields },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "methods",
            |m: &Dex| { &m.methods },
            |m: &mut Dex| { &mut m.methods },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "class_defs",
            |m: &Dex| { &m.class_defs },
            |m: &mut Dex| { &mut m.class_defs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MapList>(
            "map_list",
            |m: &Dex| { &m.map_list },
            |m: &mut Dex| { &mut m.map_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Dex>(
            "Dex",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Dex {
    const NAME: &'static str = "Dex";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_dex = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                26 => {
                    self.strings.push(is.read_string()?);
                },
                34 => {
                    self.types.push(is.read_string()?);
                },
                42 => {
                    self.protos.push(is.read_message()?);
                },
                50 => {
                    self.fields.push(is.read_message()?);
                },
                58 => {
                    self.methods.push(is.read_message()?);
                },
                66 => {
                    self.class_defs.push(is.read_message()?);
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.map_list)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.is_dex {
            my_size += 1 + 1;
        }
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.strings {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.types {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.protos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.fields {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.methods {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.class_defs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.map_list.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.is_dex {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.strings {
            os.write_string(3, &v)?;
        };
        for v in &self.types {
            os.write_string(4, &v)?;
        };
        for v in &self.protos {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.fields {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.methods {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        for v in &self.class_defs {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        if let Some(v) = self.map_list.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Dex {
        Dex::new()
    }

    fn clear(&mut self) {
        self.is_dex = ::std::option::Option::None;
        self.header.clear();
        self.strings.clear();
        self.types.clear();
        self.protos.clear();
        self.fields.clear();
        self.methods.clear();
        self.class_defs.clear();
        self.map_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Dex {
        static instance: Dex = Dex {
            is_dex: ::std::option::Option::None,
            header: ::protobuf::MessageField::none(),
            strings: ::std::vec::Vec::new(),
            types: ::std::vec::Vec::new(),
            protos: ::std::vec::Vec::new(),
            fields: ::std::vec::Vec::new(),
            methods: ::std::vec::Vec::new(),
            class_defs: ::std::vec::Vec::new(),
            map_list: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Dex {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Dex").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Dex {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Dex {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dex.DexHeader)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DexHeader {
    // message fields
    // @@protoc_insertion_point(field:dex.DexHeader.magic)
    pub magic: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dex.DexHeader.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dex.DexHeader.checksum)
    pub checksum: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dex.DexHeader.signature)
    pub signature: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dex.DexHeader.file_size)
    pub file_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dex.DexHeader.header_size)
    pub header_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dex.DexHeader.endian_tag)
    pub endian_tag: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dex.DexHeader.link_size)
    pub link_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dex.DexHeader.link_off)
    pub link_off: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dex.DexHeader.data_size)
    pub data_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dex.DexHeader.data_off)
    pub data_off: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dex.DexHeader.container_size)
    pub container_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dex.DexHeader.header_offset)
    pub header_offset: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dex.DexHeader.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DexHeader {
    fn default() -> &'a DexHeader {
        <DexHeader as ::protobuf::Message>::default_instance()
    }
}

impl DexHeader {
    pub fn new() -> DexHeader {
        ::std::default::Default::default()
    }

    // optional uint32 magic = 1;

    pub fn magic(&self) -> u32 {
        self.magic.unwrap_or(0)
    }

    pub fn clear_magic(&mut self) {
        self.magic = ::std::option::Option::None;
    }

    pub fn has_magic(&self) -> bool {
        self.magic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_magic(&mut self, v: u32) {
        self.magic = ::std::option::Option::Some(v);
    }

    // optional uint32 version = 2;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 checksum = 3;

    pub fn checksum(&self) -> u32 {
        self.checksum.unwrap_or(0)
    }

    pub fn clear_checksum(&mut self) {
        self.checksum = ::std::option::Option::None;
    }

    pub fn has_checksum(&self) -> bool {
        self.checksum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checksum(&mut self, v: u32) {
        self.checksum = ::std::option::Option::Some(v);
    }

    // optional string signature = 4;

    pub fn signature(&self) -> &str {
        match self.signature.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_signature(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::string::String) {
        self.signature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::string::String {
        if self.signature.is_none() {
            self.signature = ::std::option::Option::Some(::std::string::String::new());
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::string::String {
        self.signature.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 file_size = 5;

    pub fn file_size(&self) -> u32 {
        self.file_size.unwrap_or(0)
    }

    pub fn clear_file_size(&mut self) {
        self.file_size = ::std::option::Option::None;
    }

    pub fn has_file_size(&self) -> bool {
        self.file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: u32) {
        self.file_size = ::std::option::Option::Some(v);
    }

    // optional uint32 header_size = 6;

    pub fn header_size(&self) -> u32 {
        self.header_size.unwrap_or(0)
    }

    pub fn clear_header_size(&mut self) {
        self.header_size = ::std::option::Option::None;
    }

    pub fn has_header_size(&self) -> bool {
        self.header_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header_size(&mut self, v: u32) {
        self.header_size = ::std::option::Option::Some(v);
    }

    // optional uint32 endian_tag = 7;

    pub fn endian_tag(&self) -> u32 {
        self.endian_tag.unwrap_or(0)
    }

    pub fn clear_endian_tag(&mut self) {
        self.endian_tag = ::std::option::Option::None;
    }

    pub fn has_endian_tag(&self) -> bool {
        self.endian_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endian_tag(&mut self, v: u32) {
        self.endian_tag = ::std::option::Option::Some(v);
    }

    // optional uint32 link_size = 8;

    pub fn link_size(&self) -> u32 {
        self.link_size.unwrap_or(0)
    }

    pub fn clear_link_size(&mut self) {
        self.link_size = ::std::option::Option::None;
    }

    pub fn has_link_size(&self) -> bool {
        self.link_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_link_size(&mut self, v: u32) {
        self.link_size = ::std::option::Option::Some(v);
    }

    // optional uint32 link_off = 9;

    pub fn link_off(&self) -> u32 {
        self.link_off.unwrap_or(0)
    }

    pub fn clear_link_off(&mut self) {
        self.link_off = ::std::option::Option::None;
    }

    pub fn has_link_off(&self) -> bool {
        self.link_off.is_some()
    }

    // Param is passed by value, moved
    pub fn set_link_off(&mut self, v: u32) {
        self.link_off = ::std::option::Option::Some(v);
    }

    // optional uint32 data_size = 23;

    pub fn data_size(&self) -> u32 {
        self.data_size.unwrap_or(0)
    }

    pub fn clear_data_size(&mut self) {
        self.data_size = ::std::option::Option::None;
    }

    pub fn has_data_size(&self) -> bool {
        self.data_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_size(&mut self, v: u32) {
        self.data_size = ::std::option::Option::Some(v);
    }

    // optional uint32 data_off = 24;

    pub fn data_off(&self) -> u32 {
        self.data_off.unwrap_or(0)
    }

    pub fn clear_data_off(&mut self) {
        self.data_off = ::std::option::Option::None;
    }

    pub fn has_data_off(&self) -> bool {
        self.data_off.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_off(&mut self, v: u32) {
        self.data_off = ::std::option::Option::Some(v);
    }

    // optional uint32 container_size = 25;

    pub fn container_size(&self) -> u32 {
        self.container_size.unwrap_or(0)
    }

    pub fn clear_container_size(&mut self) {
        self.container_size = ::std::option::Option::None;
    }

    pub fn has_container_size(&self) -> bool {
        self.container_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_container_size(&mut self, v: u32) {
        self.container_size = ::std::option::Option::Some(v);
    }

    // optional uint32 header_offset = 26;

    pub fn header_offset(&self) -> u32 {
        self.header_offset.unwrap_or(0)
    }

    pub fn clear_header_offset(&mut self) {
        self.header_offset = ::std::option::Option::None;
    }

    pub fn has_header_offset(&self) -> bool {
        self.header_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header_offset(&mut self, v: u32) {
        self.header_offset = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "magic",
            |m: &DexHeader| { &m.magic },
            |m: &mut DexHeader| { &mut m.magic },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &DexHeader| { &m.version },
            |m: &mut DexHeader| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "checksum",
            |m: &DexHeader| { &m.checksum },
            |m: &mut DexHeader| { &mut m.checksum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "signature",
            |m: &DexHeader| { &m.signature },
            |m: &mut DexHeader| { &mut m.signature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_size",
            |m: &DexHeader| { &m.file_size },
            |m: &mut DexHeader| { &mut m.file_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "header_size",
            |m: &DexHeader| { &m.header_size },
            |m: &mut DexHeader| { &mut m.header_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "endian_tag",
            |m: &DexHeader| { &m.endian_tag },
            |m: &mut DexHeader| { &mut m.endian_tag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "link_size",
            |m: &DexHeader| { &m.link_size },
            |m: &mut DexHeader| { &mut m.link_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "link_off",
            |m: &DexHeader| { &m.link_off },
            |m: &mut DexHeader| { &mut m.link_off },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data_size",
            |m: &DexHeader| { &m.data_size },
            |m: &mut DexHeader| { &mut m.data_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data_off",
            |m: &DexHeader| { &m.data_off },
            |m: &mut DexHeader| { &mut m.data_off },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "container_size",
            |m: &DexHeader| { &m.container_size },
            |m: &mut DexHeader| { &mut m.container_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "header_offset",
            |m: &DexHeader| { &m.header_offset },
            |m: &mut DexHeader| { &mut m.header_offset },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DexHeader>(
            "DexHeader",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DexHeader {
    const NAME: &'static str = "DexHeader";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.magic = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.checksum = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.signature = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.file_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.header_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.endian_tag = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.link_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.link_off = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.data_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                192 => {
                    self.data_off = ::std::option::Option::Some(is.read_uint32()?);
                },
                200 => {
                    self.container_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                208 => {
                    self.header_offset = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.magic {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.checksum {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.file_size {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.header_size {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.endian_tag {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.link_size {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.link_off {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.data_size {
            my_size += ::protobuf::rt::uint32_size(23, v);
        }
        if let Some(v) = self.data_off {
            my_size += ::protobuf::rt::uint32_size(24, v);
        }
        if let Some(v) = self.container_size {
            my_size += ::protobuf::rt::uint32_size(25, v);
        }
        if let Some(v) = self.header_offset {
            my_size += ::protobuf::rt::uint32_size(26, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.magic {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.version {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.checksum {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.signature.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.file_size {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.header_size {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.endian_tag {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.link_size {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.link_off {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.data_size {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.data_off {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.container_size {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.header_offset {
            os.write_uint32(26, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DexHeader {
        DexHeader::new()
    }

    fn clear(&mut self) {
        self.magic = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.checksum = ::std::option::Option::None;
        self.signature = ::std::option::Option::None;
        self.file_size = ::std::option::Option::None;
        self.header_size = ::std::option::Option::None;
        self.endian_tag = ::std::option::Option::None;
        self.link_size = ::std::option::Option::None;
        self.link_off = ::std::option::Option::None;
        self.data_size = ::std::option::Option::None;
        self.data_off = ::std::option::Option::None;
        self.container_size = ::std::option::Option::None;
        self.header_offset = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DexHeader {
        static instance: DexHeader = DexHeader {
            magic: ::std::option::Option::None,
            version: ::std::option::Option::None,
            checksum: ::std::option::Option::None,
            signature: ::std::option::Option::None,
            file_size: ::std::option::Option::None,
            header_size: ::std::option::Option::None,
            endian_tag: ::std::option::Option::None,
            link_size: ::std::option::Option::None,
            link_off: ::std::option::Option::None,
            data_size: ::std::option::Option::None,
            data_off: ::std::option::Option::None,
            container_size: ::std::option::Option::None,
            header_offset: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DexHeader {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DexHeader").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DexHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DexHeader {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dex.ProtoItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoItem {
    // message fields
    // @@protoc_insertion_point(field:dex.ProtoItem.shorty)
    pub shorty: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dex.ProtoItem.return_type)
    pub return_type: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dex.ProtoItem.parameters_count)
    pub parameters_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dex.ProtoItem.parameters)
    pub parameters: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dex.ProtoItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoItem {
    fn default() -> &'a ProtoItem {
        <ProtoItem as ::protobuf::Message>::default_instance()
    }
}

impl ProtoItem {
    pub fn new() -> ProtoItem {
        ::std::default::Default::default()
    }

    // optional string shorty = 1;

    pub fn shorty(&self) -> &str {
        match self.shorty.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_shorty(&mut self) {
        self.shorty = ::std::option::Option::None;
    }

    pub fn has_shorty(&self) -> bool {
        self.shorty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shorty(&mut self, v: ::std::string::String) {
        self.shorty = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shorty(&mut self) -> &mut ::std::string::String {
        if self.shorty.is_none() {
            self.shorty = ::std::option::Option::Some(::std::string::String::new());
        }
        self.shorty.as_mut().unwrap()
    }

    // Take field
    pub fn take_shorty(&mut self) -> ::std::string::String {
        self.shorty.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string return_type = 2;

    pub fn return_type(&self) -> &str {
        match self.return_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_return_type(&mut self) {
        self.return_type = ::std::option::Option::None;
    }

    pub fn has_return_type(&self) -> bool {
        self.return_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_type(&mut self, v: ::std::string::String) {
        self.return_type = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_return_type(&mut self) -> &mut ::std::string::String {
        if self.return_type.is_none() {
            self.return_type = ::std::option::Option::Some(::std::string::String::new());
        }
        self.return_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_return_type(&mut self) -> ::std::string::String {
        self.return_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 parameters_count = 3;

    pub fn parameters_count(&self) -> u32 {
        self.parameters_count.unwrap_or(0)
    }

    pub fn clear_parameters_count(&mut self) {
        self.parameters_count = ::std::option::Option::None;
    }

    pub fn has_parameters_count(&self) -> bool {
        self.parameters_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parameters_count(&mut self, v: u32) {
        self.parameters_count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shorty",
            |m: &ProtoItem| { &m.shorty },
            |m: &mut ProtoItem| { &mut m.shorty },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "return_type",
            |m: &ProtoItem| { &m.return_type },
            |m: &mut ProtoItem| { &mut m.return_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "parameters_count",
            |m: &ProtoItem| { &m.parameters_count },
            |m: &mut ProtoItem| { &mut m.parameters_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "parameters",
            |m: &ProtoItem| { &m.parameters },
            |m: &mut ProtoItem| { &mut m.parameters },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoItem>(
            "ProtoItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoItem {
    const NAME: &'static str = "ProtoItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.shorty = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.return_type = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.parameters_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.parameters.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.shorty.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.return_type.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.parameters_count {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        for value in &self.parameters {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.shorty.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.return_type.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.parameters_count {
            os.write_uint32(3, v)?;
        }
        for v in &self.parameters {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoItem {
        ProtoItem::new()
    }

    fn clear(&mut self) {
        self.shorty = ::std::option::Option::None;
        self.return_type = ::std::option::Option::None;
        self.parameters_count = ::std::option::Option::None;
        self.parameters.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoItem {
        static instance: ProtoItem = ProtoItem {
            shorty: ::std::option::Option::None,
            return_type: ::std::option::Option::None,
            parameters_count: ::std::option::Option::None,
            parameters: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dex.FieldItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FieldItem {
    // message fields
    // @@protoc_insertion_point(field:dex.FieldItem.class)
    pub class: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dex.FieldItem.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dex.FieldItem.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dex.FieldItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FieldItem {
    fn default() -> &'a FieldItem {
        <FieldItem as ::protobuf::Message>::default_instance()
    }
}

impl FieldItem {
    pub fn new() -> FieldItem {
        ::std::default::Default::default()
    }

    // optional string class = 1;

    pub fn class(&self) -> &str {
        match self.class.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_class(&mut self) {
        self.class = ::std::option::Option::None;
    }

    pub fn has_class(&self) -> bool {
        self.class.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class(&mut self, v: ::std::string::String) {
        self.class = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_class(&mut self) -> &mut ::std::string::String {
        if self.class.is_none() {
            self.class = ::std::option::Option::Some(::std::string::String::new());
        }
        self.class.as_mut().unwrap()
    }

    // Take field
    pub fn take_class(&mut self) -> ::std::string::String {
        self.class.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string type = 2;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "class",
            |m: &FieldItem| { &m.class },
            |m: &mut FieldItem| { &mut m.class },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &FieldItem| { &m.type_ },
            |m: &mut FieldItem| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &FieldItem| { &m.name },
            |m: &mut FieldItem| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FieldItem>(
            "FieldItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FieldItem {
    const NAME: &'static str = "FieldItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.class = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.class.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.class.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.type_.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FieldItem {
        FieldItem::new()
    }

    fn clear(&mut self) {
        self.class = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FieldItem {
        static instance: FieldItem = FieldItem {
            class: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FieldItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FieldItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FieldItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FieldItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dex.MethodItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MethodItem {
    // message fields
    // @@protoc_insertion_point(field:dex.MethodItem.class)
    pub class: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dex.MethodItem.proto)
    pub proto: ::protobuf::MessageField<ProtoItem>,
    // @@protoc_insertion_point(field:dex.MethodItem.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dex.MethodItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MethodItem {
    fn default() -> &'a MethodItem {
        <MethodItem as ::protobuf::Message>::default_instance()
    }
}

impl MethodItem {
    pub fn new() -> MethodItem {
        ::std::default::Default::default()
    }

    // optional string class = 1;

    pub fn class(&self) -> &str {
        match self.class.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_class(&mut self) {
        self.class = ::std::option::Option::None;
    }

    pub fn has_class(&self) -> bool {
        self.class.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class(&mut self, v: ::std::string::String) {
        self.class = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_class(&mut self) -> &mut ::std::string::String {
        if self.class.is_none() {
            self.class = ::std::option::Option::Some(::std::string::String::new());
        }
        self.class.as_mut().unwrap()
    }

    // Take field
    pub fn take_class(&mut self) -> ::std::string::String {
        self.class.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "class",
            |m: &MethodItem| { &m.class },
            |m: &mut MethodItem| { &mut m.class },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProtoItem>(
            "proto",
            |m: &MethodItem| { &m.proto },
            |m: &mut MethodItem| { &mut m.proto },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &MethodItem| { &m.name },
            |m: &mut MethodItem| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MethodItem>(
            "MethodItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MethodItem {
    const NAME: &'static str = "MethodItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.class = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.proto)?;
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.class.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.proto.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.class.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.proto.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MethodItem {
        MethodItem::new()
    }

    fn clear(&mut self) {
        self.class = ::std::option::Option::None;
        self.proto.clear();
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MethodItem {
        static instance: MethodItem = MethodItem {
            class: ::std::option::Option::None,
            proto: ::protobuf::MessageField::none(),
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MethodItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MethodItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MethodItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MethodItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dex.ClassItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ClassItem {
    // message fields
    // @@protoc_insertion_point(field:dex.ClassItem.class)
    pub class: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dex.ClassItem.access_flags)
    pub access_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dex.ClassItem.superclass)
    pub superclass: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:dex.ClassItem.source_file)
    pub source_file: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:dex.ClassItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClassItem {
    fn default() -> &'a ClassItem {
        <ClassItem as ::protobuf::Message>::default_instance()
    }
}

impl ClassItem {
    pub fn new() -> ClassItem {
        ::std::default::Default::default()
    }

    // optional string class = 1;

    pub fn class(&self) -> &str {
        match self.class.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_class(&mut self) {
        self.class = ::std::option::Option::None;
    }

    pub fn has_class(&self) -> bool {
        self.class.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class(&mut self, v: ::std::string::String) {
        self.class = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_class(&mut self) -> &mut ::std::string::String {
        if self.class.is_none() {
            self.class = ::std::option::Option::Some(::std::string::String::new());
        }
        self.class.as_mut().unwrap()
    }

    // Take field
    pub fn take_class(&mut self) -> ::std::string::String {
        self.class.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 access_flags = 2;

    pub fn access_flags(&self) -> u32 {
        self.access_flags.unwrap_or(0)
    }

    pub fn clear_access_flags(&mut self) {
        self.access_flags = ::std::option::Option::None;
    }

    pub fn has_access_flags(&self) -> bool {
        self.access_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_access_flags(&mut self, v: u32) {
        self.access_flags = ::std::option::Option::Some(v);
    }

    // optional string superclass = 3;

    pub fn superclass(&self) -> &str {
        match self.superclass.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_superclass(&mut self) {
        self.superclass = ::std::option::Option::None;
    }

    pub fn has_superclass(&self) -> bool {
        self.superclass.is_some()
    }

    // Param is passed by value, moved
    pub fn set_superclass(&mut self, v: ::std::string::String) {
        self.superclass = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_superclass(&mut self) -> &mut ::std::string::String {
        if self.superclass.is_none() {
            self.superclass = ::std::option::Option::Some(::std::string::String::new());
        }
        self.superclass.as_mut().unwrap()
    }

    // Take field
    pub fn take_superclass(&mut self) -> ::std::string::String {
        self.superclass.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string source_file = 4;

    pub fn source_file(&self) -> &str {
        match self.source_file.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_source_file(&mut self) {
        self.source_file = ::std::option::Option::None;
    }

    pub fn has_source_file(&self) -> bool {
        self.source_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_file(&mut self, v: ::std::string::String) {
        self.source_file = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_file(&mut self) -> &mut ::std::string::String {
        if self.source_file.is_none() {
            self.source_file = ::std::option::Option::Some(::std::string::String::new());
        }
        self.source_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_source_file(&mut self) -> ::std::string::String {
        self.source_file.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "class",
            |m: &ClassItem| { &m.class },
            |m: &mut ClassItem| { &mut m.class },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "access_flags",
            |m: &ClassItem| { &m.access_flags },
            |m: &mut ClassItem| { &mut m.access_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "superclass",
            |m: &ClassItem| { &m.superclass },
            |m: &mut ClassItem| { &mut m.superclass },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_file",
            |m: &ClassItem| { &m.source_file },
            |m: &mut ClassItem| { &mut m.source_file },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClassItem>(
            "ClassItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClassItem {
    const NAME: &'static str = "ClassItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.class = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.access_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.superclass = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.source_file = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.class.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.access_flags {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.superclass.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.source_file.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.class.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.access_flags {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.superclass.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.source_file.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClassItem {
        ClassItem::new()
    }

    fn clear(&mut self) {
        self.class = ::std::option::Option::None;
        self.access_flags = ::std::option::Option::None;
        self.superclass = ::std::option::Option::None;
        self.source_file = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClassItem {
        static instance: ClassItem = ClassItem {
            class: ::std::option::Option::None,
            access_flags: ::std::option::Option::None,
            superclass: ::std::option::Option::None,
            source_file: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClassItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClassItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClassItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClassItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dex.MapList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MapList {
    // message fields
    // @@protoc_insertion_point(field:dex.MapList.size)
    pub size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dex.MapList.items)
    pub items: ::std::vec::Vec<MapItem>,
    // special fields
    // @@protoc_insertion_point(special_field:dex.MapList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MapList {
    fn default() -> &'a MapList {
        <MapList as ::protobuf::Message>::default_instance()
    }
}

impl MapList {
    pub fn new() -> MapList {
        ::std::default::Default::default()
    }

    // optional uint32 size = 1;

    pub fn size(&self) -> u32 {
        self.size.unwrap_or(0)
    }

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u32) {
        self.size = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "size",
            |m: &MapList| { &m.size },
            |m: &mut MapList| { &mut m.size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &MapList| { &m.items },
            |m: &mut MapList| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MapList>(
            "MapList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MapList {
    const NAME: &'static str = "MapList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.size = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.size {
            os.write_uint32(1, v)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MapList {
        MapList::new()
    }

    fn clear(&mut self) {
        self.size = ::std::option::Option::None;
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MapList {
        static instance: MapList = MapList {
            size: ::std::option::Option::None,
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MapList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MapList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MapList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MapList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:dex.MapItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MapItem {
    // message fields
    // @@protoc_insertion_point(field:dex.MapItem.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<TypeCode>>,
    // @@protoc_insertion_point(field:dex.MapItem.unused)
    pub unused: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dex.MapItem.size)
    pub size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:dex.MapItem.offset)
    pub offset: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:dex.MapItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MapItem {
    fn default() -> &'a MapItem {
        <MapItem as ::protobuf::Message>::default_instance()
    }
}

impl MapItem {
    pub fn new() -> MapItem {
        ::std::default::Default::default()
    }

    // optional .dex.TypeCode type = 1;

    pub fn type_(&self) -> TypeCode {
        match self.type_ {
            Some(e) => e.enum_value_or(TypeCode::TYPE_HEADER_ITEM),
            None => TypeCode::TYPE_HEADER_ITEM,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: TypeCode) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 unused = 2;

    pub fn unused(&self) -> u32 {
        self.unused.unwrap_or(0)
    }

    pub fn clear_unused(&mut self) {
        self.unused = ::std::option::Option::None;
    }

    pub fn has_unused(&self) -> bool {
        self.unused.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unused(&mut self, v: u32) {
        self.unused = ::std::option::Option::Some(v);
    }

    // optional uint32 size = 3;

    pub fn size(&self) -> u32 {
        self.size.unwrap_or(0)
    }

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u32) {
        self.size = ::std::option::Option::Some(v);
    }

    // optional uint32 offset = 4;

    pub fn offset(&self) -> u32 {
        self.offset.unwrap_or(0)
    }

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u32) {
        self.offset = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &MapItem| { &m.type_ },
            |m: &mut MapItem| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unused",
            |m: &MapItem| { &m.unused },
            |m: &mut MapItem| { &mut m.unused },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "size",
            |m: &MapItem| { &m.size },
            |m: &mut MapItem| { &mut m.size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "offset",
            |m: &MapItem| { &m.offset },
            |m: &mut MapItem| { &mut m.offset },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MapItem>(
            "MapItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MapItem {
    const NAME: &'static str = "MapItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.unused = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.size = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.offset = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.unused {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.unused {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.size {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MapItem {
        MapItem::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.unused = ::std::option::Option::None;
        self.size = ::std::option::Option::None;
        self.offset = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MapItem {
        static instance: MapItem = MapItem {
            type_: ::std::option::Option::None,
            unused: ::std::option::Option::None,
            size: ::std::option::Option::None,
            offset: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MapItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MapItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MapItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MapItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dex.AccessFlag)
pub enum AccessFlag {
    // @@protoc_insertion_point(enum_value:dex.AccessFlag.ACC_PUBLIC)
    ACC_PUBLIC = 1,
    // @@protoc_insertion_point(enum_value:dex.AccessFlag.ACC_PRIVATE)
    ACC_PRIVATE = 2,
    // @@protoc_insertion_point(enum_value:dex.AccessFlag.ACC_PROTECTED)
    ACC_PROTECTED = 4,
    // @@protoc_insertion_point(enum_value:dex.AccessFlag.ACC_STATIC)
    ACC_STATIC = 8,
    // @@protoc_insertion_point(enum_value:dex.AccessFlag.ACC_FINAL)
    ACC_FINAL = 16,
    // @@protoc_insertion_point(enum_value:dex.AccessFlag.ACC_SYNCHRONIZED)
    ACC_SYNCHRONIZED = 32,
    // @@protoc_insertion_point(enum_value:dex.AccessFlag.ACC_BRIDGE)
    ACC_BRIDGE = 64,
    // @@protoc_insertion_point(enum_value:dex.AccessFlag.ACC_VARARGS)
    ACC_VARARGS = 128,
    // @@protoc_insertion_point(enum_value:dex.AccessFlag.ACC_NATIVE)
    ACC_NATIVE = 256,
    // @@protoc_insertion_point(enum_value:dex.AccessFlag.ACC_INTERFACE)
    ACC_INTERFACE = 512,
    // @@protoc_insertion_point(enum_value:dex.AccessFlag.ACC_ABSTRACT)
    ACC_ABSTRACT = 1024,
    // @@protoc_insertion_point(enum_value:dex.AccessFlag.ACC_STRICT)
    ACC_STRICT = 2048,
    // @@protoc_insertion_point(enum_value:dex.AccessFlag.ACC_SYNTHETIC)
    ACC_SYNTHETIC = 4096,
    // @@protoc_insertion_point(enum_value:dex.AccessFlag.ACC_ANNOTATION)
    ACC_ANNOTATION = 8192,
    // @@protoc_insertion_point(enum_value:dex.AccessFlag.ACC_ENUM)
    ACC_ENUM = 16384,
    // @@protoc_insertion_point(enum_value:dex.AccessFlag.ACC_CONSTRUCTOR)
    ACC_CONSTRUCTOR = 65536,
    // @@protoc_insertion_point(enum_value:dex.AccessFlag.ACC_DECLARED_SYNCHRONIZED)
    ACC_DECLARED_SYNCHRONIZED = 131072,
}

impl ::protobuf::Enum for AccessFlag {
    const NAME: &'static str = "AccessFlag";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AccessFlag> {
        match value {
            1 => ::std::option::Option::Some(AccessFlag::ACC_PUBLIC),
            2 => ::std::option::Option::Some(AccessFlag::ACC_PRIVATE),
            4 => ::std::option::Option::Some(AccessFlag::ACC_PROTECTED),
            8 => ::std::option::Option::Some(AccessFlag::ACC_STATIC),
            16 => ::std::option::Option::Some(AccessFlag::ACC_FINAL),
            32 => ::std::option::Option::Some(AccessFlag::ACC_SYNCHRONIZED),
            64 => ::std::option::Option::Some(AccessFlag::ACC_BRIDGE),
            128 => ::std::option::Option::Some(AccessFlag::ACC_VARARGS),
            256 => ::std::option::Option::Some(AccessFlag::ACC_NATIVE),
            512 => ::std::option::Option::Some(AccessFlag::ACC_INTERFACE),
            1024 => ::std::option::Option::Some(AccessFlag::ACC_ABSTRACT),
            2048 => ::std::option::Option::Some(AccessFlag::ACC_STRICT),
            4096 => ::std::option::Option::Some(AccessFlag::ACC_SYNTHETIC),
            8192 => ::std::option::Option::Some(AccessFlag::ACC_ANNOTATION),
            16384 => ::std::option::Option::Some(AccessFlag::ACC_ENUM),
            65536 => ::std::option::Option::Some(AccessFlag::ACC_CONSTRUCTOR),
            131072 => ::std::option::Option::Some(AccessFlag::ACC_DECLARED_SYNCHRONIZED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<AccessFlag> {
        match str {
            "ACC_PUBLIC" => ::std::option::Option::Some(AccessFlag::ACC_PUBLIC),
            "ACC_PRIVATE" => ::std::option::Option::Some(AccessFlag::ACC_PRIVATE),
            "ACC_PROTECTED" => ::std::option::Option::Some(AccessFlag::ACC_PROTECTED),
            "ACC_STATIC" => ::std::option::Option::Some(AccessFlag::ACC_STATIC),
            "ACC_FINAL" => ::std::option::Option::Some(AccessFlag::ACC_FINAL),
            "ACC_SYNCHRONIZED" => ::std::option::Option::Some(AccessFlag::ACC_SYNCHRONIZED),
            "ACC_BRIDGE" => ::std::option::Option::Some(AccessFlag::ACC_BRIDGE),
            "ACC_VARARGS" => ::std::option::Option::Some(AccessFlag::ACC_VARARGS),
            "ACC_NATIVE" => ::std::option::Option::Some(AccessFlag::ACC_NATIVE),
            "ACC_INTERFACE" => ::std::option::Option::Some(AccessFlag::ACC_INTERFACE),
            "ACC_ABSTRACT" => ::std::option::Option::Some(AccessFlag::ACC_ABSTRACT),
            "ACC_STRICT" => ::std::option::Option::Some(AccessFlag::ACC_STRICT),
            "ACC_SYNTHETIC" => ::std::option::Option::Some(AccessFlag::ACC_SYNTHETIC),
            "ACC_ANNOTATION" => ::std::option::Option::Some(AccessFlag::ACC_ANNOTATION),
            "ACC_ENUM" => ::std::option::Option::Some(AccessFlag::ACC_ENUM),
            "ACC_CONSTRUCTOR" => ::std::option::Option::Some(AccessFlag::ACC_CONSTRUCTOR),
            "ACC_DECLARED_SYNCHRONIZED" => ::std::option::Option::Some(AccessFlag::ACC_DECLARED_SYNCHRONIZED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [AccessFlag] = &[
        AccessFlag::ACC_PUBLIC,
        AccessFlag::ACC_PRIVATE,
        AccessFlag::ACC_PROTECTED,
        AccessFlag::ACC_STATIC,
        AccessFlag::ACC_FINAL,
        AccessFlag::ACC_SYNCHRONIZED,
        AccessFlag::ACC_BRIDGE,
        AccessFlag::ACC_VARARGS,
        AccessFlag::ACC_NATIVE,
        AccessFlag::ACC_INTERFACE,
        AccessFlag::ACC_ABSTRACT,
        AccessFlag::ACC_STRICT,
        AccessFlag::ACC_SYNTHETIC,
        AccessFlag::ACC_ANNOTATION,
        AccessFlag::ACC_ENUM,
        AccessFlag::ACC_CONSTRUCTOR,
        AccessFlag::ACC_DECLARED_SYNCHRONIZED,
    ];
}

impl ::protobuf::EnumFull for AccessFlag {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("AccessFlag").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            AccessFlag::ACC_PUBLIC => 0,
            AccessFlag::ACC_PRIVATE => 1,
            AccessFlag::ACC_PROTECTED => 2,
            AccessFlag::ACC_STATIC => 3,
            AccessFlag::ACC_FINAL => 4,
            AccessFlag::ACC_SYNCHRONIZED => 5,
            AccessFlag::ACC_BRIDGE => 6,
            AccessFlag::ACC_VARARGS => 7,
            AccessFlag::ACC_NATIVE => 8,
            AccessFlag::ACC_INTERFACE => 9,
            AccessFlag::ACC_ABSTRACT => 10,
            AccessFlag::ACC_STRICT => 11,
            AccessFlag::ACC_SYNTHETIC => 12,
            AccessFlag::ACC_ANNOTATION => 13,
            AccessFlag::ACC_ENUM => 14,
            AccessFlag::ACC_CONSTRUCTOR => 15,
            AccessFlag::ACC_DECLARED_SYNCHRONIZED => 16,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for AccessFlag {
    fn default() -> Self {
        AccessFlag::ACC_PUBLIC
    }
}

impl AccessFlag {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<AccessFlag>("AccessFlag")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dex.AccessFlagSpecial)
pub enum AccessFlagSpecial {
    // @@protoc_insertion_point(enum_value:dex.AccessFlagSpecial.ACC_VOLATILE)
    ACC_VOLATILE = 64,
    // @@protoc_insertion_point(enum_value:dex.AccessFlagSpecial.ACC_TRANSIENT)
    ACC_TRANSIENT = 128,
}

impl ::protobuf::Enum for AccessFlagSpecial {
    const NAME: &'static str = "AccessFlagSpecial";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AccessFlagSpecial> {
        match value {
            64 => ::std::option::Option::Some(AccessFlagSpecial::ACC_VOLATILE),
            128 => ::std::option::Option::Some(AccessFlagSpecial::ACC_TRANSIENT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<AccessFlagSpecial> {
        match str {
            "ACC_VOLATILE" => ::std::option::Option::Some(AccessFlagSpecial::ACC_VOLATILE),
            "ACC_TRANSIENT" => ::std::option::Option::Some(AccessFlagSpecial::ACC_TRANSIENT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [AccessFlagSpecial] = &[
        AccessFlagSpecial::ACC_VOLATILE,
        AccessFlagSpecial::ACC_TRANSIENT,
    ];
}

impl ::protobuf::EnumFull for AccessFlagSpecial {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("AccessFlagSpecial").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            AccessFlagSpecial::ACC_VOLATILE => 0,
            AccessFlagSpecial::ACC_TRANSIENT => 1,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for AccessFlagSpecial {
    fn default() -> Self {
        AccessFlagSpecial::ACC_VOLATILE
    }
}

impl AccessFlagSpecial {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<AccessFlagSpecial>("AccessFlagSpecial")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:dex.TypeCode)
pub enum TypeCode {
    // @@protoc_insertion_point(enum_value:dex.TypeCode.TYPE_HEADER_ITEM)
    TYPE_HEADER_ITEM = 0,
    // @@protoc_insertion_point(enum_value:dex.TypeCode.TYPE_STRING_ID_ITEM)
    TYPE_STRING_ID_ITEM = 1,
    // @@protoc_insertion_point(enum_value:dex.TypeCode.TYPE_TYPE_ID_ITEM)
    TYPE_TYPE_ID_ITEM = 2,
    // @@protoc_insertion_point(enum_value:dex.TypeCode.TYPE_PROTO_ID_ITEM)
    TYPE_PROTO_ID_ITEM = 3,
    // @@protoc_insertion_point(enum_value:dex.TypeCode.TYPE_FIELD_ID_ITEM)
    TYPE_FIELD_ID_ITEM = 4,
    // @@protoc_insertion_point(enum_value:dex.TypeCode.TYPE_METHOD_ID_ITEM)
    TYPE_METHOD_ID_ITEM = 5,
    // @@protoc_insertion_point(enum_value:dex.TypeCode.TYPE_CLASS_DEF_ITEM)
    TYPE_CLASS_DEF_ITEM = 6,
    // @@protoc_insertion_point(enum_value:dex.TypeCode.TYPE_CALL_SITE_ID_ITEM)
    TYPE_CALL_SITE_ID_ITEM = 7,
    // @@protoc_insertion_point(enum_value:dex.TypeCode.TYPE_METHOD_HANDLE_ITEM)
    TYPE_METHOD_HANDLE_ITEM = 8,
    // @@protoc_insertion_point(enum_value:dex.TypeCode.TYPE_MAP_LIST)
    TYPE_MAP_LIST = 4096,
    // @@protoc_insertion_point(enum_value:dex.TypeCode.TYPE_TYPE_LIST)
    TYPE_TYPE_LIST = 4097,
    // @@protoc_insertion_point(enum_value:dex.TypeCode.TYPE_ANNOTATION_SET_REF_LIST)
    TYPE_ANNOTATION_SET_REF_LIST = 4098,
    // @@protoc_insertion_point(enum_value:dex.TypeCode.TYPE_ANNOTATION_SET_ITEM)
    TYPE_ANNOTATION_SET_ITEM = 4099,
    // @@protoc_insertion_point(enum_value:dex.TypeCode.TYPE_CLASS_DATA_ITEM)
    TYPE_CLASS_DATA_ITEM = 8192,
    // @@protoc_insertion_point(enum_value:dex.TypeCode.TYPE_CODE_ITEM)
    TYPE_CODE_ITEM = 8193,
    // @@protoc_insertion_point(enum_value:dex.TypeCode.TYPE_STRING_DATA_ITEM)
    TYPE_STRING_DATA_ITEM = 8194,
    // @@protoc_insertion_point(enum_value:dex.TypeCode.TYPE_DEBUG_INFO_ITEM)
    TYPE_DEBUG_INFO_ITEM = 8195,
    // @@protoc_insertion_point(enum_value:dex.TypeCode.TYPE_ANNOTATION_ITEM)
    TYPE_ANNOTATION_ITEM = 8196,
    // @@protoc_insertion_point(enum_value:dex.TypeCode.TYPE_ENCODED_ARRAY_ITEM)
    TYPE_ENCODED_ARRAY_ITEM = 8197,
    // @@protoc_insertion_point(enum_value:dex.TypeCode.TYPE_ANNOTATIONS_DIRECTORY_ITEM)
    TYPE_ANNOTATIONS_DIRECTORY_ITEM = 8198,
    // @@protoc_insertion_point(enum_value:dex.TypeCode.TYPE_HIDDENAPI_CLASS_DATA_ITEM)
    TYPE_HIDDENAPI_CLASS_DATA_ITEM = 61440,
}

impl ::protobuf::Enum for TypeCode {
    const NAME: &'static str = "TypeCode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TypeCode> {
        match value {
            0 => ::std::option::Option::Some(TypeCode::TYPE_HEADER_ITEM),
            1 => ::std::option::Option::Some(TypeCode::TYPE_STRING_ID_ITEM),
            2 => ::std::option::Option::Some(TypeCode::TYPE_TYPE_ID_ITEM),
            3 => ::std::option::Option::Some(TypeCode::TYPE_PROTO_ID_ITEM),
            4 => ::std::option::Option::Some(TypeCode::TYPE_FIELD_ID_ITEM),
            5 => ::std::option::Option::Some(TypeCode::TYPE_METHOD_ID_ITEM),
            6 => ::std::option::Option::Some(TypeCode::TYPE_CLASS_DEF_ITEM),
            7 => ::std::option::Option::Some(TypeCode::TYPE_CALL_SITE_ID_ITEM),
            8 => ::std::option::Option::Some(TypeCode::TYPE_METHOD_HANDLE_ITEM),
            4096 => ::std::option::Option::Some(TypeCode::TYPE_MAP_LIST),
            4097 => ::std::option::Option::Some(TypeCode::TYPE_TYPE_LIST),
            4098 => ::std::option::Option::Some(TypeCode::TYPE_ANNOTATION_SET_REF_LIST),
            4099 => ::std::option::Option::Some(TypeCode::TYPE_ANNOTATION_SET_ITEM),
            8192 => ::std::option::Option::Some(TypeCode::TYPE_CLASS_DATA_ITEM),
            8193 => ::std::option::Option::Some(TypeCode::TYPE_CODE_ITEM),
            8194 => ::std::option::Option::Some(TypeCode::TYPE_STRING_DATA_ITEM),
            8195 => ::std::option::Option::Some(TypeCode::TYPE_DEBUG_INFO_ITEM),
            8196 => ::std::option::Option::Some(TypeCode::TYPE_ANNOTATION_ITEM),
            8197 => ::std::option::Option::Some(TypeCode::TYPE_ENCODED_ARRAY_ITEM),
            8198 => ::std::option::Option::Some(TypeCode::TYPE_ANNOTATIONS_DIRECTORY_ITEM),
            61440 => ::std::option::Option::Some(TypeCode::TYPE_HIDDENAPI_CLASS_DATA_ITEM),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<TypeCode> {
        match str {
            "TYPE_HEADER_ITEM" => ::std::option::Option::Some(TypeCode::TYPE_HEADER_ITEM),
            "TYPE_STRING_ID_ITEM" => ::std::option::Option::Some(TypeCode::TYPE_STRING_ID_ITEM),
            "TYPE_TYPE_ID_ITEM" => ::std::option::Option::Some(TypeCode::TYPE_TYPE_ID_ITEM),
            "TYPE_PROTO_ID_ITEM" => ::std::option::Option::Some(TypeCode::TYPE_PROTO_ID_ITEM),
            "TYPE_FIELD_ID_ITEM" => ::std::option::Option::Some(TypeCode::TYPE_FIELD_ID_ITEM),
            "TYPE_METHOD_ID_ITEM" => ::std::option::Option::Some(TypeCode::TYPE_METHOD_ID_ITEM),
            "TYPE_CLASS_DEF_ITEM" => ::std::option::Option::Some(TypeCode::TYPE_CLASS_DEF_ITEM),
            "TYPE_CALL_SITE_ID_ITEM" => ::std::option::Option::Some(TypeCode::TYPE_CALL_SITE_ID_ITEM),
            "TYPE_METHOD_HANDLE_ITEM" => ::std::option::Option::Some(TypeCode::TYPE_METHOD_HANDLE_ITEM),
            "TYPE_MAP_LIST" => ::std::option::Option::Some(TypeCode::TYPE_MAP_LIST),
            "TYPE_TYPE_LIST" => ::std::option::Option::Some(TypeCode::TYPE_TYPE_LIST),
            "TYPE_ANNOTATION_SET_REF_LIST" => ::std::option::Option::Some(TypeCode::TYPE_ANNOTATION_SET_REF_LIST),
            "TYPE_ANNOTATION_SET_ITEM" => ::std::option::Option::Some(TypeCode::TYPE_ANNOTATION_SET_ITEM),
            "TYPE_CLASS_DATA_ITEM" => ::std::option::Option::Some(TypeCode::TYPE_CLASS_DATA_ITEM),
            "TYPE_CODE_ITEM" => ::std::option::Option::Some(TypeCode::TYPE_CODE_ITEM),
            "TYPE_STRING_DATA_ITEM" => ::std::option::Option::Some(TypeCode::TYPE_STRING_DATA_ITEM),
            "TYPE_DEBUG_INFO_ITEM" => ::std::option::Option::Some(TypeCode::TYPE_DEBUG_INFO_ITEM),
            "TYPE_ANNOTATION_ITEM" => ::std::option::Option::Some(TypeCode::TYPE_ANNOTATION_ITEM),
            "TYPE_ENCODED_ARRAY_ITEM" => ::std::option::Option::Some(TypeCode::TYPE_ENCODED_ARRAY_ITEM),
            "TYPE_ANNOTATIONS_DIRECTORY_ITEM" => ::std::option::Option::Some(TypeCode::TYPE_ANNOTATIONS_DIRECTORY_ITEM),
            "TYPE_HIDDENAPI_CLASS_DATA_ITEM" => ::std::option::Option::Some(TypeCode::TYPE_HIDDENAPI_CLASS_DATA_ITEM),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TypeCode] = &[
        TypeCode::TYPE_HEADER_ITEM,
        TypeCode::TYPE_STRING_ID_ITEM,
        TypeCode::TYPE_TYPE_ID_ITEM,
        TypeCode::TYPE_PROTO_ID_ITEM,
        TypeCode::TYPE_FIELD_ID_ITEM,
        TypeCode::TYPE_METHOD_ID_ITEM,
        TypeCode::TYPE_CLASS_DEF_ITEM,
        TypeCode::TYPE_CALL_SITE_ID_ITEM,
        TypeCode::TYPE_METHOD_HANDLE_ITEM,
        TypeCode::TYPE_MAP_LIST,
        TypeCode::TYPE_TYPE_LIST,
        TypeCode::TYPE_ANNOTATION_SET_REF_LIST,
        TypeCode::TYPE_ANNOTATION_SET_ITEM,
        TypeCode::TYPE_CLASS_DATA_ITEM,
        TypeCode::TYPE_CODE_ITEM,
        TypeCode::TYPE_STRING_DATA_ITEM,
        TypeCode::TYPE_DEBUG_INFO_ITEM,
        TypeCode::TYPE_ANNOTATION_ITEM,
        TypeCode::TYPE_ENCODED_ARRAY_ITEM,
        TypeCode::TYPE_ANNOTATIONS_DIRECTORY_ITEM,
        TypeCode::TYPE_HIDDENAPI_CLASS_DATA_ITEM,
    ];
}

impl ::protobuf::EnumFull for TypeCode {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("TypeCode").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            TypeCode::TYPE_HEADER_ITEM => 0,
            TypeCode::TYPE_STRING_ID_ITEM => 1,
            TypeCode::TYPE_TYPE_ID_ITEM => 2,
            TypeCode::TYPE_PROTO_ID_ITEM => 3,
            TypeCode::TYPE_FIELD_ID_ITEM => 4,
            TypeCode::TYPE_METHOD_ID_ITEM => 5,
            TypeCode::TYPE_CLASS_DEF_ITEM => 6,
            TypeCode::TYPE_CALL_SITE_ID_ITEM => 7,
            TypeCode::TYPE_METHOD_HANDLE_ITEM => 8,
            TypeCode::TYPE_MAP_LIST => 9,
            TypeCode::TYPE_TYPE_LIST => 10,
            TypeCode::TYPE_ANNOTATION_SET_REF_LIST => 11,
            TypeCode::TYPE_ANNOTATION_SET_ITEM => 12,
            TypeCode::TYPE_CLASS_DATA_ITEM => 13,
            TypeCode::TYPE_CODE_ITEM => 14,
            TypeCode::TYPE_STRING_DATA_ITEM => 15,
            TypeCode::TYPE_DEBUG_INFO_ITEM => 16,
            TypeCode::TYPE_ANNOTATION_ITEM => 17,
            TypeCode::TYPE_ENCODED_ARRAY_ITEM => 18,
            TypeCode::TYPE_ANNOTATIONS_DIRECTORY_ITEM => 19,
            TypeCode::TYPE_HIDDENAPI_CLASS_DATA_ITEM => 20,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for TypeCode {
    fn default() -> Self {
        TypeCode::TYPE_HEADER_ITEM
    }
}

impl TypeCode {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TypeCode>("TypeCode")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\tdex.proto\x12\x03dex\x1a\nyara.proto\"\xc7\x02\n\x03Dex\x12\x15\n\
    \x06is_dex\x18\x01\x20\x01(\x08R\x05isDex\x12&\n\x06header\x18\x02\x20\
    \x01(\x0b2\x0e.dex.DexHeaderR\x06header\x12\x18\n\x07strings\x18\x03\x20\
    \x03(\tR\x07strings\x12\x14\n\x05types\x18\x04\x20\x03(\tR\x05types\x12&\
    \n\x06protos\x18\x05\x20\x03(\x0b2\x0e.dex.ProtoItemR\x06protos\x12&\n\
    \x06fields\x18\x06\x20\x03(\x0b2\x0e.dex.FieldItemR\x06fields\x12)\n\x07\
    methods\x18\x07\x20\x03(\x0b2\x0f.dex.MethodItemR\x07methods\x12-\n\ncla\
    ss_defs\x18\x08\x20\x03(\x0b2\x0e.dex.ClassItemR\tclassDefs\x12'\n\x08ma\
    p_list\x18\t\x20\x01(\x0b2\x0c.dex.MapListR\x07mapList\"\xcd\x03\n\tDexH\
    eader\x12\x1d\n\x05magic\x18\x01\x20\x01(\rR\x05magicB\x07\x82\x93\x19\
    \x03*\x01x\x12\x18\n\x07version\x18\x02\x20\x01(\rR\x07version\x12#\n\
    \x08checksum\x18\x03\x20\x01(\rR\x08checksumB\x07\x82\x93\x19\x03*\x01x\
    \x12\x1c\n\tsignature\x18\x04\x20\x01(\tR\tsignature\x12\x1b\n\tfile_siz\
    e\x18\x05\x20\x01(\rR\x08fileSize\x12(\n\x0bheader_size\x18\x06\x20\x01(\
    \rR\nheaderSizeB\x07\x82\x93\x19\x03*\x01x\x12&\n\nendian_tag\x18\x07\
    \x20\x01(\rR\tendianTagB\x07\x82\x93\x19\x03*\x01x\x12\x1b\n\tlink_size\
    \x18\x08\x20\x01(\rR\x08linkSize\x12\"\n\x08link_off\x18\t\x20\x01(\rR\
    \x07linkOffB\x07\x82\x93\x19\x03*\x01x\x12\x1b\n\tdata_size\x18\x17\x20\
    \x01(\rR\x08dataSize\x12\"\n\x08data_off\x18\x18\x20\x01(\rR\x07dataOffB\
    \x07\x82\x93\x19\x03*\x01x\x12%\n\x0econtainer_size\x18\x19\x20\x01(\rR\
    \rcontainerSize\x12,\n\rheader_offset\x18\x1a\x20\x01(\rR\x0cheaderOffse\
    tB\x07\x82\x93\x19\x03*\x01x\"\x8f\x01\n\tProtoItem\x12\x16\n\x06shorty\
    \x18\x01\x20\x01(\tR\x06shorty\x12\x1f\n\x0breturn_type\x18\x02\x20\x01(\
    \tR\nreturnType\x12)\n\x10parameters_count\x18\x03\x20\x01(\rR\x0fparame\
    tersCount\x12\x1e\n\nparameters\x18\x04\x20\x03(\tR\nparameters\"I\n\tFi\
    eldItem\x12\x14\n\x05class\x18\x01\x20\x01(\tR\x05class\x12\x12\n\x04typ\
    e\x18\x02\x20\x01(\tR\x04type\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04n\
    ame\"\\\n\nMethodItem\x12\x14\n\x05class\x18\x01\x20\x01(\tR\x05class\
    \x12$\n\x05proto\x18\x02\x20\x01(\x0b2\x0e.dex.ProtoItemR\x05proto\x12\
    \x12\n\x04name\x18\x03\x20\x01(\tR\x04name\"\x9d\x01\n\tClassItem\x12\
    \x14\n\x05class\x18\x01\x20\x01(\tR\x05class\x129\n\x0caccess_flags\x18\
    \x02\x20\x01(\rR\x0baccessFlagsB\x16\x82\x93\x19\x12*\x10flags:AccessFla\
    g\x12\x1e\n\nsuperclass\x18\x03\x20\x01(\tR\nsuperclass\x12\x1f\n\x0bsou\
    rce_file\x18\x04\x20\x01(\tR\nsourceFile\"A\n\x07MapList\x12\x12\n\x04si\
    ze\x18\x01\x20\x01(\rR\x04size\x12\"\n\x05items\x18\x02\x20\x03(\x0b2\
    \x0c.dex.MapItemR\x05items\"y\n\x07MapItem\x12!\n\x04type\x18\x01\x20\
    \x01(\x0e2\r.dex.TypeCodeR\x04type\x12\x16\n\x06unused\x18\x02\x20\x01(\
    \rR\x06unused\x12\x12\n\x04size\x18\x03\x20\x01(\rR\x04size\x12\x1f\n\
    \x06offset\x18\x04\x20\x01(\rR\x06offsetB\x07\x82\x93\x19\x03*\x01x*\xd9\
    \x02\n\nAccessFlag\x12\x0e\n\nACC_PUBLIC\x10\x01\x12\x0f\n\x0bACC_PRIVAT\
    E\x10\x02\x12\x11\n\rACC_PROTECTED\x10\x04\x12\x0e\n\nACC_STATIC\x10\x08\
    \x12\r\n\tACC_FINAL\x10\x10\x12\x14\n\x10ACC_SYNCHRONIZED\x10\x20\x12\
    \x0e\n\nACC_BRIDGE\x10@\x12\x10\n\x0bACC_VARARGS\x10\x80\x01\x12\x0f\n\n\
    ACC_NATIVE\x10\x80\x02\x12\x12\n\rACC_INTERFACE\x10\x80\x04\x12\x11\n\
    \x0cACC_ABSTRACT\x10\x80\x08\x12\x0f\n\nACC_STRICT\x10\x80\x10\x12\x12\n\
    \rACC_SYNTHETIC\x10\x80\x20\x12\x13\n\x0eACC_ANNOTATION\x10\x80@\x12\x0e\
    \n\x08ACC_ENUM\x10\x80\x80\x01\x12\x15\n\x0fACC_CONSTRUCTOR\x10\x80\x80\
    \x04\x12\x1f\n\x19ACC_DECLARED_SYNCHRONIZED\x10\x80\x80\x08\x1a\x06\x92\
    \x93\x19\x02\x10\x01*A\n\x11AccessFlagSpecial\x12\x10\n\x0cACC_VOLATILE\
    \x10@\x12\x12\n\rACC_TRANSIENT\x10\x80\x01\x1a\x06\x92\x93\x19\x02\x10\
    \x01*\xca\x04\n\x08TypeCode\x12\x14\n\x10TYPE_HEADER_ITEM\x10\0\x12\x17\
    \n\x13TYPE_STRING_ID_ITEM\x10\x01\x12\x15\n\x11TYPE_TYPE_ID_ITEM\x10\x02\
    \x12\x16\n\x12TYPE_PROTO_ID_ITEM\x10\x03\x12\x16\n\x12TYPE_FIELD_ID_ITEM\
    \x10\x04\x12\x17\n\x13TYPE_METHOD_ID_ITEM\x10\x05\x12\x17\n\x13TYPE_CLAS\
    S_DEF_ITEM\x10\x06\x12\x1a\n\x16TYPE_CALL_SITE_ID_ITEM\x10\x07\x12\x1b\n\
    \x17TYPE_METHOD_HANDLE_ITEM\x10\x08\x12\x12\n\rTYPE_MAP_LIST\x10\x80\x20\
    \x12\x13\n\x0eTYPE_TYPE_LIST\x10\x81\x20\x12!\n\x1cTYPE_ANNOTATION_SET_R\
    EF_LIST\x10\x82\x20\x12\x1d\n\x18TYPE_ANNOTATION_SET_ITEM\x10\x83\x20\
    \x12\x19\n\x14TYPE_CLASS_DATA_ITEM\x10\x80@\x12\x13\n\x0eTYPE_CODE_ITEM\
    \x10\x81@\x12\x1a\n\x15TYPE_STRING_DATA_ITEM\x10\x82@\x12\x19\n\x14TYPE_\
    DEBUG_INFO_ITEM\x10\x83@\x12\x19\n\x14TYPE_ANNOTATION_ITEM\x10\x84@\x12\
    \x1c\n\x17TYPE_ENCODED_ARRAY_ITEM\x10\x85@\x12$\n\x1fTYPE_ANNOTATIONS_DI\
    RECTORY_ITEM\x10\x86@\x12$\n\x1eTYPE_HIDDENAPI_CLASS_DATA_ITEM\x10\x80\
    \xe0\x03\x1a\x06\x92\x93\x19\x02\x10\x01B#\xfa\x92\x19\x1f\n\x03dex\x12\
    \x07dex.Dex\x1a\x03dex\"\ndex-moduleb\x06proto2\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::yara::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(8);
            messages.push(Dex::generated_message_descriptor_data());
            messages.push(DexHeader::generated_message_descriptor_data());
            messages.push(ProtoItem::generated_message_descriptor_data());
            messages.push(FieldItem::generated_message_descriptor_data());
            messages.push(MethodItem::generated_message_descriptor_data());
            messages.push(ClassItem::generated_message_descriptor_data());
            messages.push(MapList::generated_message_descriptor_data());
            messages.push(MapItem::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(3);
            enums.push(AccessFlag::generated_enum_descriptor_data());
            enums.push(AccessFlagSpecial::generated_enum_descriptor_data());
            enums.push(TypeCode::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
