// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `pe.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

// @@protoc_insertion_point(message:pe.PE)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PE {
    // message fields
    // @@protoc_insertion_point(field:pe.PE.is_pe)
    pub is_pe: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:pe.PE.machine)
    pub machine: ::std::option::Option<::protobuf::EnumOrUnknown<Machine>>,
    // @@protoc_insertion_point(field:pe.PE.subsystem)
    pub subsystem: ::std::option::Option<::protobuf::EnumOrUnknown<Subsystem>>,
    // @@protoc_insertion_point(field:pe.PE.os_version)
    pub os_version: ::protobuf::MessageField<Version>,
    // @@protoc_insertion_point(field:pe.PE.subsystem_version)
    pub subsystem_version: ::protobuf::MessageField<Version>,
    // @@protoc_insertion_point(field:pe.PE.image_version)
    pub image_version: ::protobuf::MessageField<Version>,
    // @@protoc_insertion_point(field:pe.PE.linker_version)
    pub linker_version: ::protobuf::MessageField<Version>,
    // @@protoc_insertion_point(field:pe.PE.opthdr_magic)
    pub opthdr_magic: ::std::option::Option<::protobuf::EnumOrUnknown<OptionalMagic>>,
    // @@protoc_insertion_point(field:pe.PE.characteristics)
    pub characteristics: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.PE.dll_characteristics)
    pub dll_characteristics: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.PE.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.PE.image_base)
    pub image_base: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:pe.PE.checksum)
    pub checksum: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.PE.base_of_code)
    pub base_of_code: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.PE.base_of_data)
    pub base_of_data: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.PE.entry_point)
    pub entry_point: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.PE.entry_point_raw)
    pub entry_point_raw: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.PE.dll_name)
    pub dll_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:pe.PE.export_timestamp)
    pub export_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.PE.section_alignment)
    pub section_alignment: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.PE.file_alignment)
    pub file_alignment: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.PE.loader_flags)
    pub loader_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.PE.size_of_optional_header)
    pub size_of_optional_header: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.PE.size_of_code)
    pub size_of_code: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.PE.size_of_initialized_data)
    pub size_of_initialized_data: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.PE.size_of_uninitialized_data)
    pub size_of_uninitialized_data: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.PE.size_of_image)
    pub size_of_image: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.PE.size_of_headers)
    pub size_of_headers: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.PE.size_of_stack_reserve)
    pub size_of_stack_reserve: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:pe.PE.size_of_stack_commit)
    pub size_of_stack_commit: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:pe.PE.size_of_heap_reserve)
    pub size_of_heap_reserve: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:pe.PE.size_of_heap_commit)
    pub size_of_heap_commit: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:pe.PE.pointer_to_symbol_table)
    pub pointer_to_symbol_table: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.PE.win32_version_value)
    pub win32_version_value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.PE.number_of_symbols)
    pub number_of_symbols: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.PE.number_of_rva_and_sizes)
    pub number_of_rva_and_sizes: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.PE.number_of_sections)
    pub number_of_sections: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.PE.number_of_imported_functions)
    pub number_of_imported_functions: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:pe.PE.number_of_delayed_imported_functions)
    pub number_of_delayed_imported_functions: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:pe.PE.number_of_resources)
    pub number_of_resources: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:pe.PE.number_of_version_infos)
    pub number_of_version_infos: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:pe.PE.number_of_imports)
    pub number_of_imports: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:pe.PE.number_of_delayed_imports)
    pub number_of_delayed_imports: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:pe.PE.number_of_exports)
    pub number_of_exports: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:pe.PE.number_of_signatures)
    pub number_of_signatures: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:pe.PE.version_info)
    pub version_info: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:pe.PE.version_info_list)
    pub version_info_list: ::std::vec::Vec<KeyValue>,
    // @@protoc_insertion_point(field:pe.PE.rich_signature)
    pub rich_signature: ::protobuf::MessageField<RichSignature>,
    // @@protoc_insertion_point(field:pe.PE.pdb_path)
    pub pdb_path: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:pe.PE.sections)
    pub sections: ::std::vec::Vec<Section>,
    // @@protoc_insertion_point(field:pe.PE.data_directories)
    pub data_directories: ::std::vec::Vec<DirEntry>,
    // @@protoc_insertion_point(field:pe.PE.resource_timestamp)
    pub resource_timestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:pe.PE.resource_version)
    pub resource_version: ::protobuf::MessageField<Version>,
    // @@protoc_insertion_point(field:pe.PE.resources)
    pub resources: ::std::vec::Vec<Resource>,
    // @@protoc_insertion_point(field:pe.PE.import_details)
    pub import_details: ::std::vec::Vec<Import>,
    // @@protoc_insertion_point(field:pe.PE.delayed_import_details)
    pub delayed_import_details: ::std::vec::Vec<Import>,
    // @@protoc_insertion_point(field:pe.PE.export_details)
    pub export_details: ::std::vec::Vec<Export>,
    // @@protoc_insertion_point(field:pe.PE.is_signed)
    pub is_signed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:pe.PE.signatures)
    pub signatures: ::std::vec::Vec<Signature>,
    // @@protoc_insertion_point(field:pe.PE.overlay)
    pub overlay: ::protobuf::MessageField<Overlay>,
    // special fields
    // @@protoc_insertion_point(special_field:pe.PE.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PE {
    fn default() -> &'a PE {
        <PE as ::protobuf::Message>::default_instance()
    }
}

impl PE {
    pub fn new() -> PE {
        ::std::default::Default::default()
    }

    // required bool is_pe = 1;

    pub fn is_pe(&self) -> bool {
        self.is_pe.unwrap_or(false)
    }

    pub fn clear_is_pe(&mut self) {
        self.is_pe = ::std::option::Option::None;
    }

    pub fn has_is_pe(&self) -> bool {
        self.is_pe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_pe(&mut self, v: bool) {
        self.is_pe = ::std::option::Option::Some(v);
    }

    // optional .pe.Machine machine = 2;

    pub fn machine(&self) -> Machine {
        match self.machine {
            Some(e) => e.enum_value_or(Machine::MACHINE_UNKNOWN),
            None => Machine::MACHINE_UNKNOWN,
        }
    }

    pub fn clear_machine(&mut self) {
        self.machine = ::std::option::Option::None;
    }

    pub fn has_machine(&self) -> bool {
        self.machine.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine(&mut self, v: Machine) {
        self.machine = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .pe.Subsystem subsystem = 3;

    pub fn subsystem(&self) -> Subsystem {
        match self.subsystem {
            Some(e) => e.enum_value_or(Subsystem::SUBSYSTEM_UNKNOWN),
            None => Subsystem::SUBSYSTEM_UNKNOWN,
        }
    }

    pub fn clear_subsystem(&mut self) {
        self.subsystem = ::std::option::Option::None;
    }

    pub fn has_subsystem(&self) -> bool {
        self.subsystem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subsystem(&mut self, v: Subsystem) {
        self.subsystem = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .pe.OptionalMagic opthdr_magic = 8;

    pub fn opthdr_magic(&self) -> OptionalMagic {
        match self.opthdr_magic {
            Some(e) => e.enum_value_or(OptionalMagic::IMAGE_NT_OPTIONAL_HDR32_MAGIC),
            None => OptionalMagic::IMAGE_NT_OPTIONAL_HDR32_MAGIC,
        }
    }

    pub fn clear_opthdr_magic(&mut self) {
        self.opthdr_magic = ::std::option::Option::None;
    }

    pub fn has_opthdr_magic(&self) -> bool {
        self.opthdr_magic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_opthdr_magic(&mut self, v: OptionalMagic) {
        self.opthdr_magic = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 characteristics = 9;

    pub fn characteristics(&self) -> u32 {
        self.characteristics.unwrap_or(0)
    }

    pub fn clear_characteristics(&mut self) {
        self.characteristics = ::std::option::Option::None;
    }

    pub fn has_characteristics(&self) -> bool {
        self.characteristics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_characteristics(&mut self, v: u32) {
        self.characteristics = ::std::option::Option::Some(v);
    }

    // optional uint32 dll_characteristics = 10;

    pub fn dll_characteristics(&self) -> u32 {
        self.dll_characteristics.unwrap_or(0)
    }

    pub fn clear_dll_characteristics(&mut self) {
        self.dll_characteristics = ::std::option::Option::None;
    }

    pub fn has_dll_characteristics(&self) -> bool {
        self.dll_characteristics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dll_characteristics(&mut self, v: u32) {
        self.dll_characteristics = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 11;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint64 image_base = 12;

    pub fn image_base(&self) -> u64 {
        self.image_base.unwrap_or(0)
    }

    pub fn clear_image_base(&mut self) {
        self.image_base = ::std::option::Option::None;
    }

    pub fn has_image_base(&self) -> bool {
        self.image_base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_base(&mut self, v: u64) {
        self.image_base = ::std::option::Option::Some(v);
    }

    // optional uint32 checksum = 13;

    pub fn checksum(&self) -> u32 {
        self.checksum.unwrap_or(0)
    }

    pub fn clear_checksum(&mut self) {
        self.checksum = ::std::option::Option::None;
    }

    pub fn has_checksum(&self) -> bool {
        self.checksum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checksum(&mut self, v: u32) {
        self.checksum = ::std::option::Option::Some(v);
    }

    // optional uint32 base_of_code = 14;

    pub fn base_of_code(&self) -> u32 {
        self.base_of_code.unwrap_or(0)
    }

    pub fn clear_base_of_code(&mut self) {
        self.base_of_code = ::std::option::Option::None;
    }

    pub fn has_base_of_code(&self) -> bool {
        self.base_of_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base_of_code(&mut self, v: u32) {
        self.base_of_code = ::std::option::Option::Some(v);
    }

    // optional uint32 base_of_data = 15;

    pub fn base_of_data(&self) -> u32 {
        self.base_of_data.unwrap_or(0)
    }

    pub fn clear_base_of_data(&mut self) {
        self.base_of_data = ::std::option::Option::None;
    }

    pub fn has_base_of_data(&self) -> bool {
        self.base_of_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base_of_data(&mut self, v: u32) {
        self.base_of_data = ::std::option::Option::Some(v);
    }

    // optional uint32 entry_point = 16;

    pub fn entry_point(&self) -> u32 {
        self.entry_point.unwrap_or(0)
    }

    pub fn clear_entry_point(&mut self) {
        self.entry_point = ::std::option::Option::None;
    }

    pub fn has_entry_point(&self) -> bool {
        self.entry_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entry_point(&mut self, v: u32) {
        self.entry_point = ::std::option::Option::Some(v);
    }

    // optional uint32 entry_point_raw = 17;

    pub fn entry_point_raw(&self) -> u32 {
        self.entry_point_raw.unwrap_or(0)
    }

    pub fn clear_entry_point_raw(&mut self) {
        self.entry_point_raw = ::std::option::Option::None;
    }

    pub fn has_entry_point_raw(&self) -> bool {
        self.entry_point_raw.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entry_point_raw(&mut self, v: u32) {
        self.entry_point_raw = ::std::option::Option::Some(v);
    }

    // optional string dll_name = 18;

    pub fn dll_name(&self) -> &str {
        match self.dll_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_dll_name(&mut self) {
        self.dll_name = ::std::option::Option::None;
    }

    pub fn has_dll_name(&self) -> bool {
        self.dll_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dll_name(&mut self, v: ::std::string::String) {
        self.dll_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dll_name(&mut self) -> &mut ::std::string::String {
        if self.dll_name.is_none() {
            self.dll_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.dll_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_dll_name(&mut self) -> ::std::string::String {
        self.dll_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 export_timestamp = 19;

    pub fn export_timestamp(&self) -> u32 {
        self.export_timestamp.unwrap_or(0)
    }

    pub fn clear_export_timestamp(&mut self) {
        self.export_timestamp = ::std::option::Option::None;
    }

    pub fn has_export_timestamp(&self) -> bool {
        self.export_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_export_timestamp(&mut self, v: u32) {
        self.export_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 section_alignment = 20;

    pub fn section_alignment(&self) -> u32 {
        self.section_alignment.unwrap_or(0)
    }

    pub fn clear_section_alignment(&mut self) {
        self.section_alignment = ::std::option::Option::None;
    }

    pub fn has_section_alignment(&self) -> bool {
        self.section_alignment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_section_alignment(&mut self, v: u32) {
        self.section_alignment = ::std::option::Option::Some(v);
    }

    // optional uint32 file_alignment = 21;

    pub fn file_alignment(&self) -> u32 {
        self.file_alignment.unwrap_or(0)
    }

    pub fn clear_file_alignment(&mut self) {
        self.file_alignment = ::std::option::Option::None;
    }

    pub fn has_file_alignment(&self) -> bool {
        self.file_alignment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_alignment(&mut self, v: u32) {
        self.file_alignment = ::std::option::Option::Some(v);
    }

    // optional uint32 loader_flags = 22;

    pub fn loader_flags(&self) -> u32 {
        self.loader_flags.unwrap_or(0)
    }

    pub fn clear_loader_flags(&mut self) {
        self.loader_flags = ::std::option::Option::None;
    }

    pub fn has_loader_flags(&self) -> bool {
        self.loader_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loader_flags(&mut self, v: u32) {
        self.loader_flags = ::std::option::Option::Some(v);
    }

    // optional uint32 size_of_optional_header = 23;

    pub fn size_of_optional_header(&self) -> u32 {
        self.size_of_optional_header.unwrap_or(0)
    }

    pub fn clear_size_of_optional_header(&mut self) {
        self.size_of_optional_header = ::std::option::Option::None;
    }

    pub fn has_size_of_optional_header(&self) -> bool {
        self.size_of_optional_header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size_of_optional_header(&mut self, v: u32) {
        self.size_of_optional_header = ::std::option::Option::Some(v);
    }

    // optional uint32 size_of_code = 24;

    pub fn size_of_code(&self) -> u32 {
        self.size_of_code.unwrap_or(0)
    }

    pub fn clear_size_of_code(&mut self) {
        self.size_of_code = ::std::option::Option::None;
    }

    pub fn has_size_of_code(&self) -> bool {
        self.size_of_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size_of_code(&mut self, v: u32) {
        self.size_of_code = ::std::option::Option::Some(v);
    }

    // optional uint32 size_of_initialized_data = 25;

    pub fn size_of_initialized_data(&self) -> u32 {
        self.size_of_initialized_data.unwrap_or(0)
    }

    pub fn clear_size_of_initialized_data(&mut self) {
        self.size_of_initialized_data = ::std::option::Option::None;
    }

    pub fn has_size_of_initialized_data(&self) -> bool {
        self.size_of_initialized_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size_of_initialized_data(&mut self, v: u32) {
        self.size_of_initialized_data = ::std::option::Option::Some(v);
    }

    // optional uint32 size_of_uninitialized_data = 26;

    pub fn size_of_uninitialized_data(&self) -> u32 {
        self.size_of_uninitialized_data.unwrap_or(0)
    }

    pub fn clear_size_of_uninitialized_data(&mut self) {
        self.size_of_uninitialized_data = ::std::option::Option::None;
    }

    pub fn has_size_of_uninitialized_data(&self) -> bool {
        self.size_of_uninitialized_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size_of_uninitialized_data(&mut self, v: u32) {
        self.size_of_uninitialized_data = ::std::option::Option::Some(v);
    }

    // optional uint32 size_of_image = 27;

    pub fn size_of_image(&self) -> u32 {
        self.size_of_image.unwrap_or(0)
    }

    pub fn clear_size_of_image(&mut self) {
        self.size_of_image = ::std::option::Option::None;
    }

    pub fn has_size_of_image(&self) -> bool {
        self.size_of_image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size_of_image(&mut self, v: u32) {
        self.size_of_image = ::std::option::Option::Some(v);
    }

    // optional uint32 size_of_headers = 28;

    pub fn size_of_headers(&self) -> u32 {
        self.size_of_headers.unwrap_or(0)
    }

    pub fn clear_size_of_headers(&mut self) {
        self.size_of_headers = ::std::option::Option::None;
    }

    pub fn has_size_of_headers(&self) -> bool {
        self.size_of_headers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size_of_headers(&mut self, v: u32) {
        self.size_of_headers = ::std::option::Option::Some(v);
    }

    // optional uint64 size_of_stack_reserve = 29;

    pub fn size_of_stack_reserve(&self) -> u64 {
        self.size_of_stack_reserve.unwrap_or(0)
    }

    pub fn clear_size_of_stack_reserve(&mut self) {
        self.size_of_stack_reserve = ::std::option::Option::None;
    }

    pub fn has_size_of_stack_reserve(&self) -> bool {
        self.size_of_stack_reserve.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size_of_stack_reserve(&mut self, v: u64) {
        self.size_of_stack_reserve = ::std::option::Option::Some(v);
    }

    // optional uint64 size_of_stack_commit = 30;

    pub fn size_of_stack_commit(&self) -> u64 {
        self.size_of_stack_commit.unwrap_or(0)
    }

    pub fn clear_size_of_stack_commit(&mut self) {
        self.size_of_stack_commit = ::std::option::Option::None;
    }

    pub fn has_size_of_stack_commit(&self) -> bool {
        self.size_of_stack_commit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size_of_stack_commit(&mut self, v: u64) {
        self.size_of_stack_commit = ::std::option::Option::Some(v);
    }

    // optional uint64 size_of_heap_reserve = 31;

    pub fn size_of_heap_reserve(&self) -> u64 {
        self.size_of_heap_reserve.unwrap_or(0)
    }

    pub fn clear_size_of_heap_reserve(&mut self) {
        self.size_of_heap_reserve = ::std::option::Option::None;
    }

    pub fn has_size_of_heap_reserve(&self) -> bool {
        self.size_of_heap_reserve.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size_of_heap_reserve(&mut self, v: u64) {
        self.size_of_heap_reserve = ::std::option::Option::Some(v);
    }

    // optional uint64 size_of_heap_commit = 32;

    pub fn size_of_heap_commit(&self) -> u64 {
        self.size_of_heap_commit.unwrap_or(0)
    }

    pub fn clear_size_of_heap_commit(&mut self) {
        self.size_of_heap_commit = ::std::option::Option::None;
    }

    pub fn has_size_of_heap_commit(&self) -> bool {
        self.size_of_heap_commit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size_of_heap_commit(&mut self, v: u64) {
        self.size_of_heap_commit = ::std::option::Option::Some(v);
    }

    // optional uint32 pointer_to_symbol_table = 33;

    pub fn pointer_to_symbol_table(&self) -> u32 {
        self.pointer_to_symbol_table.unwrap_or(0)
    }

    pub fn clear_pointer_to_symbol_table(&mut self) {
        self.pointer_to_symbol_table = ::std::option::Option::None;
    }

    pub fn has_pointer_to_symbol_table(&self) -> bool {
        self.pointer_to_symbol_table.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pointer_to_symbol_table(&mut self, v: u32) {
        self.pointer_to_symbol_table = ::std::option::Option::Some(v);
    }

    // optional uint32 win32_version_value = 34;

    pub fn win32_version_value(&self) -> u32 {
        self.win32_version_value.unwrap_or(0)
    }

    pub fn clear_win32_version_value(&mut self) {
        self.win32_version_value = ::std::option::Option::None;
    }

    pub fn has_win32_version_value(&self) -> bool {
        self.win32_version_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_win32_version_value(&mut self, v: u32) {
        self.win32_version_value = ::std::option::Option::Some(v);
    }

    // optional uint32 number_of_symbols = 35;

    pub fn number_of_symbols(&self) -> u32 {
        self.number_of_symbols.unwrap_or(0)
    }

    pub fn clear_number_of_symbols(&mut self) {
        self.number_of_symbols = ::std::option::Option::None;
    }

    pub fn has_number_of_symbols(&self) -> bool {
        self.number_of_symbols.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number_of_symbols(&mut self, v: u32) {
        self.number_of_symbols = ::std::option::Option::Some(v);
    }

    // optional uint32 number_of_rva_and_sizes = 36;

    pub fn number_of_rva_and_sizes(&self) -> u32 {
        self.number_of_rva_and_sizes.unwrap_or(0)
    }

    pub fn clear_number_of_rva_and_sizes(&mut self) {
        self.number_of_rva_and_sizes = ::std::option::Option::None;
    }

    pub fn has_number_of_rva_and_sizes(&self) -> bool {
        self.number_of_rva_and_sizes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number_of_rva_and_sizes(&mut self, v: u32) {
        self.number_of_rva_and_sizes = ::std::option::Option::Some(v);
    }

    // optional uint32 number_of_sections = 37;

    pub fn number_of_sections(&self) -> u32 {
        self.number_of_sections.unwrap_or(0)
    }

    pub fn clear_number_of_sections(&mut self) {
        self.number_of_sections = ::std::option::Option::None;
    }

    pub fn has_number_of_sections(&self) -> bool {
        self.number_of_sections.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number_of_sections(&mut self, v: u32) {
        self.number_of_sections = ::std::option::Option::Some(v);
    }

    // optional uint64 number_of_imported_functions = 38;

    pub fn number_of_imported_functions(&self) -> u64 {
        self.number_of_imported_functions.unwrap_or(0)
    }

    pub fn clear_number_of_imported_functions(&mut self) {
        self.number_of_imported_functions = ::std::option::Option::None;
    }

    pub fn has_number_of_imported_functions(&self) -> bool {
        self.number_of_imported_functions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number_of_imported_functions(&mut self, v: u64) {
        self.number_of_imported_functions = ::std::option::Option::Some(v);
    }

    // optional uint64 number_of_delayed_imported_functions = 39;

    pub fn number_of_delayed_imported_functions(&self) -> u64 {
        self.number_of_delayed_imported_functions.unwrap_or(0)
    }

    pub fn clear_number_of_delayed_imported_functions(&mut self) {
        self.number_of_delayed_imported_functions = ::std::option::Option::None;
    }

    pub fn has_number_of_delayed_imported_functions(&self) -> bool {
        self.number_of_delayed_imported_functions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number_of_delayed_imported_functions(&mut self, v: u64) {
        self.number_of_delayed_imported_functions = ::std::option::Option::Some(v);
    }

    // optional uint64 number_of_resources = 40;

    pub fn number_of_resources(&self) -> u64 {
        self.number_of_resources.unwrap_or(0)
    }

    pub fn clear_number_of_resources(&mut self) {
        self.number_of_resources = ::std::option::Option::None;
    }

    pub fn has_number_of_resources(&self) -> bool {
        self.number_of_resources.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number_of_resources(&mut self, v: u64) {
        self.number_of_resources = ::std::option::Option::Some(v);
    }

    // optional uint64 number_of_version_infos = 41;

    pub fn number_of_version_infos(&self) -> u64 {
        self.number_of_version_infos.unwrap_or(0)
    }

    pub fn clear_number_of_version_infos(&mut self) {
        self.number_of_version_infos = ::std::option::Option::None;
    }

    pub fn has_number_of_version_infos(&self) -> bool {
        self.number_of_version_infos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number_of_version_infos(&mut self, v: u64) {
        self.number_of_version_infos = ::std::option::Option::Some(v);
    }

    // optional uint64 number_of_imports = 42;

    pub fn number_of_imports(&self) -> u64 {
        self.number_of_imports.unwrap_or(0)
    }

    pub fn clear_number_of_imports(&mut self) {
        self.number_of_imports = ::std::option::Option::None;
    }

    pub fn has_number_of_imports(&self) -> bool {
        self.number_of_imports.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number_of_imports(&mut self, v: u64) {
        self.number_of_imports = ::std::option::Option::Some(v);
    }

    // optional uint64 number_of_delayed_imports = 43;

    pub fn number_of_delayed_imports(&self) -> u64 {
        self.number_of_delayed_imports.unwrap_or(0)
    }

    pub fn clear_number_of_delayed_imports(&mut self) {
        self.number_of_delayed_imports = ::std::option::Option::None;
    }

    pub fn has_number_of_delayed_imports(&self) -> bool {
        self.number_of_delayed_imports.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number_of_delayed_imports(&mut self, v: u64) {
        self.number_of_delayed_imports = ::std::option::Option::Some(v);
    }

    // optional uint64 number_of_exports = 44;

    pub fn number_of_exports(&self) -> u64 {
        self.number_of_exports.unwrap_or(0)
    }

    pub fn clear_number_of_exports(&mut self) {
        self.number_of_exports = ::std::option::Option::None;
    }

    pub fn has_number_of_exports(&self) -> bool {
        self.number_of_exports.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number_of_exports(&mut self, v: u64) {
        self.number_of_exports = ::std::option::Option::Some(v);
    }

    // optional uint64 number_of_signatures = 45;

    pub fn number_of_signatures(&self) -> u64 {
        self.number_of_signatures.unwrap_or(0)
    }

    pub fn clear_number_of_signatures(&mut self) {
        self.number_of_signatures = ::std::option::Option::None;
    }

    pub fn has_number_of_signatures(&self) -> bool {
        self.number_of_signatures.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number_of_signatures(&mut self, v: u64) {
        self.number_of_signatures = ::std::option::Option::Some(v);
    }

    // optional bytes pdb_path = 49;

    pub fn pdb_path(&self) -> &[u8] {
        match self.pdb_path.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_pdb_path(&mut self) {
        self.pdb_path = ::std::option::Option::None;
    }

    pub fn has_pdb_path(&self) -> bool {
        self.pdb_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pdb_path(&mut self, v: ::std::vec::Vec<u8>) {
        self.pdb_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pdb_path(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pdb_path.is_none() {
            self.pdb_path = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.pdb_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_pdb_path(&mut self) -> ::std::vec::Vec<u8> {
        self.pdb_path.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 resource_timestamp = 52;

    pub fn resource_timestamp(&self) -> u64 {
        self.resource_timestamp.unwrap_or(0)
    }

    pub fn clear_resource_timestamp(&mut self) {
        self.resource_timestamp = ::std::option::Option::None;
    }

    pub fn has_resource_timestamp(&self) -> bool {
        self.resource_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resource_timestamp(&mut self, v: u64) {
        self.resource_timestamp = ::std::option::Option::Some(v);
    }

    // optional bool is_signed = 58;

    pub fn is_signed(&self) -> bool {
        self.is_signed.unwrap_or(false)
    }

    pub fn clear_is_signed(&mut self) {
        self.is_signed = ::std::option::Option::None;
    }

    pub fn has_is_signed(&self) -> bool {
        self.is_signed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_signed(&mut self, v: bool) {
        self.is_signed = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(60);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_pe",
            |m: &PE| { &m.is_pe },
            |m: &mut PE| { &mut m.is_pe },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "machine",
            |m: &PE| { &m.machine },
            |m: &mut PE| { &mut m.machine },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subsystem",
            |m: &PE| { &m.subsystem },
            |m: &mut PE| { &mut m.subsystem },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Version>(
            "os_version",
            |m: &PE| { &m.os_version },
            |m: &mut PE| { &mut m.os_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Version>(
            "subsystem_version",
            |m: &PE| { &m.subsystem_version },
            |m: &mut PE| { &mut m.subsystem_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Version>(
            "image_version",
            |m: &PE| { &m.image_version },
            |m: &mut PE| { &mut m.image_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Version>(
            "linker_version",
            |m: &PE| { &m.linker_version },
            |m: &mut PE| { &mut m.linker_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "opthdr_magic",
            |m: &PE| { &m.opthdr_magic },
            |m: &mut PE| { &mut m.opthdr_magic },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "characteristics",
            |m: &PE| { &m.characteristics },
            |m: &mut PE| { &mut m.characteristics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dll_characteristics",
            |m: &PE| { &m.dll_characteristics },
            |m: &mut PE| { &mut m.dll_characteristics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &PE| { &m.timestamp },
            |m: &mut PE| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "image_base",
            |m: &PE| { &m.image_base },
            |m: &mut PE| { &mut m.image_base },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "checksum",
            |m: &PE| { &m.checksum },
            |m: &mut PE| { &mut m.checksum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "base_of_code",
            |m: &PE| { &m.base_of_code },
            |m: &mut PE| { &mut m.base_of_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "base_of_data",
            |m: &PE| { &m.base_of_data },
            |m: &mut PE| { &mut m.base_of_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entry_point",
            |m: &PE| { &m.entry_point },
            |m: &mut PE| { &mut m.entry_point },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entry_point_raw",
            |m: &PE| { &m.entry_point_raw },
            |m: &mut PE| { &mut m.entry_point_raw },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dll_name",
            |m: &PE| { &m.dll_name },
            |m: &mut PE| { &mut m.dll_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "export_timestamp",
            |m: &PE| { &m.export_timestamp },
            |m: &mut PE| { &mut m.export_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "section_alignment",
            |m: &PE| { &m.section_alignment },
            |m: &mut PE| { &mut m.section_alignment },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_alignment",
            |m: &PE| { &m.file_alignment },
            |m: &mut PE| { &mut m.file_alignment },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "loader_flags",
            |m: &PE| { &m.loader_flags },
            |m: &mut PE| { &mut m.loader_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "size_of_optional_header",
            |m: &PE| { &m.size_of_optional_header },
            |m: &mut PE| { &mut m.size_of_optional_header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "size_of_code",
            |m: &PE| { &m.size_of_code },
            |m: &mut PE| { &mut m.size_of_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "size_of_initialized_data",
            |m: &PE| { &m.size_of_initialized_data },
            |m: &mut PE| { &mut m.size_of_initialized_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "size_of_uninitialized_data",
            |m: &PE| { &m.size_of_uninitialized_data },
            |m: &mut PE| { &mut m.size_of_uninitialized_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "size_of_image",
            |m: &PE| { &m.size_of_image },
            |m: &mut PE| { &mut m.size_of_image },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "size_of_headers",
            |m: &PE| { &m.size_of_headers },
            |m: &mut PE| { &mut m.size_of_headers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "size_of_stack_reserve",
            |m: &PE| { &m.size_of_stack_reserve },
            |m: &mut PE| { &mut m.size_of_stack_reserve },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "size_of_stack_commit",
            |m: &PE| { &m.size_of_stack_commit },
            |m: &mut PE| { &mut m.size_of_stack_commit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "size_of_heap_reserve",
            |m: &PE| { &m.size_of_heap_reserve },
            |m: &mut PE| { &mut m.size_of_heap_reserve },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "size_of_heap_commit",
            |m: &PE| { &m.size_of_heap_commit },
            |m: &mut PE| { &mut m.size_of_heap_commit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pointer_to_symbol_table",
            |m: &PE| { &m.pointer_to_symbol_table },
            |m: &mut PE| { &mut m.pointer_to_symbol_table },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "win32_version_value",
            |m: &PE| { &m.win32_version_value },
            |m: &mut PE| { &mut m.win32_version_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "number_of_symbols",
            |m: &PE| { &m.number_of_symbols },
            |m: &mut PE| { &mut m.number_of_symbols },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "number_of_rva_and_sizes",
            |m: &PE| { &m.number_of_rva_and_sizes },
            |m: &mut PE| { &mut m.number_of_rva_and_sizes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "number_of_sections",
            |m: &PE| { &m.number_of_sections },
            |m: &mut PE| { &mut m.number_of_sections },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "number_of_imported_functions",
            |m: &PE| { &m.number_of_imported_functions },
            |m: &mut PE| { &mut m.number_of_imported_functions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "number_of_delayed_imported_functions",
            |m: &PE| { &m.number_of_delayed_imported_functions },
            |m: &mut PE| { &mut m.number_of_delayed_imported_functions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "number_of_resources",
            |m: &PE| { &m.number_of_resources },
            |m: &mut PE| { &mut m.number_of_resources },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "number_of_version_infos",
            |m: &PE| { &m.number_of_version_infos },
            |m: &mut PE| { &mut m.number_of_version_infos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "number_of_imports",
            |m: &PE| { &m.number_of_imports },
            |m: &mut PE| { &mut m.number_of_imports },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "number_of_delayed_imports",
            |m: &PE| { &m.number_of_delayed_imports },
            |m: &mut PE| { &mut m.number_of_delayed_imports },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "number_of_exports",
            |m: &PE| { &m.number_of_exports },
            |m: &mut PE| { &mut m.number_of_exports },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "number_of_signatures",
            |m: &PE| { &m.number_of_signatures },
            |m: &mut PE| { &mut m.number_of_signatures },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "version_info",
            |m: &PE| { &m.version_info },
            |m: &mut PE| { &mut m.version_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "version_info_list",
            |m: &PE| { &m.version_info_list },
            |m: &mut PE| { &mut m.version_info_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RichSignature>(
            "rich_signature",
            |m: &PE| { &m.rich_signature },
            |m: &mut PE| { &mut m.rich_signature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pdb_path",
            |m: &PE| { &m.pdb_path },
            |m: &mut PE| { &mut m.pdb_path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sections",
            |m: &PE| { &m.sections },
            |m: &mut PE| { &mut m.sections },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data_directories",
            |m: &PE| { &m.data_directories },
            |m: &mut PE| { &mut m.data_directories },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "resource_timestamp",
            |m: &PE| { &m.resource_timestamp },
            |m: &mut PE| { &mut m.resource_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Version>(
            "resource_version",
            |m: &PE| { &m.resource_version },
            |m: &mut PE| { &mut m.resource_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "resources",
            |m: &PE| { &m.resources },
            |m: &mut PE| { &mut m.resources },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "import_details",
            |m: &PE| { &m.import_details },
            |m: &mut PE| { &mut m.import_details },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "delayed_import_details",
            |m: &PE| { &m.delayed_import_details },
            |m: &mut PE| { &mut m.delayed_import_details },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "export_details",
            |m: &PE| { &m.export_details },
            |m: &mut PE| { &mut m.export_details },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_signed",
            |m: &PE| { &m.is_signed },
            |m: &mut PE| { &mut m.is_signed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "signatures",
            |m: &PE| { &m.signatures },
            |m: &mut PE| { &mut m.signatures },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Overlay>(
            "overlay",
            |m: &PE| { &m.overlay },
            |m: &mut PE| { &mut m.overlay },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PE>(
            "PE",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PE {
    const NAME: &'static str = "PE";

    fn is_initialized(&self) -> bool {
        if self.is_pe.is_none() {
            return false;
        }
        for v in &self.os_version {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.subsystem_version {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.image_version {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.linker_version {
            if !v.is_initialized() {
                return false;
            }
        };
        // TODO: check map values are initialized
        for v in &self.version_info_list {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rich_signature {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sections {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.data_directories {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.resource_version {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.resources {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.import_details {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.delayed_import_details {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.export_details {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.signatures {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.overlay {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_pe = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.machine = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.subsystem = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.os_version)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.subsystem_version)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.image_version)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.linker_version)?;
                },
                64 => {
                    self.opthdr_magic = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                72 => {
                    self.characteristics = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.dll_characteristics = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.image_base = ::std::option::Option::Some(is.read_uint64()?);
                },
                104 => {
                    self.checksum = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.base_of_code = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.base_of_data = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.entry_point = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.entry_point_raw = ::std::option::Option::Some(is.read_uint32()?);
                },
                146 => {
                    self.dll_name = ::std::option::Option::Some(is.read_string()?);
                },
                152 => {
                    self.export_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.section_alignment = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.file_alignment = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.loader_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.size_of_optional_header = ::std::option::Option::Some(is.read_uint32()?);
                },
                192 => {
                    self.size_of_code = ::std::option::Option::Some(is.read_uint32()?);
                },
                200 => {
                    self.size_of_initialized_data = ::std::option::Option::Some(is.read_uint32()?);
                },
                208 => {
                    self.size_of_uninitialized_data = ::std::option::Option::Some(is.read_uint32()?);
                },
                216 => {
                    self.size_of_image = ::std::option::Option::Some(is.read_uint32()?);
                },
                224 => {
                    self.size_of_headers = ::std::option::Option::Some(is.read_uint32()?);
                },
                232 => {
                    self.size_of_stack_reserve = ::std::option::Option::Some(is.read_uint64()?);
                },
                240 => {
                    self.size_of_stack_commit = ::std::option::Option::Some(is.read_uint64()?);
                },
                248 => {
                    self.size_of_heap_reserve = ::std::option::Option::Some(is.read_uint64()?);
                },
                256 => {
                    self.size_of_heap_commit = ::std::option::Option::Some(is.read_uint64()?);
                },
                264 => {
                    self.pointer_to_symbol_table = ::std::option::Option::Some(is.read_uint32()?);
                },
                272 => {
                    self.win32_version_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                280 => {
                    self.number_of_symbols = ::std::option::Option::Some(is.read_uint32()?);
                },
                288 => {
                    self.number_of_rva_and_sizes = ::std::option::Option::Some(is.read_uint32()?);
                },
                296 => {
                    self.number_of_sections = ::std::option::Option::Some(is.read_uint32()?);
                },
                304 => {
                    self.number_of_imported_functions = ::std::option::Option::Some(is.read_uint64()?);
                },
                312 => {
                    self.number_of_delayed_imported_functions = ::std::option::Option::Some(is.read_uint64()?);
                },
                320 => {
                    self.number_of_resources = ::std::option::Option::Some(is.read_uint64()?);
                },
                328 => {
                    self.number_of_version_infos = ::std::option::Option::Some(is.read_uint64()?);
                },
                336 => {
                    self.number_of_imports = ::std::option::Option::Some(is.read_uint64()?);
                },
                344 => {
                    self.number_of_delayed_imports = ::std::option::Option::Some(is.read_uint64()?);
                },
                352 => {
                    self.number_of_exports = ::std::option::Option::Some(is.read_uint64()?);
                },
                360 => {
                    self.number_of_signatures = ::std::option::Option::Some(is.read_uint64()?);
                },
                370 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.version_info.insert(key, value);
                },
                378 => {
                    self.version_info_list.push(is.read_message()?);
                },
                386 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rich_signature)?;
                },
                394 => {
                    self.pdb_path = ::std::option::Option::Some(is.read_bytes()?);
                },
                402 => {
                    self.sections.push(is.read_message()?);
                },
                410 => {
                    self.data_directories.push(is.read_message()?);
                },
                416 => {
                    self.resource_timestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                426 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.resource_version)?;
                },
                434 => {
                    self.resources.push(is.read_message()?);
                },
                442 => {
                    self.import_details.push(is.read_message()?);
                },
                450 => {
                    self.delayed_import_details.push(is.read_message()?);
                },
                458 => {
                    self.export_details.push(is.read_message()?);
                },
                464 => {
                    self.is_signed = ::std::option::Option::Some(is.read_bool()?);
                },
                474 => {
                    self.signatures.push(is.read_message()?);
                },
                482 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.overlay)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.is_pe {
            my_size += 1 + 1;
        }
        if let Some(v) = self.machine {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.subsystem {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.os_version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.subsystem_version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.image_version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.linker_version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.opthdr_magic {
            my_size += ::protobuf::rt::int32_size(8, v.value());
        }
        if let Some(v) = self.characteristics {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.dll_characteristics {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.image_base {
            my_size += ::protobuf::rt::uint64_size(12, v);
        }
        if let Some(v) = self.checksum {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.base_of_code {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.base_of_data {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.entry_point {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.entry_point_raw {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.dll_name.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        if let Some(v) = self.export_timestamp {
            my_size += ::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.section_alignment {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.file_alignment {
            my_size += ::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.loader_flags {
            my_size += ::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.size_of_optional_header {
            my_size += ::protobuf::rt::uint32_size(23, v);
        }
        if let Some(v) = self.size_of_code {
            my_size += ::protobuf::rt::uint32_size(24, v);
        }
        if let Some(v) = self.size_of_initialized_data {
            my_size += ::protobuf::rt::uint32_size(25, v);
        }
        if let Some(v) = self.size_of_uninitialized_data {
            my_size += ::protobuf::rt::uint32_size(26, v);
        }
        if let Some(v) = self.size_of_image {
            my_size += ::protobuf::rt::uint32_size(27, v);
        }
        if let Some(v) = self.size_of_headers {
            my_size += ::protobuf::rt::uint32_size(28, v);
        }
        if let Some(v) = self.size_of_stack_reserve {
            my_size += ::protobuf::rt::uint64_size(29, v);
        }
        if let Some(v) = self.size_of_stack_commit {
            my_size += ::protobuf::rt::uint64_size(30, v);
        }
        if let Some(v) = self.size_of_heap_reserve {
            my_size += ::protobuf::rt::uint64_size(31, v);
        }
        if let Some(v) = self.size_of_heap_commit {
            my_size += ::protobuf::rt::uint64_size(32, v);
        }
        if let Some(v) = self.pointer_to_symbol_table {
            my_size += ::protobuf::rt::uint32_size(33, v);
        }
        if let Some(v) = self.win32_version_value {
            my_size += ::protobuf::rt::uint32_size(34, v);
        }
        if let Some(v) = self.number_of_symbols {
            my_size += ::protobuf::rt::uint32_size(35, v);
        }
        if let Some(v) = self.number_of_rva_and_sizes {
            my_size += ::protobuf::rt::uint32_size(36, v);
        }
        if let Some(v) = self.number_of_sections {
            my_size += ::protobuf::rt::uint32_size(37, v);
        }
        if let Some(v) = self.number_of_imported_functions {
            my_size += ::protobuf::rt::uint64_size(38, v);
        }
        if let Some(v) = self.number_of_delayed_imported_functions {
            my_size += ::protobuf::rt::uint64_size(39, v);
        }
        if let Some(v) = self.number_of_resources {
            my_size += ::protobuf::rt::uint64_size(40, v);
        }
        if let Some(v) = self.number_of_version_infos {
            my_size += ::protobuf::rt::uint64_size(41, v);
        }
        if let Some(v) = self.number_of_imports {
            my_size += ::protobuf::rt::uint64_size(42, v);
        }
        if let Some(v) = self.number_of_delayed_imports {
            my_size += ::protobuf::rt::uint64_size(43, v);
        }
        if let Some(v) = self.number_of_exports {
            my_size += ::protobuf::rt::uint64_size(44, v);
        }
        if let Some(v) = self.number_of_signatures {
            my_size += ::protobuf::rt::uint64_size(45, v);
        }
        for (k, v) in &self.version_info {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for value in &self.version_info_list {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.rich_signature.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.pdb_path.as_ref() {
            my_size += ::protobuf::rt::bytes_size(49, &v);
        }
        for value in &self.sections {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.data_directories {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.resource_timestamp {
            my_size += ::protobuf::rt::uint64_size(52, v);
        }
        if let Some(v) = self.resource_version.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.resources {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.import_details {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.delayed_import_details {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.export_details {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.is_signed {
            my_size += 2 + 1;
        }
        for value in &self.signatures {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.overlay.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.is_pe {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.machine {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.subsystem {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.os_version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.subsystem_version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.image_version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.linker_version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.opthdr_magic {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.characteristics {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.dll_characteristics {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.image_base {
            os.write_uint64(12, v)?;
        }
        if let Some(v) = self.checksum {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.base_of_code {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.base_of_data {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.entry_point {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.entry_point_raw {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.dll_name.as_ref() {
            os.write_string(18, v)?;
        }
        if let Some(v) = self.export_timestamp {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.section_alignment {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.file_alignment {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.loader_flags {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.size_of_optional_header {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.size_of_code {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.size_of_initialized_data {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.size_of_uninitialized_data {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.size_of_image {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.size_of_headers {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.size_of_stack_reserve {
            os.write_uint64(29, v)?;
        }
        if let Some(v) = self.size_of_stack_commit {
            os.write_uint64(30, v)?;
        }
        if let Some(v) = self.size_of_heap_reserve {
            os.write_uint64(31, v)?;
        }
        if let Some(v) = self.size_of_heap_commit {
            os.write_uint64(32, v)?;
        }
        if let Some(v) = self.pointer_to_symbol_table {
            os.write_uint32(33, v)?;
        }
        if let Some(v) = self.win32_version_value {
            os.write_uint32(34, v)?;
        }
        if let Some(v) = self.number_of_symbols {
            os.write_uint32(35, v)?;
        }
        if let Some(v) = self.number_of_rva_and_sizes {
            os.write_uint32(36, v)?;
        }
        if let Some(v) = self.number_of_sections {
            os.write_uint32(37, v)?;
        }
        if let Some(v) = self.number_of_imported_functions {
            os.write_uint64(38, v)?;
        }
        if let Some(v) = self.number_of_delayed_imported_functions {
            os.write_uint64(39, v)?;
        }
        if let Some(v) = self.number_of_resources {
            os.write_uint64(40, v)?;
        }
        if let Some(v) = self.number_of_version_infos {
            os.write_uint64(41, v)?;
        }
        if let Some(v) = self.number_of_imports {
            os.write_uint64(42, v)?;
        }
        if let Some(v) = self.number_of_delayed_imports {
            os.write_uint64(43, v)?;
        }
        if let Some(v) = self.number_of_exports {
            os.write_uint64(44, v)?;
        }
        if let Some(v) = self.number_of_signatures {
            os.write_uint64(45, v)?;
        }
        for (k, v) in &self.version_info {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(370)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        for v in &self.version_info_list {
            ::protobuf::rt::write_message_field_with_cached_size(47, v, os)?;
        };
        if let Some(v) = self.rich_signature.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(48, v, os)?;
        }
        if let Some(v) = self.pdb_path.as_ref() {
            os.write_bytes(49, v)?;
        }
        for v in &self.sections {
            ::protobuf::rt::write_message_field_with_cached_size(50, v, os)?;
        };
        for v in &self.data_directories {
            ::protobuf::rt::write_message_field_with_cached_size(51, v, os)?;
        };
        if let Some(v) = self.resource_timestamp {
            os.write_uint64(52, v)?;
        }
        if let Some(v) = self.resource_version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(53, v, os)?;
        }
        for v in &self.resources {
            ::protobuf::rt::write_message_field_with_cached_size(54, v, os)?;
        };
        for v in &self.import_details {
            ::protobuf::rt::write_message_field_with_cached_size(55, v, os)?;
        };
        for v in &self.delayed_import_details {
            ::protobuf::rt::write_message_field_with_cached_size(56, v, os)?;
        };
        for v in &self.export_details {
            ::protobuf::rt::write_message_field_with_cached_size(57, v, os)?;
        };
        if let Some(v) = self.is_signed {
            os.write_bool(58, v)?;
        }
        for v in &self.signatures {
            ::protobuf::rt::write_message_field_with_cached_size(59, v, os)?;
        };
        if let Some(v) = self.overlay.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(60, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PE {
        PE::new()
    }

    fn clear(&mut self) {
        self.is_pe = ::std::option::Option::None;
        self.machine = ::std::option::Option::None;
        self.subsystem = ::std::option::Option::None;
        self.os_version.clear();
        self.subsystem_version.clear();
        self.image_version.clear();
        self.linker_version.clear();
        self.opthdr_magic = ::std::option::Option::None;
        self.characteristics = ::std::option::Option::None;
        self.dll_characteristics = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.image_base = ::std::option::Option::None;
        self.checksum = ::std::option::Option::None;
        self.base_of_code = ::std::option::Option::None;
        self.base_of_data = ::std::option::Option::None;
        self.entry_point = ::std::option::Option::None;
        self.entry_point_raw = ::std::option::Option::None;
        self.dll_name = ::std::option::Option::None;
        self.export_timestamp = ::std::option::Option::None;
        self.section_alignment = ::std::option::Option::None;
        self.file_alignment = ::std::option::Option::None;
        self.loader_flags = ::std::option::Option::None;
        self.size_of_optional_header = ::std::option::Option::None;
        self.size_of_code = ::std::option::Option::None;
        self.size_of_initialized_data = ::std::option::Option::None;
        self.size_of_uninitialized_data = ::std::option::Option::None;
        self.size_of_image = ::std::option::Option::None;
        self.size_of_headers = ::std::option::Option::None;
        self.size_of_stack_reserve = ::std::option::Option::None;
        self.size_of_stack_commit = ::std::option::Option::None;
        self.size_of_heap_reserve = ::std::option::Option::None;
        self.size_of_heap_commit = ::std::option::Option::None;
        self.pointer_to_symbol_table = ::std::option::Option::None;
        self.win32_version_value = ::std::option::Option::None;
        self.number_of_symbols = ::std::option::Option::None;
        self.number_of_rva_and_sizes = ::std::option::Option::None;
        self.number_of_sections = ::std::option::Option::None;
        self.number_of_imported_functions = ::std::option::Option::None;
        self.number_of_delayed_imported_functions = ::std::option::Option::None;
        self.number_of_resources = ::std::option::Option::None;
        self.number_of_version_infos = ::std::option::Option::None;
        self.number_of_imports = ::std::option::Option::None;
        self.number_of_delayed_imports = ::std::option::Option::None;
        self.number_of_exports = ::std::option::Option::None;
        self.number_of_signatures = ::std::option::Option::None;
        self.version_info.clear();
        self.version_info_list.clear();
        self.rich_signature.clear();
        self.pdb_path = ::std::option::Option::None;
        self.sections.clear();
        self.data_directories.clear();
        self.resource_timestamp = ::std::option::Option::None;
        self.resource_version.clear();
        self.resources.clear();
        self.import_details.clear();
        self.delayed_import_details.clear();
        self.export_details.clear();
        self.is_signed = ::std::option::Option::None;
        self.signatures.clear();
        self.overlay.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PE {
        static instance: ::protobuf::rt::Lazy<PE> = ::protobuf::rt::Lazy::new();
        instance.get(PE::new)
    }
}

impl ::protobuf::MessageFull for PE {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PE").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PE {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PE {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pe.Version)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Version {
    // message fields
    // @@protoc_insertion_point(field:pe.Version.major)
    pub major: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.Version.minor)
    pub minor: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:pe.Version.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Version {
    fn default() -> &'a Version {
        <Version as ::protobuf::Message>::default_instance()
    }
}

impl Version {
    pub fn new() -> Version {
        ::std::default::Default::default()
    }

    // required uint32 major = 1;

    pub fn major(&self) -> u32 {
        self.major.unwrap_or(0)
    }

    pub fn clear_major(&mut self) {
        self.major = ::std::option::Option::None;
    }

    pub fn has_major(&self) -> bool {
        self.major.is_some()
    }

    // Param is passed by value, moved
    pub fn set_major(&mut self, v: u32) {
        self.major = ::std::option::Option::Some(v);
    }

    // required uint32 minor = 2;

    pub fn minor(&self) -> u32 {
        self.minor.unwrap_or(0)
    }

    pub fn clear_minor(&mut self) {
        self.minor = ::std::option::Option::None;
    }

    pub fn has_minor(&self) -> bool {
        self.minor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minor(&mut self, v: u32) {
        self.minor = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "major",
            |m: &Version| { &m.major },
            |m: &mut Version| { &mut m.major },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minor",
            |m: &Version| { &m.minor },
            |m: &mut Version| { &mut m.minor },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Version>(
            "Version",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Version {
    const NAME: &'static str = "Version";

    fn is_initialized(&self) -> bool {
        if self.major.is_none() {
            return false;
        }
        if self.minor.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.major = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.minor = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.major {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.minor {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.major {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.minor {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Version {
        Version::new()
    }

    fn clear(&mut self) {
        self.major = ::std::option::Option::None;
        self.minor = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Version {
        static instance: Version = Version {
            major: ::std::option::Option::None,
            minor: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Version {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Version").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Version {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Version {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pe.KeyValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct KeyValue {
    // message fields
    // @@protoc_insertion_point(field:pe.KeyValue.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:pe.KeyValue.value)
    pub value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:pe.KeyValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KeyValue {
    fn default() -> &'a KeyValue {
        <KeyValue as ::protobuf::Message>::default_instance()
    }
}

impl KeyValue {
    pub fn new() -> KeyValue {
        ::std::default::Default::default()
    }

    // required string key = 1;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string value = 2;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &KeyValue| { &m.key },
            |m: &mut KeyValue| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &KeyValue| { &m.value },
            |m: &mut KeyValue| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KeyValue>(
            "KeyValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KeyValue {
    const NAME: &'static str = "KeyValue";

    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        }
        if self.value.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KeyValue {
        KeyValue::new()
    }

    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KeyValue {
        static instance: KeyValue = KeyValue {
            key: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KeyValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KeyValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KeyValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pe.DirEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DirEntry {
    // message fields
    // @@protoc_insertion_point(field:pe.DirEntry.virtual_address)
    pub virtual_address: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.DirEntry.size)
    pub size: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:pe.DirEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DirEntry {
    fn default() -> &'a DirEntry {
        <DirEntry as ::protobuf::Message>::default_instance()
    }
}

impl DirEntry {
    pub fn new() -> DirEntry {
        ::std::default::Default::default()
    }

    // required uint32 virtual_address = 1;

    pub fn virtual_address(&self) -> u32 {
        self.virtual_address.unwrap_or(0)
    }

    pub fn clear_virtual_address(&mut self) {
        self.virtual_address = ::std::option::Option::None;
    }

    pub fn has_virtual_address(&self) -> bool {
        self.virtual_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_virtual_address(&mut self, v: u32) {
        self.virtual_address = ::std::option::Option::Some(v);
    }

    // required uint32 size = 2;

    pub fn size(&self) -> u32 {
        self.size.unwrap_or(0)
    }

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u32) {
        self.size = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "virtual_address",
            |m: &DirEntry| { &m.virtual_address },
            |m: &mut DirEntry| { &mut m.virtual_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "size",
            |m: &DirEntry| { &m.size },
            |m: &mut DirEntry| { &mut m.size },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DirEntry>(
            "DirEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DirEntry {
    const NAME: &'static str = "DirEntry";

    fn is_initialized(&self) -> bool {
        if self.virtual_address.is_none() {
            return false;
        }
        if self.size.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.virtual_address = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.size = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.virtual_address {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.virtual_address {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.size {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DirEntry {
        DirEntry::new()
    }

    fn clear(&mut self) {
        self.virtual_address = ::std::option::Option::None;
        self.size = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DirEntry {
        static instance: DirEntry = DirEntry {
            virtual_address: ::std::option::Option::None,
            size: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DirEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DirEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DirEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DirEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pe.Resource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Resource {
    // message fields
    // @@protoc_insertion_point(field:pe.Resource.length)
    pub length: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.Resource.rva)
    pub rva: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.Resource.offset)
    pub offset: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.Resource.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<ResourceType>>,
    // @@protoc_insertion_point(field:pe.Resource.id)
    pub id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.Resource.language)
    pub language: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.Resource.type_string)
    pub type_string: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:pe.Resource.name_string)
    pub name_string: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:pe.Resource.language_string)
    pub language_string: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:pe.Resource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Resource {
    fn default() -> &'a Resource {
        <Resource as ::protobuf::Message>::default_instance()
    }
}

impl Resource {
    pub fn new() -> Resource {
        ::std::default::Default::default()
    }

    // required uint32 length = 1;

    pub fn length(&self) -> u32 {
        self.length.unwrap_or(0)
    }

    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: u32) {
        self.length = ::std::option::Option::Some(v);
    }

    // required uint32 rva = 2;

    pub fn rva(&self) -> u32 {
        self.rva.unwrap_or(0)
    }

    pub fn clear_rva(&mut self) {
        self.rva = ::std::option::Option::None;
    }

    pub fn has_rva(&self) -> bool {
        self.rva.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rva(&mut self, v: u32) {
        self.rva = ::std::option::Option::Some(v);
    }

    // optional uint32 offset = 3;

    pub fn offset(&self) -> u32 {
        self.offset.unwrap_or(0)
    }

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u32) {
        self.offset = ::std::option::Option::Some(v);
    }

    // optional .pe.ResourceType type = 4;

    pub fn type_(&self) -> ResourceType {
        match self.type_ {
            Some(e) => e.enum_value_or(ResourceType::RESOURCE_TYPE_CURSOR),
            None => ResourceType::RESOURCE_TYPE_CURSOR,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ResourceType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 id = 5;

    pub fn id(&self) -> u32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional uint32 language = 6;

    pub fn language(&self) -> u32 {
        self.language.unwrap_or(0)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: u32) {
        self.language = ::std::option::Option::Some(v);
    }

    // optional bytes type_string = 7;

    pub fn type_string(&self) -> &[u8] {
        match self.type_string.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_type_string(&mut self) {
        self.type_string = ::std::option::Option::None;
    }

    pub fn has_type_string(&self) -> bool {
        self.type_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type_string(&mut self, v: ::std::vec::Vec<u8>) {
        self.type_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type_string(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.type_string.is_none() {
            self.type_string = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.type_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_string(&mut self) -> ::std::vec::Vec<u8> {
        self.type_string.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes name_string = 8;

    pub fn name_string(&self) -> &[u8] {
        match self.name_string.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_name_string(&mut self) {
        self.name_string = ::std::option::Option::None;
    }

    pub fn has_name_string(&self) -> bool {
        self.name_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name_string(&mut self, v: ::std::vec::Vec<u8>) {
        self.name_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name_string(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.name_string.is_none() {
            self.name_string = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.name_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_name_string(&mut self) -> ::std::vec::Vec<u8> {
        self.name_string.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes language_string = 9;

    pub fn language_string(&self) -> &[u8] {
        match self.language_string.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_language_string(&mut self) {
        self.language_string = ::std::option::Option::None;
    }

    pub fn has_language_string(&self) -> bool {
        self.language_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language_string(&mut self, v: ::std::vec::Vec<u8>) {
        self.language_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language_string(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.language_string.is_none() {
            self.language_string = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.language_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_language_string(&mut self) -> ::std::vec::Vec<u8> {
        self.language_string.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "length",
            |m: &Resource| { &m.length },
            |m: &mut Resource| { &mut m.length },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rva",
            |m: &Resource| { &m.rva },
            |m: &mut Resource| { &mut m.rva },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "offset",
            |m: &Resource| { &m.offset },
            |m: &mut Resource| { &mut m.offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &Resource| { &m.type_ },
            |m: &mut Resource| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &Resource| { &m.id },
            |m: &mut Resource| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "language",
            |m: &Resource| { &m.language },
            |m: &mut Resource| { &mut m.language },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type_string",
            |m: &Resource| { &m.type_string },
            |m: &mut Resource| { &mut m.type_string },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name_string",
            |m: &Resource| { &m.name_string },
            |m: &mut Resource| { &mut m.name_string },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "language_string",
            |m: &Resource| { &m.language_string },
            |m: &mut Resource| { &mut m.language_string },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Resource>(
            "Resource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Resource {
    const NAME: &'static str = "Resource";

    fn is_initialized(&self) -> bool {
        if self.length.is_none() {
            return false;
        }
        if self.rva.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.length = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.rva = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.offset = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.id = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.language = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.type_string = ::std::option::Option::Some(is.read_bytes()?);
                },
                66 => {
                    self.name_string = ::std::option::Option::Some(is.read_bytes()?);
                },
                74 => {
                    self.language_string = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.rva {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.type_string.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.name_string.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.language_string.as_ref() {
            my_size += ::protobuf::rt::bytes_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.length {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.rva {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.language {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.type_string.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.name_string.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.language_string.as_ref() {
            os.write_bytes(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Resource {
        Resource::new()
    }

    fn clear(&mut self) {
        self.length = ::std::option::Option::None;
        self.rva = ::std::option::Option::None;
        self.offset = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.id = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.type_string = ::std::option::Option::None;
        self.name_string = ::std::option::Option::None;
        self.language_string = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Resource {
        static instance: Resource = Resource {
            length: ::std::option::Option::None,
            rva: ::std::option::Option::None,
            offset: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            id: ::std::option::Option::None,
            language: ::std::option::Option::None,
            type_string: ::std::option::Option::None,
            name_string: ::std::option::Option::None,
            language_string: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Resource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Resource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Resource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Resource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pe.Import)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Import {
    // message fields
    // @@protoc_insertion_point(field:pe.Import.library_name)
    pub library_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:pe.Import.number_of_functions)
    pub number_of_functions: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:pe.Import.functions)
    pub functions: ::std::vec::Vec<Function>,
    // special fields
    // @@protoc_insertion_point(special_field:pe.Import.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Import {
    fn default() -> &'a Import {
        <Import as ::protobuf::Message>::default_instance()
    }
}

impl Import {
    pub fn new() -> Import {
        ::std::default::Default::default()
    }

    // required string library_name = 1;

    pub fn library_name(&self) -> &str {
        match self.library_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_library_name(&mut self) {
        self.library_name = ::std::option::Option::None;
    }

    pub fn has_library_name(&self) -> bool {
        self.library_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_library_name(&mut self, v: ::std::string::String) {
        self.library_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_library_name(&mut self) -> &mut ::std::string::String {
        if self.library_name.is_none() {
            self.library_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.library_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_library_name(&mut self) -> ::std::string::String {
        self.library_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint64 number_of_functions = 2;

    pub fn number_of_functions(&self) -> u64 {
        self.number_of_functions.unwrap_or(0)
    }

    pub fn clear_number_of_functions(&mut self) {
        self.number_of_functions = ::std::option::Option::None;
    }

    pub fn has_number_of_functions(&self) -> bool {
        self.number_of_functions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number_of_functions(&mut self, v: u64) {
        self.number_of_functions = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "library_name",
            |m: &Import| { &m.library_name },
            |m: &mut Import| { &mut m.library_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "number_of_functions",
            |m: &Import| { &m.number_of_functions },
            |m: &mut Import| { &mut m.number_of_functions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "functions",
            |m: &Import| { &m.functions },
            |m: &mut Import| { &mut m.functions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Import>(
            "Import",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Import {
    const NAME: &'static str = "Import";

    fn is_initialized(&self) -> bool {
        if self.library_name.is_none() {
            return false;
        }
        if self.number_of_functions.is_none() {
            return false;
        }
        for v in &self.functions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.library_name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.number_of_functions = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.functions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.library_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.number_of_functions {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        for value in &self.functions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.library_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.number_of_functions {
            os.write_uint64(2, v)?;
        }
        for v in &self.functions {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Import {
        Import::new()
    }

    fn clear(&mut self) {
        self.library_name = ::std::option::Option::None;
        self.number_of_functions = ::std::option::Option::None;
        self.functions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Import {
        static instance: Import = Import {
            library_name: ::std::option::Option::None,
            number_of_functions: ::std::option::Option::None,
            functions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Import {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Import").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Import {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Import {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pe.Export)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Export {
    // message fields
    // @@protoc_insertion_point(field:pe.Export.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:pe.Export.ordinal)
    pub ordinal: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.Export.rva)
    pub rva: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.Export.offset)
    pub offset: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.Export.forward_name)
    pub forward_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:pe.Export.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Export {
    fn default() -> &'a Export {
        <Export as ::protobuf::Message>::default_instance()
    }
}

impl Export {
    pub fn new() -> Export {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint32 ordinal = 2;

    pub fn ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }

    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }

    // required uint32 rva = 3;

    pub fn rva(&self) -> u32 {
        self.rva.unwrap_or(0)
    }

    pub fn clear_rva(&mut self) {
        self.rva = ::std::option::Option::None;
    }

    pub fn has_rva(&self) -> bool {
        self.rva.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rva(&mut self, v: u32) {
        self.rva = ::std::option::Option::Some(v);
    }

    // optional uint32 offset = 4;

    pub fn offset(&self) -> u32 {
        self.offset.unwrap_or(0)
    }

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u32) {
        self.offset = ::std::option::Option::Some(v);
    }

    // optional string forward_name = 5;

    pub fn forward_name(&self) -> &str {
        match self.forward_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_forward_name(&mut self) {
        self.forward_name = ::std::option::Option::None;
    }

    pub fn has_forward_name(&self) -> bool {
        self.forward_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forward_name(&mut self, v: ::std::string::String) {
        self.forward_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_forward_name(&mut self) -> &mut ::std::string::String {
        if self.forward_name.is_none() {
            self.forward_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.forward_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_forward_name(&mut self) -> ::std::string::String {
        self.forward_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &Export| { &m.name },
            |m: &mut Export| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ordinal",
            |m: &Export| { &m.ordinal },
            |m: &mut Export| { &mut m.ordinal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rva",
            |m: &Export| { &m.rva },
            |m: &mut Export| { &mut m.rva },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "offset",
            |m: &Export| { &m.offset },
            |m: &mut Export| { &mut m.offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "forward_name",
            |m: &Export| { &m.forward_name },
            |m: &mut Export| { &mut m.forward_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Export>(
            "Export",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Export {
    const NAME: &'static str = "Export";

    fn is_initialized(&self) -> bool {
        if self.ordinal.is_none() {
            return false;
        }
        if self.rva.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.ordinal = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.rva = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.offset = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.forward_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.ordinal {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.rva {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.forward_name.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.rva {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.forward_name.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Export {
        Export::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.ordinal = ::std::option::Option::None;
        self.rva = ::std::option::Option::None;
        self.offset = ::std::option::Option::None;
        self.forward_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Export {
        static instance: Export = Export {
            name: ::std::option::Option::None,
            ordinal: ::std::option::Option::None,
            rva: ::std::option::Option::None,
            offset: ::std::option::Option::None,
            forward_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Export {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Export").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Export {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Export {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pe.Function)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Function {
    // message fields
    // @@protoc_insertion_point(field:pe.Function.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:pe.Function.ordinal)
    pub ordinal: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.Function.rva)
    pub rva: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:pe.Function.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Function {
    fn default() -> &'a Function {
        <Function as ::protobuf::Message>::default_instance()
    }
}

impl Function {
    pub fn new() -> Function {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 ordinal = 2;

    pub fn ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }

    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }

    // required uint32 rva = 3;

    pub fn rva(&self) -> u32 {
        self.rva.unwrap_or(0)
    }

    pub fn clear_rva(&mut self) {
        self.rva = ::std::option::Option::None;
    }

    pub fn has_rva(&self) -> bool {
        self.rva.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rva(&mut self, v: u32) {
        self.rva = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &Function| { &m.name },
            |m: &mut Function| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ordinal",
            |m: &Function| { &m.ordinal },
            |m: &mut Function| { &mut m.ordinal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rva",
            |m: &Function| { &m.rva },
            |m: &mut Function| { &mut m.rva },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Function>(
            "Function",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Function {
    const NAME: &'static str = "Function";

    fn is_initialized(&self) -> bool {
        if self.rva.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.ordinal = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.rva = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.ordinal {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.rva {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.rva {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Function {
        Function::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.ordinal = ::std::option::Option::None;
        self.rva = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Function {
        static instance: Function = Function {
            name: ::std::option::Option::None,
            ordinal: ::std::option::Option::None,
            rva: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Function {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Function").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Function {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Function {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pe.Signature)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Signature {
    // message fields
    // @@protoc_insertion_point(field:pe.Signature.subject)
    pub subject: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:pe.Signature.issuer)
    pub issuer: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:pe.Signature.thumbprint)
    pub thumbprint: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:pe.Signature.version)
    pub version: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:pe.Signature.algorithm)
    pub algorithm: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:pe.Signature.algorithm_oid)
    pub algorithm_oid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:pe.Signature.serial)
    pub serial: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:pe.Signature.not_before)
    pub not_before: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:pe.Signature.not_after)
    pub not_after: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:pe.Signature.verified)
    pub verified: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:pe.Signature.digest_alg)
    pub digest_alg: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:pe.Signature.digest)
    pub digest: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:pe.Signature.file_digest)
    pub file_digest: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:pe.Signature.number_of_certificates)
    pub number_of_certificates: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:pe.Signature.number_of_countersignatures)
    pub number_of_countersignatures: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:pe.Signature.signer_info)
    pub signer_info: ::protobuf::MessageField<SignerInfo>,
    // @@protoc_insertion_point(field:pe.Signature.certificates)
    pub certificates: ::std::vec::Vec<Certificate>,
    // @@protoc_insertion_point(field:pe.Signature.countersignatures)
    pub countersignatures: ::std::vec::Vec<CounterSignature>,
    // special fields
    // @@protoc_insertion_point(special_field:pe.Signature.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Signature {
    fn default() -> &'a Signature {
        <Signature as ::protobuf::Message>::default_instance()
    }
}

impl Signature {
    pub fn new() -> Signature {
        ::std::default::Default::default()
    }

    // optional string subject = 1;

    pub fn subject(&self) -> &str {
        match self.subject.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_subject(&mut self) {
        self.subject = ::std::option::Option::None;
    }

    pub fn has_subject(&self) -> bool {
        self.subject.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subject(&mut self, v: ::std::string::String) {
        self.subject = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subject(&mut self) -> &mut ::std::string::String {
        if self.subject.is_none() {
            self.subject = ::std::option::Option::Some(::std::string::String::new());
        }
        self.subject.as_mut().unwrap()
    }

    // Take field
    pub fn take_subject(&mut self) -> ::std::string::String {
        self.subject.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string issuer = 2;

    pub fn issuer(&self) -> &str {
        match self.issuer.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_issuer(&mut self) {
        self.issuer = ::std::option::Option::None;
    }

    pub fn has_issuer(&self) -> bool {
        self.issuer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_issuer(&mut self, v: ::std::string::String) {
        self.issuer = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_issuer(&mut self) -> &mut ::std::string::String {
        if self.issuer.is_none() {
            self.issuer = ::std::option::Option::Some(::std::string::String::new());
        }
        self.issuer.as_mut().unwrap()
    }

    // Take field
    pub fn take_issuer(&mut self) -> ::std::string::String {
        self.issuer.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string thumbprint = 3;

    pub fn thumbprint(&self) -> &str {
        match self.thumbprint.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_thumbprint(&mut self) {
        self.thumbprint = ::std::option::Option::None;
    }

    pub fn has_thumbprint(&self) -> bool {
        self.thumbprint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbprint(&mut self, v: ::std::string::String) {
        self.thumbprint = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbprint(&mut self) -> &mut ::std::string::String {
        if self.thumbprint.is_none() {
            self.thumbprint = ::std::option::Option::Some(::std::string::String::new());
        }
        self.thumbprint.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbprint(&mut self) -> ::std::string::String {
        self.thumbprint.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 version = 4;

    pub fn version(&self) -> i64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i64) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional string algorithm = 5;

    pub fn algorithm(&self) -> &str {
        match self.algorithm.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_algorithm(&mut self) {
        self.algorithm = ::std::option::Option::None;
    }

    pub fn has_algorithm(&self) -> bool {
        self.algorithm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_algorithm(&mut self, v: ::std::string::String) {
        self.algorithm = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_algorithm(&mut self) -> &mut ::std::string::String {
        if self.algorithm.is_none() {
            self.algorithm = ::std::option::Option::Some(::std::string::String::new());
        }
        self.algorithm.as_mut().unwrap()
    }

    // Take field
    pub fn take_algorithm(&mut self) -> ::std::string::String {
        self.algorithm.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string algorithm_oid = 6;

    pub fn algorithm_oid(&self) -> &str {
        match self.algorithm_oid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_algorithm_oid(&mut self) {
        self.algorithm_oid = ::std::option::Option::None;
    }

    pub fn has_algorithm_oid(&self) -> bool {
        self.algorithm_oid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_algorithm_oid(&mut self, v: ::std::string::String) {
        self.algorithm_oid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_algorithm_oid(&mut self) -> &mut ::std::string::String {
        if self.algorithm_oid.is_none() {
            self.algorithm_oid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.algorithm_oid.as_mut().unwrap()
    }

    // Take field
    pub fn take_algorithm_oid(&mut self) -> ::std::string::String {
        self.algorithm_oid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string serial = 7;

    pub fn serial(&self) -> &str {
        match self.serial.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_serial(&mut self) {
        self.serial = ::std::option::Option::None;
    }

    pub fn has_serial(&self) -> bool {
        self.serial.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serial(&mut self, v: ::std::string::String) {
        self.serial = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serial(&mut self) -> &mut ::std::string::String {
        if self.serial.is_none() {
            self.serial = ::std::option::Option::Some(::std::string::String::new());
        }
        self.serial.as_mut().unwrap()
    }

    // Take field
    pub fn take_serial(&mut self) -> ::std::string::String {
        self.serial.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 not_before = 8;

    pub fn not_before(&self) -> i64 {
        self.not_before.unwrap_or(0)
    }

    pub fn clear_not_before(&mut self) {
        self.not_before = ::std::option::Option::None;
    }

    pub fn has_not_before(&self) -> bool {
        self.not_before.is_some()
    }

    // Param is passed by value, moved
    pub fn set_not_before(&mut self, v: i64) {
        self.not_before = ::std::option::Option::Some(v);
    }

    // optional int64 not_after = 9;

    pub fn not_after(&self) -> i64 {
        self.not_after.unwrap_or(0)
    }

    pub fn clear_not_after(&mut self) {
        self.not_after = ::std::option::Option::None;
    }

    pub fn has_not_after(&self) -> bool {
        self.not_after.is_some()
    }

    // Param is passed by value, moved
    pub fn set_not_after(&mut self, v: i64) {
        self.not_after = ::std::option::Option::Some(v);
    }

    // optional bool verified = 10;

    pub fn verified(&self) -> bool {
        self.verified.unwrap_or(false)
    }

    pub fn clear_verified(&mut self) {
        self.verified = ::std::option::Option::None;
    }

    pub fn has_verified(&self) -> bool {
        self.verified.is_some()
    }

    // Param is passed by value, moved
    pub fn set_verified(&mut self, v: bool) {
        self.verified = ::std::option::Option::Some(v);
    }

    // optional string digest_alg = 11;

    pub fn digest_alg(&self) -> &str {
        match self.digest_alg.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_digest_alg(&mut self) {
        self.digest_alg = ::std::option::Option::None;
    }

    pub fn has_digest_alg(&self) -> bool {
        self.digest_alg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_digest_alg(&mut self, v: ::std::string::String) {
        self.digest_alg = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_digest_alg(&mut self) -> &mut ::std::string::String {
        if self.digest_alg.is_none() {
            self.digest_alg = ::std::option::Option::Some(::std::string::String::new());
        }
        self.digest_alg.as_mut().unwrap()
    }

    // Take field
    pub fn take_digest_alg(&mut self) -> ::std::string::String {
        self.digest_alg.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string digest = 12;

    pub fn digest(&self) -> &str {
        match self.digest.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_digest(&mut self) {
        self.digest = ::std::option::Option::None;
    }

    pub fn has_digest(&self) -> bool {
        self.digest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_digest(&mut self, v: ::std::string::String) {
        self.digest = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_digest(&mut self) -> &mut ::std::string::String {
        if self.digest.is_none() {
            self.digest = ::std::option::Option::Some(::std::string::String::new());
        }
        self.digest.as_mut().unwrap()
    }

    // Take field
    pub fn take_digest(&mut self) -> ::std::string::String {
        self.digest.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string file_digest = 13;

    pub fn file_digest(&self) -> &str {
        match self.file_digest.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_digest(&mut self) {
        self.file_digest = ::std::option::Option::None;
    }

    pub fn has_file_digest(&self) -> bool {
        self.file_digest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_digest(&mut self, v: ::std::string::String) {
        self.file_digest = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_digest(&mut self) -> &mut ::std::string::String {
        if self.file_digest.is_none() {
            self.file_digest = ::std::option::Option::Some(::std::string::String::new());
        }
        self.file_digest.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_digest(&mut self) -> ::std::string::String {
        self.file_digest.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 number_of_certificates = 14;

    pub fn number_of_certificates(&self) -> u64 {
        self.number_of_certificates.unwrap_or(0)
    }

    pub fn clear_number_of_certificates(&mut self) {
        self.number_of_certificates = ::std::option::Option::None;
    }

    pub fn has_number_of_certificates(&self) -> bool {
        self.number_of_certificates.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number_of_certificates(&mut self, v: u64) {
        self.number_of_certificates = ::std::option::Option::Some(v);
    }

    // optional uint64 number_of_countersignatures = 15;

    pub fn number_of_countersignatures(&self) -> u64 {
        self.number_of_countersignatures.unwrap_or(0)
    }

    pub fn clear_number_of_countersignatures(&mut self) {
        self.number_of_countersignatures = ::std::option::Option::None;
    }

    pub fn has_number_of_countersignatures(&self) -> bool {
        self.number_of_countersignatures.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number_of_countersignatures(&mut self, v: u64) {
        self.number_of_countersignatures = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(18);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subject",
            |m: &Signature| { &m.subject },
            |m: &mut Signature| { &mut m.subject },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "issuer",
            |m: &Signature| { &m.issuer },
            |m: &mut Signature| { &mut m.issuer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbprint",
            |m: &Signature| { &m.thumbprint },
            |m: &mut Signature| { &mut m.thumbprint },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &Signature| { &m.version },
            |m: &mut Signature| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "algorithm",
            |m: &Signature| { &m.algorithm },
            |m: &mut Signature| { &mut m.algorithm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "algorithm_oid",
            |m: &Signature| { &m.algorithm_oid },
            |m: &mut Signature| { &mut m.algorithm_oid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serial",
            |m: &Signature| { &m.serial },
            |m: &mut Signature| { &mut m.serial },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "not_before",
            |m: &Signature| { &m.not_before },
            |m: &mut Signature| { &mut m.not_before },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "not_after",
            |m: &Signature| { &m.not_after },
            |m: &mut Signature| { &mut m.not_after },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "verified",
            |m: &Signature| { &m.verified },
            |m: &mut Signature| { &mut m.verified },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "digest_alg",
            |m: &Signature| { &m.digest_alg },
            |m: &mut Signature| { &mut m.digest_alg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "digest",
            |m: &Signature| { &m.digest },
            |m: &mut Signature| { &mut m.digest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_digest",
            |m: &Signature| { &m.file_digest },
            |m: &mut Signature| { &mut m.file_digest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "number_of_certificates",
            |m: &Signature| { &m.number_of_certificates },
            |m: &mut Signature| { &mut m.number_of_certificates },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "number_of_countersignatures",
            |m: &Signature| { &m.number_of_countersignatures },
            |m: &mut Signature| { &mut m.number_of_countersignatures },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SignerInfo>(
            "signer_info",
            |m: &Signature| { &m.signer_info },
            |m: &mut Signature| { &mut m.signer_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "certificates",
            |m: &Signature| { &m.certificates },
            |m: &mut Signature| { &mut m.certificates },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "countersignatures",
            |m: &Signature| { &m.countersignatures },
            |m: &mut Signature| { &mut m.countersignatures },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Signature>(
            "Signature",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Signature {
    const NAME: &'static str = "Signature";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.subject = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.issuer = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.thumbprint = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.version = ::std::option::Option::Some(is.read_int64()?);
                },
                42 => {
                    self.algorithm = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.algorithm_oid = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.serial = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.not_before = ::std::option::Option::Some(is.read_int64()?);
                },
                72 => {
                    self.not_after = ::std::option::Option::Some(is.read_int64()?);
                },
                80 => {
                    self.verified = ::std::option::Option::Some(is.read_bool()?);
                },
                90 => {
                    self.digest_alg = ::std::option::Option::Some(is.read_string()?);
                },
                98 => {
                    self.digest = ::std::option::Option::Some(is.read_string()?);
                },
                106 => {
                    self.file_digest = ::std::option::Option::Some(is.read_string()?);
                },
                112 => {
                    self.number_of_certificates = ::std::option::Option::Some(is.read_uint64()?);
                },
                120 => {
                    self.number_of_countersignatures = ::std::option::Option::Some(is.read_uint64()?);
                },
                130 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.signer_info)?;
                },
                138 => {
                    self.certificates.push(is.read_message()?);
                },
                146 => {
                    self.countersignatures.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.subject.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.issuer.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.thumbprint.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        if let Some(v) = self.algorithm.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.algorithm_oid.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.serial.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.not_before {
            my_size += ::protobuf::rt::int64_size(8, v);
        }
        if let Some(v) = self.not_after {
            my_size += ::protobuf::rt::int64_size(9, v);
        }
        if let Some(v) = self.verified {
            my_size += 1 + 1;
        }
        if let Some(v) = self.digest_alg.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.digest.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.file_digest.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.number_of_certificates {
            my_size += ::protobuf::rt::uint64_size(14, v);
        }
        if let Some(v) = self.number_of_countersignatures {
            my_size += ::protobuf::rt::uint64_size(15, v);
        }
        if let Some(v) = self.signer_info.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.certificates {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.countersignatures {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.subject.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.issuer.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.thumbprint.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.version {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.algorithm.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.algorithm_oid.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.serial.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.not_before {
            os.write_int64(8, v)?;
        }
        if let Some(v) = self.not_after {
            os.write_int64(9, v)?;
        }
        if let Some(v) = self.verified {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.digest_alg.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.digest.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.file_digest.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.number_of_certificates {
            os.write_uint64(14, v)?;
        }
        if let Some(v) = self.number_of_countersignatures {
            os.write_uint64(15, v)?;
        }
        if let Some(v) = self.signer_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        for v in &self.certificates {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        };
        for v in &self.countersignatures {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Signature {
        Signature::new()
    }

    fn clear(&mut self) {
        self.subject = ::std::option::Option::None;
        self.issuer = ::std::option::Option::None;
        self.thumbprint = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.algorithm = ::std::option::Option::None;
        self.algorithm_oid = ::std::option::Option::None;
        self.serial = ::std::option::Option::None;
        self.not_before = ::std::option::Option::None;
        self.not_after = ::std::option::Option::None;
        self.verified = ::std::option::Option::None;
        self.digest_alg = ::std::option::Option::None;
        self.digest = ::std::option::Option::None;
        self.file_digest = ::std::option::Option::None;
        self.number_of_certificates = ::std::option::Option::None;
        self.number_of_countersignatures = ::std::option::Option::None;
        self.signer_info.clear();
        self.certificates.clear();
        self.countersignatures.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Signature {
        static instance: Signature = Signature {
            subject: ::std::option::Option::None,
            issuer: ::std::option::Option::None,
            thumbprint: ::std::option::Option::None,
            version: ::std::option::Option::None,
            algorithm: ::std::option::Option::None,
            algorithm_oid: ::std::option::Option::None,
            serial: ::std::option::Option::None,
            not_before: ::std::option::Option::None,
            not_after: ::std::option::Option::None,
            verified: ::std::option::Option::None,
            digest_alg: ::std::option::Option::None,
            digest: ::std::option::Option::None,
            file_digest: ::std::option::Option::None,
            number_of_certificates: ::std::option::Option::None,
            number_of_countersignatures: ::std::option::Option::None,
            signer_info: ::protobuf::MessageField::none(),
            certificates: ::std::vec::Vec::new(),
            countersignatures: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Signature {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Signature").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Signature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Signature {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pe.SignerInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SignerInfo {
    // message fields
    // @@protoc_insertion_point(field:pe.SignerInfo.program_name)
    pub program_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:pe.SignerInfo.more_info)
    pub more_info: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:pe.SignerInfo.digest)
    pub digest: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:pe.SignerInfo.digest_alg)
    pub digest_alg: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:pe.SignerInfo.chain)
    pub chain: ::std::vec::Vec<Certificate>,
    // special fields
    // @@protoc_insertion_point(special_field:pe.SignerInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SignerInfo {
    fn default() -> &'a SignerInfo {
        <SignerInfo as ::protobuf::Message>::default_instance()
    }
}

impl SignerInfo {
    pub fn new() -> SignerInfo {
        ::std::default::Default::default()
    }

    // optional string program_name = 1;

    pub fn program_name(&self) -> &str {
        match self.program_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_program_name(&mut self) {
        self.program_name = ::std::option::Option::None;
    }

    pub fn has_program_name(&self) -> bool {
        self.program_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_program_name(&mut self, v: ::std::string::String) {
        self.program_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_program_name(&mut self) -> &mut ::std::string::String {
        if self.program_name.is_none() {
            self.program_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.program_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_program_name(&mut self) -> ::std::string::String {
        self.program_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string more_info = 2;

    pub fn more_info(&self) -> &str {
        match self.more_info.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_more_info(&mut self) {
        self.more_info = ::std::option::Option::None;
    }

    pub fn has_more_info(&self) -> bool {
        self.more_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_more_info(&mut self, v: ::std::string::String) {
        self.more_info = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_more_info(&mut self) -> &mut ::std::string::String {
        if self.more_info.is_none() {
            self.more_info = ::std::option::Option::Some(::std::string::String::new());
        }
        self.more_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_more_info(&mut self) -> ::std::string::String {
        self.more_info.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string digest = 3;

    pub fn digest(&self) -> &str {
        match self.digest.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_digest(&mut self) {
        self.digest = ::std::option::Option::None;
    }

    pub fn has_digest(&self) -> bool {
        self.digest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_digest(&mut self, v: ::std::string::String) {
        self.digest = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_digest(&mut self) -> &mut ::std::string::String {
        if self.digest.is_none() {
            self.digest = ::std::option::Option::Some(::std::string::String::new());
        }
        self.digest.as_mut().unwrap()
    }

    // Take field
    pub fn take_digest(&mut self) -> ::std::string::String {
        self.digest.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string digest_alg = 4;

    pub fn digest_alg(&self) -> &str {
        match self.digest_alg.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_digest_alg(&mut self) {
        self.digest_alg = ::std::option::Option::None;
    }

    pub fn has_digest_alg(&self) -> bool {
        self.digest_alg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_digest_alg(&mut self, v: ::std::string::String) {
        self.digest_alg = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_digest_alg(&mut self) -> &mut ::std::string::String {
        if self.digest_alg.is_none() {
            self.digest_alg = ::std::option::Option::Some(::std::string::String::new());
        }
        self.digest_alg.as_mut().unwrap()
    }

    // Take field
    pub fn take_digest_alg(&mut self) -> ::std::string::String {
        self.digest_alg.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "program_name",
            |m: &SignerInfo| { &m.program_name },
            |m: &mut SignerInfo| { &mut m.program_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "more_info",
            |m: &SignerInfo| { &m.more_info },
            |m: &mut SignerInfo| { &mut m.more_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "digest",
            |m: &SignerInfo| { &m.digest },
            |m: &mut SignerInfo| { &mut m.digest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "digest_alg",
            |m: &SignerInfo| { &m.digest_alg },
            |m: &mut SignerInfo| { &mut m.digest_alg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "chain",
            |m: &SignerInfo| { &m.chain },
            |m: &mut SignerInfo| { &mut m.chain },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SignerInfo>(
            "SignerInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SignerInfo {
    const NAME: &'static str = "SignerInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.program_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.more_info = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.digest = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.digest_alg = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.chain.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.program_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.more_info.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.digest.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.digest_alg.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.chain {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.program_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.more_info.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.digest.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.digest_alg.as_ref() {
            os.write_string(4, v)?;
        }
        for v in &self.chain {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SignerInfo {
        SignerInfo::new()
    }

    fn clear(&mut self) {
        self.program_name = ::std::option::Option::None;
        self.more_info = ::std::option::Option::None;
        self.digest = ::std::option::Option::None;
        self.digest_alg = ::std::option::Option::None;
        self.chain.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SignerInfo {
        static instance: SignerInfo = SignerInfo {
            program_name: ::std::option::Option::None,
            more_info: ::std::option::Option::None,
            digest: ::std::option::Option::None,
            digest_alg: ::std::option::Option::None,
            chain: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SignerInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SignerInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SignerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignerInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pe.Certificate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Certificate {
    // message fields
    // @@protoc_insertion_point(field:pe.Certificate.issuer)
    pub issuer: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:pe.Certificate.subject)
    pub subject: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:pe.Certificate.thumbprint)
    pub thumbprint: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:pe.Certificate.version)
    pub version: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:pe.Certificate.algorithm)
    pub algorithm: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:pe.Certificate.algorithm_oid)
    pub algorithm_oid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:pe.Certificate.serial)
    pub serial: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:pe.Certificate.not_before)
    pub not_before: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:pe.Certificate.not_after)
    pub not_after: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:pe.Certificate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Certificate {
    fn default() -> &'a Certificate {
        <Certificate as ::protobuf::Message>::default_instance()
    }
}

impl Certificate {
    pub fn new() -> Certificate {
        ::std::default::Default::default()
    }

    // optional string issuer = 1;

    pub fn issuer(&self) -> &str {
        match self.issuer.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_issuer(&mut self) {
        self.issuer = ::std::option::Option::None;
    }

    pub fn has_issuer(&self) -> bool {
        self.issuer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_issuer(&mut self, v: ::std::string::String) {
        self.issuer = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_issuer(&mut self) -> &mut ::std::string::String {
        if self.issuer.is_none() {
            self.issuer = ::std::option::Option::Some(::std::string::String::new());
        }
        self.issuer.as_mut().unwrap()
    }

    // Take field
    pub fn take_issuer(&mut self) -> ::std::string::String {
        self.issuer.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string subject = 2;

    pub fn subject(&self) -> &str {
        match self.subject.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_subject(&mut self) {
        self.subject = ::std::option::Option::None;
    }

    pub fn has_subject(&self) -> bool {
        self.subject.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subject(&mut self, v: ::std::string::String) {
        self.subject = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subject(&mut self) -> &mut ::std::string::String {
        if self.subject.is_none() {
            self.subject = ::std::option::Option::Some(::std::string::String::new());
        }
        self.subject.as_mut().unwrap()
    }

    // Take field
    pub fn take_subject(&mut self) -> ::std::string::String {
        self.subject.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string thumbprint = 3;

    pub fn thumbprint(&self) -> &str {
        match self.thumbprint.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_thumbprint(&mut self) {
        self.thumbprint = ::std::option::Option::None;
    }

    pub fn has_thumbprint(&self) -> bool {
        self.thumbprint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbprint(&mut self, v: ::std::string::String) {
        self.thumbprint = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbprint(&mut self) -> &mut ::std::string::String {
        if self.thumbprint.is_none() {
            self.thumbprint = ::std::option::Option::Some(::std::string::String::new());
        }
        self.thumbprint.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbprint(&mut self) -> ::std::string::String {
        self.thumbprint.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 version = 4;

    pub fn version(&self) -> i64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i64) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional string algorithm = 5;

    pub fn algorithm(&self) -> &str {
        match self.algorithm.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_algorithm(&mut self) {
        self.algorithm = ::std::option::Option::None;
    }

    pub fn has_algorithm(&self) -> bool {
        self.algorithm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_algorithm(&mut self, v: ::std::string::String) {
        self.algorithm = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_algorithm(&mut self) -> &mut ::std::string::String {
        if self.algorithm.is_none() {
            self.algorithm = ::std::option::Option::Some(::std::string::String::new());
        }
        self.algorithm.as_mut().unwrap()
    }

    // Take field
    pub fn take_algorithm(&mut self) -> ::std::string::String {
        self.algorithm.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string algorithm_oid = 6;

    pub fn algorithm_oid(&self) -> &str {
        match self.algorithm_oid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_algorithm_oid(&mut self) {
        self.algorithm_oid = ::std::option::Option::None;
    }

    pub fn has_algorithm_oid(&self) -> bool {
        self.algorithm_oid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_algorithm_oid(&mut self, v: ::std::string::String) {
        self.algorithm_oid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_algorithm_oid(&mut self) -> &mut ::std::string::String {
        if self.algorithm_oid.is_none() {
            self.algorithm_oid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.algorithm_oid.as_mut().unwrap()
    }

    // Take field
    pub fn take_algorithm_oid(&mut self) -> ::std::string::String {
        self.algorithm_oid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string serial = 7;

    pub fn serial(&self) -> &str {
        match self.serial.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_serial(&mut self) {
        self.serial = ::std::option::Option::None;
    }

    pub fn has_serial(&self) -> bool {
        self.serial.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serial(&mut self, v: ::std::string::String) {
        self.serial = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serial(&mut self) -> &mut ::std::string::String {
        if self.serial.is_none() {
            self.serial = ::std::option::Option::Some(::std::string::String::new());
        }
        self.serial.as_mut().unwrap()
    }

    // Take field
    pub fn take_serial(&mut self) -> ::std::string::String {
        self.serial.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 not_before = 8;

    pub fn not_before(&self) -> i64 {
        self.not_before.unwrap_or(0)
    }

    pub fn clear_not_before(&mut self) {
        self.not_before = ::std::option::Option::None;
    }

    pub fn has_not_before(&self) -> bool {
        self.not_before.is_some()
    }

    // Param is passed by value, moved
    pub fn set_not_before(&mut self, v: i64) {
        self.not_before = ::std::option::Option::Some(v);
    }

    // optional int64 not_after = 9;

    pub fn not_after(&self) -> i64 {
        self.not_after.unwrap_or(0)
    }

    pub fn clear_not_after(&mut self) {
        self.not_after = ::std::option::Option::None;
    }

    pub fn has_not_after(&self) -> bool {
        self.not_after.is_some()
    }

    // Param is passed by value, moved
    pub fn set_not_after(&mut self, v: i64) {
        self.not_after = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "issuer",
            |m: &Certificate| { &m.issuer },
            |m: &mut Certificate| { &mut m.issuer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subject",
            |m: &Certificate| { &m.subject },
            |m: &mut Certificate| { &mut m.subject },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbprint",
            |m: &Certificate| { &m.thumbprint },
            |m: &mut Certificate| { &mut m.thumbprint },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &Certificate| { &m.version },
            |m: &mut Certificate| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "algorithm",
            |m: &Certificate| { &m.algorithm },
            |m: &mut Certificate| { &mut m.algorithm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "algorithm_oid",
            |m: &Certificate| { &m.algorithm_oid },
            |m: &mut Certificate| { &mut m.algorithm_oid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serial",
            |m: &Certificate| { &m.serial },
            |m: &mut Certificate| { &mut m.serial },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "not_before",
            |m: &Certificate| { &m.not_before },
            |m: &mut Certificate| { &mut m.not_before },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "not_after",
            |m: &Certificate| { &m.not_after },
            |m: &mut Certificate| { &mut m.not_after },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Certificate>(
            "Certificate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Certificate {
    const NAME: &'static str = "Certificate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.issuer = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.subject = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.thumbprint = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.version = ::std::option::Option::Some(is.read_int64()?);
                },
                42 => {
                    self.algorithm = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.algorithm_oid = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.serial = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.not_before = ::std::option::Option::Some(is.read_int64()?);
                },
                72 => {
                    self.not_after = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.issuer.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.subject.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.thumbprint.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        if let Some(v) = self.algorithm.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.algorithm_oid.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.serial.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.not_before {
            my_size += ::protobuf::rt::int64_size(8, v);
        }
        if let Some(v) = self.not_after {
            my_size += ::protobuf::rt::int64_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.issuer.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.subject.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.thumbprint.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.version {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.algorithm.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.algorithm_oid.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.serial.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.not_before {
            os.write_int64(8, v)?;
        }
        if let Some(v) = self.not_after {
            os.write_int64(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Certificate {
        Certificate::new()
    }

    fn clear(&mut self) {
        self.issuer = ::std::option::Option::None;
        self.subject = ::std::option::Option::None;
        self.thumbprint = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.algorithm = ::std::option::Option::None;
        self.algorithm_oid = ::std::option::Option::None;
        self.serial = ::std::option::Option::None;
        self.not_before = ::std::option::Option::None;
        self.not_after = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Certificate {
        static instance: Certificate = Certificate {
            issuer: ::std::option::Option::None,
            subject: ::std::option::Option::None,
            thumbprint: ::std::option::Option::None,
            version: ::std::option::Option::None,
            algorithm: ::std::option::Option::None,
            algorithm_oid: ::std::option::Option::None,
            serial: ::std::option::Option::None,
            not_before: ::std::option::Option::None,
            not_after: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Certificate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Certificate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Certificate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Certificate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pe.CounterSignature)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CounterSignature {
    // message fields
    // @@protoc_insertion_point(field:pe.CounterSignature.verified)
    pub verified: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:pe.CounterSignature.sign_time)
    pub sign_time: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:pe.CounterSignature.digest)
    pub digest: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:pe.CounterSignature.digest_alg)
    pub digest_alg: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:pe.CounterSignature.chain)
    pub chain: ::std::vec::Vec<Certificate>,
    // special fields
    // @@protoc_insertion_point(special_field:pe.CounterSignature.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CounterSignature {
    fn default() -> &'a CounterSignature {
        <CounterSignature as ::protobuf::Message>::default_instance()
    }
}

impl CounterSignature {
    pub fn new() -> CounterSignature {
        ::std::default::Default::default()
    }

    // optional bool verified = 1;

    pub fn verified(&self) -> bool {
        self.verified.unwrap_or(false)
    }

    pub fn clear_verified(&mut self) {
        self.verified = ::std::option::Option::None;
    }

    pub fn has_verified(&self) -> bool {
        self.verified.is_some()
    }

    // Param is passed by value, moved
    pub fn set_verified(&mut self, v: bool) {
        self.verified = ::std::option::Option::Some(v);
    }

    // optional int64 sign_time = 2;

    pub fn sign_time(&self) -> i64 {
        self.sign_time.unwrap_or(0)
    }

    pub fn clear_sign_time(&mut self) {
        self.sign_time = ::std::option::Option::None;
    }

    pub fn has_sign_time(&self) -> bool {
        self.sign_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sign_time(&mut self, v: i64) {
        self.sign_time = ::std::option::Option::Some(v);
    }

    // optional string digest = 12;

    pub fn digest(&self) -> &str {
        match self.digest.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_digest(&mut self) {
        self.digest = ::std::option::Option::None;
    }

    pub fn has_digest(&self) -> bool {
        self.digest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_digest(&mut self, v: ::std::string::String) {
        self.digest = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_digest(&mut self) -> &mut ::std::string::String {
        if self.digest.is_none() {
            self.digest = ::std::option::Option::Some(::std::string::String::new());
        }
        self.digest.as_mut().unwrap()
    }

    // Take field
    pub fn take_digest(&mut self) -> ::std::string::String {
        self.digest.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string digest_alg = 3;

    pub fn digest_alg(&self) -> &str {
        match self.digest_alg.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_digest_alg(&mut self) {
        self.digest_alg = ::std::option::Option::None;
    }

    pub fn has_digest_alg(&self) -> bool {
        self.digest_alg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_digest_alg(&mut self, v: ::std::string::String) {
        self.digest_alg = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_digest_alg(&mut self) -> &mut ::std::string::String {
        if self.digest_alg.is_none() {
            self.digest_alg = ::std::option::Option::Some(::std::string::String::new());
        }
        self.digest_alg.as_mut().unwrap()
    }

    // Take field
    pub fn take_digest_alg(&mut self) -> ::std::string::String {
        self.digest_alg.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "verified",
            |m: &CounterSignature| { &m.verified },
            |m: &mut CounterSignature| { &mut m.verified },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sign_time",
            |m: &CounterSignature| { &m.sign_time },
            |m: &mut CounterSignature| { &mut m.sign_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "digest",
            |m: &CounterSignature| { &m.digest },
            |m: &mut CounterSignature| { &mut m.digest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "digest_alg",
            |m: &CounterSignature| { &m.digest_alg },
            |m: &mut CounterSignature| { &mut m.digest_alg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "chain",
            |m: &CounterSignature| { &m.chain },
            |m: &mut CounterSignature| { &mut m.chain },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CounterSignature>(
            "CounterSignature",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CounterSignature {
    const NAME: &'static str = "CounterSignature";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.verified = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.sign_time = ::std::option::Option::Some(is.read_int64()?);
                },
                98 => {
                    self.digest = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.digest_alg = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.chain.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.verified {
            my_size += 1 + 1;
        }
        if let Some(v) = self.sign_time {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.digest.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.digest_alg.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.chain {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.verified {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.sign_time {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.digest.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.digest_alg.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.chain {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CounterSignature {
        CounterSignature::new()
    }

    fn clear(&mut self) {
        self.verified = ::std::option::Option::None;
        self.sign_time = ::std::option::Option::None;
        self.digest = ::std::option::Option::None;
        self.digest_alg = ::std::option::Option::None;
        self.chain.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CounterSignature {
        static instance: CounterSignature = CounterSignature {
            verified: ::std::option::Option::None,
            sign_time: ::std::option::Option::None,
            digest: ::std::option::Option::None,
            digest_alg: ::std::option::Option::None,
            chain: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CounterSignature {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CounterSignature").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CounterSignature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CounterSignature {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pe.Section)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Section {
    // message fields
    // @@protoc_insertion_point(field:pe.Section.name)
    pub name: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:pe.Section.full_name)
    pub full_name: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:pe.Section.characteristics)
    pub characteristics: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.Section.raw_data_size)
    pub raw_data_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.Section.raw_data_offset)
    pub raw_data_offset: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.Section.virtual_address)
    pub virtual_address: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.Section.virtual_size)
    pub virtual_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.Section.pointer_to_relocations)
    pub pointer_to_relocations: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.Section.pointer_to_line_numbers)
    pub pointer_to_line_numbers: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.Section.number_of_relocations)
    pub number_of_relocations: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.Section.number_of_line_numbers)
    pub number_of_line_numbers: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:pe.Section.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Section {
    fn default() -> &'a Section {
        <Section as ::protobuf::Message>::default_instance()
    }
}

impl Section {
    pub fn new() -> Section {
        ::std::default::Default::default()
    }

    // required bytes name = 1;

    pub fn name(&self) -> &[u8] {
        match self.name.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::vec::Vec<u8>) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::vec::Vec<u8> {
        self.name.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes full_name = 2;

    pub fn full_name(&self) -> &[u8] {
        match self.full_name.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_full_name(&mut self) {
        self.full_name = ::std::option::Option::None;
    }

    pub fn has_full_name(&self) -> bool {
        self.full_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_full_name(&mut self, v: ::std::vec::Vec<u8>) {
        self.full_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_full_name(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.full_name.is_none() {
            self.full_name = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.full_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_full_name(&mut self) -> ::std::vec::Vec<u8> {
        self.full_name.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required uint32 characteristics = 3;

    pub fn characteristics(&self) -> u32 {
        self.characteristics.unwrap_or(0)
    }

    pub fn clear_characteristics(&mut self) {
        self.characteristics = ::std::option::Option::None;
    }

    pub fn has_characteristics(&self) -> bool {
        self.characteristics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_characteristics(&mut self, v: u32) {
        self.characteristics = ::std::option::Option::Some(v);
    }

    // required uint32 raw_data_size = 4;

    pub fn raw_data_size(&self) -> u32 {
        self.raw_data_size.unwrap_or(0)
    }

    pub fn clear_raw_data_size(&mut self) {
        self.raw_data_size = ::std::option::Option::None;
    }

    pub fn has_raw_data_size(&self) -> bool {
        self.raw_data_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_data_size(&mut self, v: u32) {
        self.raw_data_size = ::std::option::Option::Some(v);
    }

    // required uint32 raw_data_offset = 5;

    pub fn raw_data_offset(&self) -> u32 {
        self.raw_data_offset.unwrap_or(0)
    }

    pub fn clear_raw_data_offset(&mut self) {
        self.raw_data_offset = ::std::option::Option::None;
    }

    pub fn has_raw_data_offset(&self) -> bool {
        self.raw_data_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_data_offset(&mut self, v: u32) {
        self.raw_data_offset = ::std::option::Option::Some(v);
    }

    // required uint32 virtual_address = 6;

    pub fn virtual_address(&self) -> u32 {
        self.virtual_address.unwrap_or(0)
    }

    pub fn clear_virtual_address(&mut self) {
        self.virtual_address = ::std::option::Option::None;
    }

    pub fn has_virtual_address(&self) -> bool {
        self.virtual_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_virtual_address(&mut self, v: u32) {
        self.virtual_address = ::std::option::Option::Some(v);
    }

    // required uint32 virtual_size = 7;

    pub fn virtual_size(&self) -> u32 {
        self.virtual_size.unwrap_or(0)
    }

    pub fn clear_virtual_size(&mut self) {
        self.virtual_size = ::std::option::Option::None;
    }

    pub fn has_virtual_size(&self) -> bool {
        self.virtual_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_virtual_size(&mut self, v: u32) {
        self.virtual_size = ::std::option::Option::Some(v);
    }

    // required uint32 pointer_to_relocations = 8;

    pub fn pointer_to_relocations(&self) -> u32 {
        self.pointer_to_relocations.unwrap_or(0)
    }

    pub fn clear_pointer_to_relocations(&mut self) {
        self.pointer_to_relocations = ::std::option::Option::None;
    }

    pub fn has_pointer_to_relocations(&self) -> bool {
        self.pointer_to_relocations.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pointer_to_relocations(&mut self, v: u32) {
        self.pointer_to_relocations = ::std::option::Option::Some(v);
    }

    // required uint32 pointer_to_line_numbers = 9;

    pub fn pointer_to_line_numbers(&self) -> u32 {
        self.pointer_to_line_numbers.unwrap_or(0)
    }

    pub fn clear_pointer_to_line_numbers(&mut self) {
        self.pointer_to_line_numbers = ::std::option::Option::None;
    }

    pub fn has_pointer_to_line_numbers(&self) -> bool {
        self.pointer_to_line_numbers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pointer_to_line_numbers(&mut self, v: u32) {
        self.pointer_to_line_numbers = ::std::option::Option::Some(v);
    }

    // required uint32 number_of_relocations = 10;

    pub fn number_of_relocations(&self) -> u32 {
        self.number_of_relocations.unwrap_or(0)
    }

    pub fn clear_number_of_relocations(&mut self) {
        self.number_of_relocations = ::std::option::Option::None;
    }

    pub fn has_number_of_relocations(&self) -> bool {
        self.number_of_relocations.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number_of_relocations(&mut self, v: u32) {
        self.number_of_relocations = ::std::option::Option::Some(v);
    }

    // required uint32 number_of_line_numbers = 11;

    pub fn number_of_line_numbers(&self) -> u32 {
        self.number_of_line_numbers.unwrap_or(0)
    }

    pub fn clear_number_of_line_numbers(&mut self) {
        self.number_of_line_numbers = ::std::option::Option::None;
    }

    pub fn has_number_of_line_numbers(&self) -> bool {
        self.number_of_line_numbers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number_of_line_numbers(&mut self, v: u32) {
        self.number_of_line_numbers = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &Section| { &m.name },
            |m: &mut Section| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "full_name",
            |m: &Section| { &m.full_name },
            |m: &mut Section| { &mut m.full_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "characteristics",
            |m: &Section| { &m.characteristics },
            |m: &mut Section| { &mut m.characteristics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "raw_data_size",
            |m: &Section| { &m.raw_data_size },
            |m: &mut Section| { &mut m.raw_data_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "raw_data_offset",
            |m: &Section| { &m.raw_data_offset },
            |m: &mut Section| { &mut m.raw_data_offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "virtual_address",
            |m: &Section| { &m.virtual_address },
            |m: &mut Section| { &mut m.virtual_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "virtual_size",
            |m: &Section| { &m.virtual_size },
            |m: &mut Section| { &mut m.virtual_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pointer_to_relocations",
            |m: &Section| { &m.pointer_to_relocations },
            |m: &mut Section| { &mut m.pointer_to_relocations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pointer_to_line_numbers",
            |m: &Section| { &m.pointer_to_line_numbers },
            |m: &mut Section| { &mut m.pointer_to_line_numbers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "number_of_relocations",
            |m: &Section| { &m.number_of_relocations },
            |m: &mut Section| { &mut m.number_of_relocations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "number_of_line_numbers",
            |m: &Section| { &m.number_of_line_numbers },
            |m: &mut Section| { &mut m.number_of_line_numbers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Section>(
            "Section",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Section {
    const NAME: &'static str = "Section";

    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        if self.full_name.is_none() {
            return false;
        }
        if self.characteristics.is_none() {
            return false;
        }
        if self.raw_data_size.is_none() {
            return false;
        }
        if self.raw_data_offset.is_none() {
            return false;
        }
        if self.virtual_address.is_none() {
            return false;
        }
        if self.virtual_size.is_none() {
            return false;
        }
        if self.pointer_to_relocations.is_none() {
            return false;
        }
        if self.pointer_to_line_numbers.is_none() {
            return false;
        }
        if self.number_of_relocations.is_none() {
            return false;
        }
        if self.number_of_line_numbers.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.full_name = ::std::option::Option::Some(is.read_bytes()?);
                },
                24 => {
                    self.characteristics = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.raw_data_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.raw_data_offset = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.virtual_address = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.virtual_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.pointer_to_relocations = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.pointer_to_line_numbers = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.number_of_relocations = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.number_of_line_numbers = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.full_name.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.characteristics {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.raw_data_size {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.raw_data_offset {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.virtual_address {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.virtual_size {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.pointer_to_relocations {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.pointer_to_line_numbers {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.number_of_relocations {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.number_of_line_numbers {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.full_name.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.characteristics {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.raw_data_size {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.raw_data_offset {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.virtual_address {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.virtual_size {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.pointer_to_relocations {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.pointer_to_line_numbers {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.number_of_relocations {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.number_of_line_numbers {
            os.write_uint32(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Section {
        Section::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.full_name = ::std::option::Option::None;
        self.characteristics = ::std::option::Option::None;
        self.raw_data_size = ::std::option::Option::None;
        self.raw_data_offset = ::std::option::Option::None;
        self.virtual_address = ::std::option::Option::None;
        self.virtual_size = ::std::option::Option::None;
        self.pointer_to_relocations = ::std::option::Option::None;
        self.pointer_to_line_numbers = ::std::option::Option::None;
        self.number_of_relocations = ::std::option::Option::None;
        self.number_of_line_numbers = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Section {
        static instance: Section = Section {
            name: ::std::option::Option::None,
            full_name: ::std::option::Option::None,
            characteristics: ::std::option::Option::None,
            raw_data_size: ::std::option::Option::None,
            raw_data_offset: ::std::option::Option::None,
            virtual_address: ::std::option::Option::None,
            virtual_size: ::std::option::Option::None,
            pointer_to_relocations: ::std::option::Option::None,
            pointer_to_line_numbers: ::std::option::Option::None,
            number_of_relocations: ::std::option::Option::None,
            number_of_line_numbers: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Section {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Section").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Section {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Section {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pe.RichSignature)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RichSignature {
    // message fields
    // @@protoc_insertion_point(field:pe.RichSignature.offset)
    pub offset: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.RichSignature.length)
    pub length: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.RichSignature.key)
    pub key: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.RichSignature.raw_data)
    pub raw_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:pe.RichSignature.clear_data)
    pub clear_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:pe.RichSignature.tools)
    pub tools: ::std::vec::Vec<RichTool>,
    // special fields
    // @@protoc_insertion_point(special_field:pe.RichSignature.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RichSignature {
    fn default() -> &'a RichSignature {
        <RichSignature as ::protobuf::Message>::default_instance()
    }
}

impl RichSignature {
    pub fn new() -> RichSignature {
        ::std::default::Default::default()
    }

    // required uint32 offset = 1;

    pub fn offset(&self) -> u32 {
        self.offset.unwrap_or(0)
    }

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u32) {
        self.offset = ::std::option::Option::Some(v);
    }

    // required uint32 length = 2;

    pub fn length(&self) -> u32 {
        self.length.unwrap_or(0)
    }

    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: u32) {
        self.length = ::std::option::Option::Some(v);
    }

    // required uint32 key = 3;

    pub fn key(&self) -> u32 {
        self.key.unwrap_or(0)
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = ::std::option::Option::Some(v);
    }

    // required bytes raw_data = 4;

    pub fn raw_data(&self) -> &[u8] {
        match self.raw_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_raw_data(&mut self) {
        self.raw_data = ::std::option::Option::None;
    }

    pub fn has_raw_data(&self) -> bool {
        self.raw_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.raw_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raw_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.raw_data.is_none() {
            self.raw_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.raw_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_raw_data(&mut self) -> ::std::vec::Vec<u8> {
        self.raw_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes clear_data = 5;

    pub fn clear_data(&self) -> &[u8] {
        match self.clear_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_clear_data(&mut self) {
        self.clear_data = ::std::option::Option::None;
    }

    pub fn has_clear_data(&self) -> bool {
        self.clear_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clear_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.clear_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clear_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.clear_data.is_none() {
            self.clear_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.clear_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_clear_data(&mut self) -> ::std::vec::Vec<u8> {
        self.clear_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "offset",
            |m: &RichSignature| { &m.offset },
            |m: &mut RichSignature| { &mut m.offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "length",
            |m: &RichSignature| { &m.length },
            |m: &mut RichSignature| { &mut m.length },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &RichSignature| { &m.key },
            |m: &mut RichSignature| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "raw_data",
            |m: &RichSignature| { &m.raw_data },
            |m: &mut RichSignature| { &mut m.raw_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "clear_data",
            |m: &RichSignature| { &m.clear_data },
            |m: &mut RichSignature| { &mut m.clear_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tools",
            |m: &RichSignature| { &m.tools },
            |m: &mut RichSignature| { &mut m.tools },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RichSignature>(
            "RichSignature",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RichSignature {
    const NAME: &'static str = "RichSignature";

    fn is_initialized(&self) -> bool {
        if self.offset.is_none() {
            return false;
        }
        if self.length.is_none() {
            return false;
        }
        if self.key.is_none() {
            return false;
        }
        if self.raw_data.is_none() {
            return false;
        }
        if self.clear_data.is_none() {
            return false;
        }
        for v in &self.tools {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.offset = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.length = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.key = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.raw_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                42 => {
                    self.clear_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                50 => {
                    self.tools.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.key {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.raw_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.clear_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        for value in &self.tools {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.offset {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.length {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.key {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.raw_data.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.clear_data.as_ref() {
            os.write_bytes(5, v)?;
        }
        for v in &self.tools {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RichSignature {
        RichSignature::new()
    }

    fn clear(&mut self) {
        self.offset = ::std::option::Option::None;
        self.length = ::std::option::Option::None;
        self.key = ::std::option::Option::None;
        self.raw_data = ::std::option::Option::None;
        self.clear_data = ::std::option::Option::None;
        self.tools.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RichSignature {
        static instance: RichSignature = RichSignature {
            offset: ::std::option::Option::None,
            length: ::std::option::Option::None,
            key: ::std::option::Option::None,
            raw_data: ::std::option::Option::None,
            clear_data: ::std::option::Option::None,
            tools: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RichSignature {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RichSignature").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RichSignature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RichSignature {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pe.RichTool)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RichTool {
    // message fields
    // @@protoc_insertion_point(field:pe.RichTool.toolid)
    pub toolid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.RichTool.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:pe.RichTool.times)
    pub times: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:pe.RichTool.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RichTool {
    fn default() -> &'a RichTool {
        <RichTool as ::protobuf::Message>::default_instance()
    }
}

impl RichTool {
    pub fn new() -> RichTool {
        ::std::default::Default::default()
    }

    // required uint32 toolid = 1;

    pub fn toolid(&self) -> u32 {
        self.toolid.unwrap_or(0)
    }

    pub fn clear_toolid(&mut self) {
        self.toolid = ::std::option::Option::None;
    }

    pub fn has_toolid(&self) -> bool {
        self.toolid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_toolid(&mut self, v: u32) {
        self.toolid = ::std::option::Option::Some(v);
    }

    // required uint32 version = 2;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // required uint32 times = 3;

    pub fn times(&self) -> u32 {
        self.times.unwrap_or(0)
    }

    pub fn clear_times(&mut self) {
        self.times = ::std::option::Option::None;
    }

    pub fn has_times(&self) -> bool {
        self.times.is_some()
    }

    // Param is passed by value, moved
    pub fn set_times(&mut self, v: u32) {
        self.times = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "toolid",
            |m: &RichTool| { &m.toolid },
            |m: &mut RichTool| { &mut m.toolid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &RichTool| { &m.version },
            |m: &mut RichTool| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "times",
            |m: &RichTool| { &m.times },
            |m: &mut RichTool| { &mut m.times },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RichTool>(
            "RichTool",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RichTool {
    const NAME: &'static str = "RichTool";

    fn is_initialized(&self) -> bool {
        if self.toolid.is_none() {
            return false;
        }
        if self.version.is_none() {
            return false;
        }
        if self.times.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.toolid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.times = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.toolid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.times {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.toolid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.version {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.times {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RichTool {
        RichTool::new()
    }

    fn clear(&mut self) {
        self.toolid = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.times = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RichTool {
        static instance: RichTool = RichTool {
            toolid: ::std::option::Option::None,
            version: ::std::option::Option::None,
            times: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RichTool {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RichTool").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RichTool {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RichTool {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pe.Overlay)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Overlay {
    // message fields
    // @@protoc_insertion_point(field:pe.Overlay.offset)
    pub offset: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:pe.Overlay.size)
    pub size: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:pe.Overlay.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Overlay {
    fn default() -> &'a Overlay {
        <Overlay as ::protobuf::Message>::default_instance()
    }
}

impl Overlay {
    pub fn new() -> Overlay {
        ::std::default::Default::default()
    }

    // required uint64 offset = 1;

    pub fn offset(&self) -> u64 {
        self.offset.unwrap_or(0)
    }

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u64) {
        self.offset = ::std::option::Option::Some(v);
    }

    // required uint64 size = 2;

    pub fn size(&self) -> u64 {
        self.size.unwrap_or(0)
    }

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u64) {
        self.size = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "offset",
            |m: &Overlay| { &m.offset },
            |m: &mut Overlay| { &mut m.offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "size",
            |m: &Overlay| { &m.size },
            |m: &mut Overlay| { &mut m.size },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Overlay>(
            "Overlay",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Overlay {
    const NAME: &'static str = "Overlay";

    fn is_initialized(&self) -> bool {
        if self.offset.is_none() {
            return false;
        }
        if self.size.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.offset = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.size = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.offset {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.size {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Overlay {
        Overlay::new()
    }

    fn clear(&mut self) {
        self.offset = ::std::option::Option::None;
        self.size = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Overlay {
        static instance: Overlay = Overlay {
            offset: ::std::option::Option::None,
            size: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Overlay {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Overlay").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Overlay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Overlay {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:pe.ResourceType)
pub enum ResourceType {
    // @@protoc_insertion_point(enum_value:pe.ResourceType.RESOURCE_TYPE_CURSOR)
    RESOURCE_TYPE_CURSOR = 1,
    // @@protoc_insertion_point(enum_value:pe.ResourceType.RESOURCE_TYPE_BITMAP)
    RESOURCE_TYPE_BITMAP = 2,
    // @@protoc_insertion_point(enum_value:pe.ResourceType.RESOURCE_TYPE_ICON)
    RESOURCE_TYPE_ICON = 3,
    // @@protoc_insertion_point(enum_value:pe.ResourceType.RESOURCE_TYPE_MENU)
    RESOURCE_TYPE_MENU = 4,
    // @@protoc_insertion_point(enum_value:pe.ResourceType.RESOURCE_TYPE_DIALOG)
    RESOURCE_TYPE_DIALOG = 5,
    // @@protoc_insertion_point(enum_value:pe.ResourceType.RESOURCE_TYPE_STRING)
    RESOURCE_TYPE_STRING = 6,
    // @@protoc_insertion_point(enum_value:pe.ResourceType.RESOURCE_TYPE_FONTDIR)
    RESOURCE_TYPE_FONTDIR = 7,
    // @@protoc_insertion_point(enum_value:pe.ResourceType.RESOURCE_TYPE_FONT)
    RESOURCE_TYPE_FONT = 8,
    // @@protoc_insertion_point(enum_value:pe.ResourceType.RESOURCE_TYPE_ACCELERATOR)
    RESOURCE_TYPE_ACCELERATOR = 9,
    // @@protoc_insertion_point(enum_value:pe.ResourceType.RESOURCE_TYPE_RCDATA)
    RESOURCE_TYPE_RCDATA = 10,
    // @@protoc_insertion_point(enum_value:pe.ResourceType.RESOURCE_TYPE_MESSAGETABLE)
    RESOURCE_TYPE_MESSAGETABLE = 11,
    // @@protoc_insertion_point(enum_value:pe.ResourceType.RESOURCE_TYPE_GROUP_CURSOR)
    RESOURCE_TYPE_GROUP_CURSOR = 12,
    // @@protoc_insertion_point(enum_value:pe.ResourceType.RESOURCE_TYPE_GROUP_ICON)
    RESOURCE_TYPE_GROUP_ICON = 14,
    // @@protoc_insertion_point(enum_value:pe.ResourceType.RESOURCE_TYPE_VERSION)
    RESOURCE_TYPE_VERSION = 16,
    // @@protoc_insertion_point(enum_value:pe.ResourceType.RESOURCE_TYPE_DLGINCLUDE)
    RESOURCE_TYPE_DLGINCLUDE = 17,
    // @@protoc_insertion_point(enum_value:pe.ResourceType.RESOURCE_TYPE_PLUGPLAY)
    RESOURCE_TYPE_PLUGPLAY = 19,
    // @@protoc_insertion_point(enum_value:pe.ResourceType.RESOURCE_TYPE_VXD)
    RESOURCE_TYPE_VXD = 20,
    // @@protoc_insertion_point(enum_value:pe.ResourceType.RESOURCE_TYPE_ANICURSOR)
    RESOURCE_TYPE_ANICURSOR = 21,
    // @@protoc_insertion_point(enum_value:pe.ResourceType.RESOURCE_TYPE_ANIICON)
    RESOURCE_TYPE_ANIICON = 22,
    // @@protoc_insertion_point(enum_value:pe.ResourceType.RESOURCE_TYPE_HTML)
    RESOURCE_TYPE_HTML = 23,
    // @@protoc_insertion_point(enum_value:pe.ResourceType.RESOURCE_TYPE_MANIFEST)
    RESOURCE_TYPE_MANIFEST = 24,
}

impl ::protobuf::Enum for ResourceType {
    const NAME: &'static str = "ResourceType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ResourceType> {
        match value {
            1 => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_CURSOR),
            2 => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_BITMAP),
            3 => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_ICON),
            4 => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_MENU),
            5 => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_DIALOG),
            6 => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_STRING),
            7 => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_FONTDIR),
            8 => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_FONT),
            9 => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_ACCELERATOR),
            10 => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_RCDATA),
            11 => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_MESSAGETABLE),
            12 => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_GROUP_CURSOR),
            14 => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_GROUP_ICON),
            16 => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_VERSION),
            17 => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_DLGINCLUDE),
            19 => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_PLUGPLAY),
            20 => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_VXD),
            21 => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_ANICURSOR),
            22 => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_ANIICON),
            23 => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_HTML),
            24 => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_MANIFEST),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ResourceType> {
        match str {
            "RESOURCE_TYPE_CURSOR" => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_CURSOR),
            "RESOURCE_TYPE_BITMAP" => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_BITMAP),
            "RESOURCE_TYPE_ICON" => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_ICON),
            "RESOURCE_TYPE_MENU" => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_MENU),
            "RESOURCE_TYPE_DIALOG" => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_DIALOG),
            "RESOURCE_TYPE_STRING" => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_STRING),
            "RESOURCE_TYPE_FONTDIR" => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_FONTDIR),
            "RESOURCE_TYPE_FONT" => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_FONT),
            "RESOURCE_TYPE_ACCELERATOR" => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_ACCELERATOR),
            "RESOURCE_TYPE_RCDATA" => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_RCDATA),
            "RESOURCE_TYPE_MESSAGETABLE" => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_MESSAGETABLE),
            "RESOURCE_TYPE_GROUP_CURSOR" => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_GROUP_CURSOR),
            "RESOURCE_TYPE_GROUP_ICON" => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_GROUP_ICON),
            "RESOURCE_TYPE_VERSION" => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_VERSION),
            "RESOURCE_TYPE_DLGINCLUDE" => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_DLGINCLUDE),
            "RESOURCE_TYPE_PLUGPLAY" => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_PLUGPLAY),
            "RESOURCE_TYPE_VXD" => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_VXD),
            "RESOURCE_TYPE_ANICURSOR" => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_ANICURSOR),
            "RESOURCE_TYPE_ANIICON" => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_ANIICON),
            "RESOURCE_TYPE_HTML" => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_HTML),
            "RESOURCE_TYPE_MANIFEST" => ::std::option::Option::Some(ResourceType::RESOURCE_TYPE_MANIFEST),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ResourceType] = &[
        ResourceType::RESOURCE_TYPE_CURSOR,
        ResourceType::RESOURCE_TYPE_BITMAP,
        ResourceType::RESOURCE_TYPE_ICON,
        ResourceType::RESOURCE_TYPE_MENU,
        ResourceType::RESOURCE_TYPE_DIALOG,
        ResourceType::RESOURCE_TYPE_STRING,
        ResourceType::RESOURCE_TYPE_FONTDIR,
        ResourceType::RESOURCE_TYPE_FONT,
        ResourceType::RESOURCE_TYPE_ACCELERATOR,
        ResourceType::RESOURCE_TYPE_RCDATA,
        ResourceType::RESOURCE_TYPE_MESSAGETABLE,
        ResourceType::RESOURCE_TYPE_GROUP_CURSOR,
        ResourceType::RESOURCE_TYPE_GROUP_ICON,
        ResourceType::RESOURCE_TYPE_VERSION,
        ResourceType::RESOURCE_TYPE_DLGINCLUDE,
        ResourceType::RESOURCE_TYPE_PLUGPLAY,
        ResourceType::RESOURCE_TYPE_VXD,
        ResourceType::RESOURCE_TYPE_ANICURSOR,
        ResourceType::RESOURCE_TYPE_ANIICON,
        ResourceType::RESOURCE_TYPE_HTML,
        ResourceType::RESOURCE_TYPE_MANIFEST,
    ];
}

impl ::protobuf::EnumFull for ResourceType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ResourceType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ResourceType::RESOURCE_TYPE_CURSOR => 0,
            ResourceType::RESOURCE_TYPE_BITMAP => 1,
            ResourceType::RESOURCE_TYPE_ICON => 2,
            ResourceType::RESOURCE_TYPE_MENU => 3,
            ResourceType::RESOURCE_TYPE_DIALOG => 4,
            ResourceType::RESOURCE_TYPE_STRING => 5,
            ResourceType::RESOURCE_TYPE_FONTDIR => 6,
            ResourceType::RESOURCE_TYPE_FONT => 7,
            ResourceType::RESOURCE_TYPE_ACCELERATOR => 8,
            ResourceType::RESOURCE_TYPE_RCDATA => 9,
            ResourceType::RESOURCE_TYPE_MESSAGETABLE => 10,
            ResourceType::RESOURCE_TYPE_GROUP_CURSOR => 11,
            ResourceType::RESOURCE_TYPE_GROUP_ICON => 12,
            ResourceType::RESOURCE_TYPE_VERSION => 13,
            ResourceType::RESOURCE_TYPE_DLGINCLUDE => 14,
            ResourceType::RESOURCE_TYPE_PLUGPLAY => 15,
            ResourceType::RESOURCE_TYPE_VXD => 16,
            ResourceType::RESOURCE_TYPE_ANICURSOR => 17,
            ResourceType::RESOURCE_TYPE_ANIICON => 18,
            ResourceType::RESOURCE_TYPE_HTML => 19,
            ResourceType::RESOURCE_TYPE_MANIFEST => 20,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ResourceType {
    fn default() -> Self {
        ResourceType::RESOURCE_TYPE_CURSOR
    }
}

impl ResourceType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ResourceType>("ResourceType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:pe.Machine)
pub enum Machine {
    // @@protoc_insertion_point(enum_value:pe.Machine.MACHINE_UNKNOWN)
    MACHINE_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:pe.Machine.MACHINE_AM33)
    MACHINE_AM33 = 467,
    // @@protoc_insertion_point(enum_value:pe.Machine.MACHINE_AMD64)
    MACHINE_AMD64 = 34404,
    // @@protoc_insertion_point(enum_value:pe.Machine.MACHINE_ARM)
    MACHINE_ARM = 448,
    // @@protoc_insertion_point(enum_value:pe.Machine.MACHINE_ARMNT)
    MACHINE_ARMNT = 452,
    // @@protoc_insertion_point(enum_value:pe.Machine.MACHINE_ARM64)
    MACHINE_ARM64 = 43620,
    // @@protoc_insertion_point(enum_value:pe.Machine.MACHINE_EBC)
    MACHINE_EBC = 3772,
    // @@protoc_insertion_point(enum_value:pe.Machine.MACHINE_I386)
    MACHINE_I386 = 332,
    // @@protoc_insertion_point(enum_value:pe.Machine.MACHINE_IA64)
    MACHINE_IA64 = 512,
    // @@protoc_insertion_point(enum_value:pe.Machine.MACHINE_M32R)
    MACHINE_M32R = 36929,
    // @@protoc_insertion_point(enum_value:pe.Machine.MACHINE_MIPS16)
    MACHINE_MIPS16 = 614,
    // @@protoc_insertion_point(enum_value:pe.Machine.MACHINE_MIPSFPU)
    MACHINE_MIPSFPU = 870,
    // @@protoc_insertion_point(enum_value:pe.Machine.MACHINE_MIPSFPU16)
    MACHINE_MIPSFPU16 = 1126,
    // @@protoc_insertion_point(enum_value:pe.Machine.MACHINE_POWERPC)
    MACHINE_POWERPC = 496,
    // @@protoc_insertion_point(enum_value:pe.Machine.MACHINE_POWERPCFP)
    MACHINE_POWERPCFP = 497,
    // @@protoc_insertion_point(enum_value:pe.Machine.MACHINE_R4000)
    MACHINE_R4000 = 358,
    // @@protoc_insertion_point(enum_value:pe.Machine.MACHINE_SH3)
    MACHINE_SH3 = 418,
    // @@protoc_insertion_point(enum_value:pe.Machine.MACHINE_SH3DSP)
    MACHINE_SH3DSP = 419,
    // @@protoc_insertion_point(enum_value:pe.Machine.MACHINE_SH4)
    MACHINE_SH4 = 422,
    // @@protoc_insertion_point(enum_value:pe.Machine.MACHINE_SH5)
    MACHINE_SH5 = 424,
    // @@protoc_insertion_point(enum_value:pe.Machine.MACHINE_THUMB)
    MACHINE_THUMB = 450,
    // @@protoc_insertion_point(enum_value:pe.Machine.MACHINE_WCEMIPSV2)
    MACHINE_WCEMIPSV2 = 361,
}

impl ::protobuf::Enum for Machine {
    const NAME: &'static str = "Machine";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Machine> {
        match value {
            0 => ::std::option::Option::Some(Machine::MACHINE_UNKNOWN),
            467 => ::std::option::Option::Some(Machine::MACHINE_AM33),
            34404 => ::std::option::Option::Some(Machine::MACHINE_AMD64),
            448 => ::std::option::Option::Some(Machine::MACHINE_ARM),
            452 => ::std::option::Option::Some(Machine::MACHINE_ARMNT),
            43620 => ::std::option::Option::Some(Machine::MACHINE_ARM64),
            3772 => ::std::option::Option::Some(Machine::MACHINE_EBC),
            332 => ::std::option::Option::Some(Machine::MACHINE_I386),
            512 => ::std::option::Option::Some(Machine::MACHINE_IA64),
            36929 => ::std::option::Option::Some(Machine::MACHINE_M32R),
            614 => ::std::option::Option::Some(Machine::MACHINE_MIPS16),
            870 => ::std::option::Option::Some(Machine::MACHINE_MIPSFPU),
            1126 => ::std::option::Option::Some(Machine::MACHINE_MIPSFPU16),
            496 => ::std::option::Option::Some(Machine::MACHINE_POWERPC),
            497 => ::std::option::Option::Some(Machine::MACHINE_POWERPCFP),
            358 => ::std::option::Option::Some(Machine::MACHINE_R4000),
            418 => ::std::option::Option::Some(Machine::MACHINE_SH3),
            419 => ::std::option::Option::Some(Machine::MACHINE_SH3DSP),
            422 => ::std::option::Option::Some(Machine::MACHINE_SH4),
            424 => ::std::option::Option::Some(Machine::MACHINE_SH5),
            450 => ::std::option::Option::Some(Machine::MACHINE_THUMB),
            361 => ::std::option::Option::Some(Machine::MACHINE_WCEMIPSV2),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Machine> {
        match str {
            "MACHINE_UNKNOWN" => ::std::option::Option::Some(Machine::MACHINE_UNKNOWN),
            "MACHINE_AM33" => ::std::option::Option::Some(Machine::MACHINE_AM33),
            "MACHINE_AMD64" => ::std::option::Option::Some(Machine::MACHINE_AMD64),
            "MACHINE_ARM" => ::std::option::Option::Some(Machine::MACHINE_ARM),
            "MACHINE_ARMNT" => ::std::option::Option::Some(Machine::MACHINE_ARMNT),
            "MACHINE_ARM64" => ::std::option::Option::Some(Machine::MACHINE_ARM64),
            "MACHINE_EBC" => ::std::option::Option::Some(Machine::MACHINE_EBC),
            "MACHINE_I386" => ::std::option::Option::Some(Machine::MACHINE_I386),
            "MACHINE_IA64" => ::std::option::Option::Some(Machine::MACHINE_IA64),
            "MACHINE_M32R" => ::std::option::Option::Some(Machine::MACHINE_M32R),
            "MACHINE_MIPS16" => ::std::option::Option::Some(Machine::MACHINE_MIPS16),
            "MACHINE_MIPSFPU" => ::std::option::Option::Some(Machine::MACHINE_MIPSFPU),
            "MACHINE_MIPSFPU16" => ::std::option::Option::Some(Machine::MACHINE_MIPSFPU16),
            "MACHINE_POWERPC" => ::std::option::Option::Some(Machine::MACHINE_POWERPC),
            "MACHINE_POWERPCFP" => ::std::option::Option::Some(Machine::MACHINE_POWERPCFP),
            "MACHINE_R4000" => ::std::option::Option::Some(Machine::MACHINE_R4000),
            "MACHINE_SH3" => ::std::option::Option::Some(Machine::MACHINE_SH3),
            "MACHINE_SH3DSP" => ::std::option::Option::Some(Machine::MACHINE_SH3DSP),
            "MACHINE_SH4" => ::std::option::Option::Some(Machine::MACHINE_SH4),
            "MACHINE_SH5" => ::std::option::Option::Some(Machine::MACHINE_SH5),
            "MACHINE_THUMB" => ::std::option::Option::Some(Machine::MACHINE_THUMB),
            "MACHINE_WCEMIPSV2" => ::std::option::Option::Some(Machine::MACHINE_WCEMIPSV2),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Machine] = &[
        Machine::MACHINE_UNKNOWN,
        Machine::MACHINE_AM33,
        Machine::MACHINE_AMD64,
        Machine::MACHINE_ARM,
        Machine::MACHINE_ARMNT,
        Machine::MACHINE_ARM64,
        Machine::MACHINE_EBC,
        Machine::MACHINE_I386,
        Machine::MACHINE_IA64,
        Machine::MACHINE_M32R,
        Machine::MACHINE_MIPS16,
        Machine::MACHINE_MIPSFPU,
        Machine::MACHINE_MIPSFPU16,
        Machine::MACHINE_POWERPC,
        Machine::MACHINE_POWERPCFP,
        Machine::MACHINE_R4000,
        Machine::MACHINE_SH3,
        Machine::MACHINE_SH3DSP,
        Machine::MACHINE_SH4,
        Machine::MACHINE_SH5,
        Machine::MACHINE_THUMB,
        Machine::MACHINE_WCEMIPSV2,
    ];
}

impl ::protobuf::EnumFull for Machine {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Machine").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            Machine::MACHINE_UNKNOWN => 0,
            Machine::MACHINE_AM33 => 1,
            Machine::MACHINE_AMD64 => 2,
            Machine::MACHINE_ARM => 3,
            Machine::MACHINE_ARMNT => 4,
            Machine::MACHINE_ARM64 => 5,
            Machine::MACHINE_EBC => 6,
            Machine::MACHINE_I386 => 7,
            Machine::MACHINE_IA64 => 8,
            Machine::MACHINE_M32R => 9,
            Machine::MACHINE_MIPS16 => 10,
            Machine::MACHINE_MIPSFPU => 11,
            Machine::MACHINE_MIPSFPU16 => 12,
            Machine::MACHINE_POWERPC => 13,
            Machine::MACHINE_POWERPCFP => 14,
            Machine::MACHINE_R4000 => 15,
            Machine::MACHINE_SH3 => 16,
            Machine::MACHINE_SH3DSP => 17,
            Machine::MACHINE_SH4 => 18,
            Machine::MACHINE_SH5 => 19,
            Machine::MACHINE_THUMB => 20,
            Machine::MACHINE_WCEMIPSV2 => 21,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Machine {
    fn default() -> Self {
        Machine::MACHINE_UNKNOWN
    }
}

impl Machine {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Machine>("Machine")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:pe.Subsystem)
pub enum Subsystem {
    // @@protoc_insertion_point(enum_value:pe.Subsystem.SUBSYSTEM_UNKNOWN)
    SUBSYSTEM_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:pe.Subsystem.SUBSYSTEM_NATIVE)
    SUBSYSTEM_NATIVE = 1,
    // @@protoc_insertion_point(enum_value:pe.Subsystem.SUBSYSTEM_WINDOWS_GUI)
    SUBSYSTEM_WINDOWS_GUI = 2,
    // @@protoc_insertion_point(enum_value:pe.Subsystem.SUBSYSTEM_WINDOWS_CUI)
    SUBSYSTEM_WINDOWS_CUI = 3,
    // @@protoc_insertion_point(enum_value:pe.Subsystem.SUBSYSTEM_OS2_CUI)
    SUBSYSTEM_OS2_CUI = 5,
    // @@protoc_insertion_point(enum_value:pe.Subsystem.SUBSYSTEM_POSIX_CUI)
    SUBSYSTEM_POSIX_CUI = 7,
    // @@protoc_insertion_point(enum_value:pe.Subsystem.SUBSYSTEM_NATIVE_WINDOWS)
    SUBSYSTEM_NATIVE_WINDOWS = 8,
    // @@protoc_insertion_point(enum_value:pe.Subsystem.SUBSYSTEM_WINDOWS_CE_GUI)
    SUBSYSTEM_WINDOWS_CE_GUI = 9,
    // @@protoc_insertion_point(enum_value:pe.Subsystem.SUBSYSTEM_EFI_APPLICATION)
    SUBSYSTEM_EFI_APPLICATION = 10,
    // @@protoc_insertion_point(enum_value:pe.Subsystem.SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER)
    SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER = 11,
    // @@protoc_insertion_point(enum_value:pe.Subsystem.SUBSYSTEM_EFI_RUNTIME_DRIVER)
    SUBSYSTEM_EFI_RUNTIME_DRIVER = 12,
    // @@protoc_insertion_point(enum_value:pe.Subsystem.SUBSYSTEM_EFI_ROM_IMAGE)
    SUBSYSTEM_EFI_ROM_IMAGE = 13,
    // @@protoc_insertion_point(enum_value:pe.Subsystem.SUBSYSTEM_XBOX)
    SUBSYSTEM_XBOX = 14,
    // @@protoc_insertion_point(enum_value:pe.Subsystem.SUBSYSTEM_WINDOWS_BOOT_APPLICATION)
    SUBSYSTEM_WINDOWS_BOOT_APPLICATION = 16,
}

impl ::protobuf::Enum for Subsystem {
    const NAME: &'static str = "Subsystem";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Subsystem> {
        match value {
            0 => ::std::option::Option::Some(Subsystem::SUBSYSTEM_UNKNOWN),
            1 => ::std::option::Option::Some(Subsystem::SUBSYSTEM_NATIVE),
            2 => ::std::option::Option::Some(Subsystem::SUBSYSTEM_WINDOWS_GUI),
            3 => ::std::option::Option::Some(Subsystem::SUBSYSTEM_WINDOWS_CUI),
            5 => ::std::option::Option::Some(Subsystem::SUBSYSTEM_OS2_CUI),
            7 => ::std::option::Option::Some(Subsystem::SUBSYSTEM_POSIX_CUI),
            8 => ::std::option::Option::Some(Subsystem::SUBSYSTEM_NATIVE_WINDOWS),
            9 => ::std::option::Option::Some(Subsystem::SUBSYSTEM_WINDOWS_CE_GUI),
            10 => ::std::option::Option::Some(Subsystem::SUBSYSTEM_EFI_APPLICATION),
            11 => ::std::option::Option::Some(Subsystem::SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER),
            12 => ::std::option::Option::Some(Subsystem::SUBSYSTEM_EFI_RUNTIME_DRIVER),
            13 => ::std::option::Option::Some(Subsystem::SUBSYSTEM_EFI_ROM_IMAGE),
            14 => ::std::option::Option::Some(Subsystem::SUBSYSTEM_XBOX),
            16 => ::std::option::Option::Some(Subsystem::SUBSYSTEM_WINDOWS_BOOT_APPLICATION),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Subsystem> {
        match str {
            "SUBSYSTEM_UNKNOWN" => ::std::option::Option::Some(Subsystem::SUBSYSTEM_UNKNOWN),
            "SUBSYSTEM_NATIVE" => ::std::option::Option::Some(Subsystem::SUBSYSTEM_NATIVE),
            "SUBSYSTEM_WINDOWS_GUI" => ::std::option::Option::Some(Subsystem::SUBSYSTEM_WINDOWS_GUI),
            "SUBSYSTEM_WINDOWS_CUI" => ::std::option::Option::Some(Subsystem::SUBSYSTEM_WINDOWS_CUI),
            "SUBSYSTEM_OS2_CUI" => ::std::option::Option::Some(Subsystem::SUBSYSTEM_OS2_CUI),
            "SUBSYSTEM_POSIX_CUI" => ::std::option::Option::Some(Subsystem::SUBSYSTEM_POSIX_CUI),
            "SUBSYSTEM_NATIVE_WINDOWS" => ::std::option::Option::Some(Subsystem::SUBSYSTEM_NATIVE_WINDOWS),
            "SUBSYSTEM_WINDOWS_CE_GUI" => ::std::option::Option::Some(Subsystem::SUBSYSTEM_WINDOWS_CE_GUI),
            "SUBSYSTEM_EFI_APPLICATION" => ::std::option::Option::Some(Subsystem::SUBSYSTEM_EFI_APPLICATION),
            "SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER" => ::std::option::Option::Some(Subsystem::SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER),
            "SUBSYSTEM_EFI_RUNTIME_DRIVER" => ::std::option::Option::Some(Subsystem::SUBSYSTEM_EFI_RUNTIME_DRIVER),
            "SUBSYSTEM_EFI_ROM_IMAGE" => ::std::option::Option::Some(Subsystem::SUBSYSTEM_EFI_ROM_IMAGE),
            "SUBSYSTEM_XBOX" => ::std::option::Option::Some(Subsystem::SUBSYSTEM_XBOX),
            "SUBSYSTEM_WINDOWS_BOOT_APPLICATION" => ::std::option::Option::Some(Subsystem::SUBSYSTEM_WINDOWS_BOOT_APPLICATION),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Subsystem] = &[
        Subsystem::SUBSYSTEM_UNKNOWN,
        Subsystem::SUBSYSTEM_NATIVE,
        Subsystem::SUBSYSTEM_WINDOWS_GUI,
        Subsystem::SUBSYSTEM_WINDOWS_CUI,
        Subsystem::SUBSYSTEM_OS2_CUI,
        Subsystem::SUBSYSTEM_POSIX_CUI,
        Subsystem::SUBSYSTEM_NATIVE_WINDOWS,
        Subsystem::SUBSYSTEM_WINDOWS_CE_GUI,
        Subsystem::SUBSYSTEM_EFI_APPLICATION,
        Subsystem::SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER,
        Subsystem::SUBSYSTEM_EFI_RUNTIME_DRIVER,
        Subsystem::SUBSYSTEM_EFI_ROM_IMAGE,
        Subsystem::SUBSYSTEM_XBOX,
        Subsystem::SUBSYSTEM_WINDOWS_BOOT_APPLICATION,
    ];
}

impl ::protobuf::EnumFull for Subsystem {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Subsystem").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            Subsystem::SUBSYSTEM_UNKNOWN => 0,
            Subsystem::SUBSYSTEM_NATIVE => 1,
            Subsystem::SUBSYSTEM_WINDOWS_GUI => 2,
            Subsystem::SUBSYSTEM_WINDOWS_CUI => 3,
            Subsystem::SUBSYSTEM_OS2_CUI => 4,
            Subsystem::SUBSYSTEM_POSIX_CUI => 5,
            Subsystem::SUBSYSTEM_NATIVE_WINDOWS => 6,
            Subsystem::SUBSYSTEM_WINDOWS_CE_GUI => 7,
            Subsystem::SUBSYSTEM_EFI_APPLICATION => 8,
            Subsystem::SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER => 9,
            Subsystem::SUBSYSTEM_EFI_RUNTIME_DRIVER => 10,
            Subsystem::SUBSYSTEM_EFI_ROM_IMAGE => 11,
            Subsystem::SUBSYSTEM_XBOX => 12,
            Subsystem::SUBSYSTEM_WINDOWS_BOOT_APPLICATION => 13,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Subsystem {
    fn default() -> Self {
        Subsystem::SUBSYSTEM_UNKNOWN
    }
}

impl Subsystem {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Subsystem>("Subsystem")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:pe.ImportFlags)
pub enum ImportFlags {
    // @@protoc_insertion_point(enum_value:pe.ImportFlags.IMPORT_STANDARD)
    IMPORT_STANDARD = 1,
    // @@protoc_insertion_point(enum_value:pe.ImportFlags.IMPORT_DELAYED)
    IMPORT_DELAYED = 2,
    // @@protoc_insertion_point(enum_value:pe.ImportFlags.IMPORT_ANY)
    IMPORT_ANY = 3,
}

impl ::protobuf::Enum for ImportFlags {
    const NAME: &'static str = "ImportFlags";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ImportFlags> {
        match value {
            1 => ::std::option::Option::Some(ImportFlags::IMPORT_STANDARD),
            2 => ::std::option::Option::Some(ImportFlags::IMPORT_DELAYED),
            3 => ::std::option::Option::Some(ImportFlags::IMPORT_ANY),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ImportFlags> {
        match str {
            "IMPORT_STANDARD" => ::std::option::Option::Some(ImportFlags::IMPORT_STANDARD),
            "IMPORT_DELAYED" => ::std::option::Option::Some(ImportFlags::IMPORT_DELAYED),
            "IMPORT_ANY" => ::std::option::Option::Some(ImportFlags::IMPORT_ANY),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ImportFlags] = &[
        ImportFlags::IMPORT_STANDARD,
        ImportFlags::IMPORT_DELAYED,
        ImportFlags::IMPORT_ANY,
    ];
}

impl ::protobuf::EnumFull for ImportFlags {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ImportFlags").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ImportFlags::IMPORT_STANDARD => 0,
            ImportFlags::IMPORT_DELAYED => 1,
            ImportFlags::IMPORT_ANY => 2,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ImportFlags {
    fn default() -> Self {
        ImportFlags::IMPORT_STANDARD
    }
}

impl ImportFlags {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ImportFlags>("ImportFlags")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:pe.Characteristics)
pub enum Characteristics {
    // @@protoc_insertion_point(enum_value:pe.Characteristics.RELOCS_STRIPPED)
    RELOCS_STRIPPED = 1,
    // @@protoc_insertion_point(enum_value:pe.Characteristics.EXECUTABLE_IMAGE)
    EXECUTABLE_IMAGE = 2,
    // @@protoc_insertion_point(enum_value:pe.Characteristics.LINE_NUMS_STRIPPED)
    LINE_NUMS_STRIPPED = 4,
    // @@protoc_insertion_point(enum_value:pe.Characteristics.LOCAL_SYMS_STRIPPED)
    LOCAL_SYMS_STRIPPED = 8,
    // @@protoc_insertion_point(enum_value:pe.Characteristics.AGGRESIVE_WS_TRIM)
    AGGRESIVE_WS_TRIM = 16,
    // @@protoc_insertion_point(enum_value:pe.Characteristics.LARGE_ADDRESS_AWARE)
    LARGE_ADDRESS_AWARE = 32,
    // @@protoc_insertion_point(enum_value:pe.Characteristics.BYTES_REVERSED_LO)
    BYTES_REVERSED_LO = 128,
    // @@protoc_insertion_point(enum_value:pe.Characteristics.MACHINE_32BIT)
    MACHINE_32BIT = 256,
    // @@protoc_insertion_point(enum_value:pe.Characteristics.DEBUG_STRIPPED)
    DEBUG_STRIPPED = 512,
    // @@protoc_insertion_point(enum_value:pe.Characteristics.REMOVABLE_RUN_FROM_SWAP)
    REMOVABLE_RUN_FROM_SWAP = 1024,
    // @@protoc_insertion_point(enum_value:pe.Characteristics.NET_RUN_FROM_SWAP)
    NET_RUN_FROM_SWAP = 2048,
    // @@protoc_insertion_point(enum_value:pe.Characteristics.SYSTEM)
    SYSTEM = 4096,
    // @@protoc_insertion_point(enum_value:pe.Characteristics.DLL)
    DLL = 8192,
    // @@protoc_insertion_point(enum_value:pe.Characteristics.UP_SYSTEM_ONLY)
    UP_SYSTEM_ONLY = 16384,
    // @@protoc_insertion_point(enum_value:pe.Characteristics.BYTES_REVERSED_HI)
    BYTES_REVERSED_HI = 32768,
}

impl ::protobuf::Enum for Characteristics {
    const NAME: &'static str = "Characteristics";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Characteristics> {
        match value {
            1 => ::std::option::Option::Some(Characteristics::RELOCS_STRIPPED),
            2 => ::std::option::Option::Some(Characteristics::EXECUTABLE_IMAGE),
            4 => ::std::option::Option::Some(Characteristics::LINE_NUMS_STRIPPED),
            8 => ::std::option::Option::Some(Characteristics::LOCAL_SYMS_STRIPPED),
            16 => ::std::option::Option::Some(Characteristics::AGGRESIVE_WS_TRIM),
            32 => ::std::option::Option::Some(Characteristics::LARGE_ADDRESS_AWARE),
            128 => ::std::option::Option::Some(Characteristics::BYTES_REVERSED_LO),
            256 => ::std::option::Option::Some(Characteristics::MACHINE_32BIT),
            512 => ::std::option::Option::Some(Characteristics::DEBUG_STRIPPED),
            1024 => ::std::option::Option::Some(Characteristics::REMOVABLE_RUN_FROM_SWAP),
            2048 => ::std::option::Option::Some(Characteristics::NET_RUN_FROM_SWAP),
            4096 => ::std::option::Option::Some(Characteristics::SYSTEM),
            8192 => ::std::option::Option::Some(Characteristics::DLL),
            16384 => ::std::option::Option::Some(Characteristics::UP_SYSTEM_ONLY),
            32768 => ::std::option::Option::Some(Characteristics::BYTES_REVERSED_HI),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Characteristics> {
        match str {
            "RELOCS_STRIPPED" => ::std::option::Option::Some(Characteristics::RELOCS_STRIPPED),
            "EXECUTABLE_IMAGE" => ::std::option::Option::Some(Characteristics::EXECUTABLE_IMAGE),
            "LINE_NUMS_STRIPPED" => ::std::option::Option::Some(Characteristics::LINE_NUMS_STRIPPED),
            "LOCAL_SYMS_STRIPPED" => ::std::option::Option::Some(Characteristics::LOCAL_SYMS_STRIPPED),
            "AGGRESIVE_WS_TRIM" => ::std::option::Option::Some(Characteristics::AGGRESIVE_WS_TRIM),
            "LARGE_ADDRESS_AWARE" => ::std::option::Option::Some(Characteristics::LARGE_ADDRESS_AWARE),
            "BYTES_REVERSED_LO" => ::std::option::Option::Some(Characteristics::BYTES_REVERSED_LO),
            "MACHINE_32BIT" => ::std::option::Option::Some(Characteristics::MACHINE_32BIT),
            "DEBUG_STRIPPED" => ::std::option::Option::Some(Characteristics::DEBUG_STRIPPED),
            "REMOVABLE_RUN_FROM_SWAP" => ::std::option::Option::Some(Characteristics::REMOVABLE_RUN_FROM_SWAP),
            "NET_RUN_FROM_SWAP" => ::std::option::Option::Some(Characteristics::NET_RUN_FROM_SWAP),
            "SYSTEM" => ::std::option::Option::Some(Characteristics::SYSTEM),
            "DLL" => ::std::option::Option::Some(Characteristics::DLL),
            "UP_SYSTEM_ONLY" => ::std::option::Option::Some(Characteristics::UP_SYSTEM_ONLY),
            "BYTES_REVERSED_HI" => ::std::option::Option::Some(Characteristics::BYTES_REVERSED_HI),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Characteristics] = &[
        Characteristics::RELOCS_STRIPPED,
        Characteristics::EXECUTABLE_IMAGE,
        Characteristics::LINE_NUMS_STRIPPED,
        Characteristics::LOCAL_SYMS_STRIPPED,
        Characteristics::AGGRESIVE_WS_TRIM,
        Characteristics::LARGE_ADDRESS_AWARE,
        Characteristics::BYTES_REVERSED_LO,
        Characteristics::MACHINE_32BIT,
        Characteristics::DEBUG_STRIPPED,
        Characteristics::REMOVABLE_RUN_FROM_SWAP,
        Characteristics::NET_RUN_FROM_SWAP,
        Characteristics::SYSTEM,
        Characteristics::DLL,
        Characteristics::UP_SYSTEM_ONLY,
        Characteristics::BYTES_REVERSED_HI,
    ];
}

impl ::protobuf::EnumFull for Characteristics {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Characteristics").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            Characteristics::RELOCS_STRIPPED => 0,
            Characteristics::EXECUTABLE_IMAGE => 1,
            Characteristics::LINE_NUMS_STRIPPED => 2,
            Characteristics::LOCAL_SYMS_STRIPPED => 3,
            Characteristics::AGGRESIVE_WS_TRIM => 4,
            Characteristics::LARGE_ADDRESS_AWARE => 5,
            Characteristics::BYTES_REVERSED_LO => 6,
            Characteristics::MACHINE_32BIT => 7,
            Characteristics::DEBUG_STRIPPED => 8,
            Characteristics::REMOVABLE_RUN_FROM_SWAP => 9,
            Characteristics::NET_RUN_FROM_SWAP => 10,
            Characteristics::SYSTEM => 11,
            Characteristics::DLL => 12,
            Characteristics::UP_SYSTEM_ONLY => 13,
            Characteristics::BYTES_REVERSED_HI => 14,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for Characteristics {
    fn default() -> Self {
        Characteristics::RELOCS_STRIPPED
    }
}

impl Characteristics {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Characteristics>("Characteristics")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:pe.OptionalMagic)
pub enum OptionalMagic {
    // @@protoc_insertion_point(enum_value:pe.OptionalMagic.IMAGE_NT_OPTIONAL_HDR32_MAGIC)
    IMAGE_NT_OPTIONAL_HDR32_MAGIC = 267,
    // @@protoc_insertion_point(enum_value:pe.OptionalMagic.IMAGE_NT_OPTIONAL_HDR64_MAGIC)
    IMAGE_NT_OPTIONAL_HDR64_MAGIC = 523,
    // @@protoc_insertion_point(enum_value:pe.OptionalMagic.IMAGE_ROM_OPTIONAL_HDR_MAGIC)
    IMAGE_ROM_OPTIONAL_HDR_MAGIC = 263,
}

impl ::protobuf::Enum for OptionalMagic {
    const NAME: &'static str = "OptionalMagic";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OptionalMagic> {
        match value {
            267 => ::std::option::Option::Some(OptionalMagic::IMAGE_NT_OPTIONAL_HDR32_MAGIC),
            523 => ::std::option::Option::Some(OptionalMagic::IMAGE_NT_OPTIONAL_HDR64_MAGIC),
            263 => ::std::option::Option::Some(OptionalMagic::IMAGE_ROM_OPTIONAL_HDR_MAGIC),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<OptionalMagic> {
        match str {
            "IMAGE_NT_OPTIONAL_HDR32_MAGIC" => ::std::option::Option::Some(OptionalMagic::IMAGE_NT_OPTIONAL_HDR32_MAGIC),
            "IMAGE_NT_OPTIONAL_HDR64_MAGIC" => ::std::option::Option::Some(OptionalMagic::IMAGE_NT_OPTIONAL_HDR64_MAGIC),
            "IMAGE_ROM_OPTIONAL_HDR_MAGIC" => ::std::option::Option::Some(OptionalMagic::IMAGE_ROM_OPTIONAL_HDR_MAGIC),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [OptionalMagic] = &[
        OptionalMagic::IMAGE_NT_OPTIONAL_HDR32_MAGIC,
        OptionalMagic::IMAGE_NT_OPTIONAL_HDR64_MAGIC,
        OptionalMagic::IMAGE_ROM_OPTIONAL_HDR_MAGIC,
    ];
}

impl ::protobuf::EnumFull for OptionalMagic {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("OptionalMagic").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            OptionalMagic::IMAGE_NT_OPTIONAL_HDR32_MAGIC => 0,
            OptionalMagic::IMAGE_NT_OPTIONAL_HDR64_MAGIC => 1,
            OptionalMagic::IMAGE_ROM_OPTIONAL_HDR_MAGIC => 2,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for OptionalMagic {
    fn default() -> Self {
        OptionalMagic::IMAGE_NT_OPTIONAL_HDR32_MAGIC
    }
}

impl OptionalMagic {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<OptionalMagic>("OptionalMagic")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:pe.DirectoryEntry)
pub enum DirectoryEntry {
    // @@protoc_insertion_point(enum_value:pe.DirectoryEntry.IMAGE_DIRECTORY_ENTRY_EXPORT)
    IMAGE_DIRECTORY_ENTRY_EXPORT = 0,
    // @@protoc_insertion_point(enum_value:pe.DirectoryEntry.IMAGE_DIRECTORY_ENTRY_IMPORT)
    IMAGE_DIRECTORY_ENTRY_IMPORT = 1,
    // @@protoc_insertion_point(enum_value:pe.DirectoryEntry.IMAGE_DIRECTORY_ENTRY_RESOURCE)
    IMAGE_DIRECTORY_ENTRY_RESOURCE = 2,
    // @@protoc_insertion_point(enum_value:pe.DirectoryEntry.IMAGE_DIRECTORY_ENTRY_EXCEPTION)
    IMAGE_DIRECTORY_ENTRY_EXCEPTION = 3,
    // @@protoc_insertion_point(enum_value:pe.DirectoryEntry.IMAGE_DIRECTORY_ENTRY_SECURITY)
    IMAGE_DIRECTORY_ENTRY_SECURITY = 4,
    // @@protoc_insertion_point(enum_value:pe.DirectoryEntry.IMAGE_DIRECTORY_ENTRY_BASERELOC)
    IMAGE_DIRECTORY_ENTRY_BASERELOC = 5,
    // @@protoc_insertion_point(enum_value:pe.DirectoryEntry.IMAGE_DIRECTORY_ENTRY_DEBUG)
    IMAGE_DIRECTORY_ENTRY_DEBUG = 6,
    // @@protoc_insertion_point(enum_value:pe.DirectoryEntry.IMAGE_DIRECTORY_ENTRY_COPYRIGHT)
    IMAGE_DIRECTORY_ENTRY_COPYRIGHT = 7,
    // @@protoc_insertion_point(enum_value:pe.DirectoryEntry.IMAGE_DIRECTORY_ENTRY_ARCHITECTURE)
    IMAGE_DIRECTORY_ENTRY_ARCHITECTURE = 8,
    // @@protoc_insertion_point(enum_value:pe.DirectoryEntry.IMAGE_DIRECTORY_ENTRY_GLOBALPTR)
    IMAGE_DIRECTORY_ENTRY_GLOBALPTR = 9,
    // @@protoc_insertion_point(enum_value:pe.DirectoryEntry.IMAGE_DIRECTORY_ENTRY_TLS)
    IMAGE_DIRECTORY_ENTRY_TLS = 10,
    // @@protoc_insertion_point(enum_value:pe.DirectoryEntry.IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG)
    IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG = 11,
    // @@protoc_insertion_point(enum_value:pe.DirectoryEntry.IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT)
    IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT = 12,
    // @@protoc_insertion_point(enum_value:pe.DirectoryEntry.IMAGE_DIRECTORY_ENTRY_IAT)
    IMAGE_DIRECTORY_ENTRY_IAT = 13,
    // @@protoc_insertion_point(enum_value:pe.DirectoryEntry.IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT)
    IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT = 14,
    // @@protoc_insertion_point(enum_value:pe.DirectoryEntry.IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR)
    IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR = 15,
}

impl ::protobuf::Enum for DirectoryEntry {
    const NAME: &'static str = "DirectoryEntry";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DirectoryEntry> {
        match value {
            0 => ::std::option::Option::Some(DirectoryEntry::IMAGE_DIRECTORY_ENTRY_EXPORT),
            1 => ::std::option::Option::Some(DirectoryEntry::IMAGE_DIRECTORY_ENTRY_IMPORT),
            2 => ::std::option::Option::Some(DirectoryEntry::IMAGE_DIRECTORY_ENTRY_RESOURCE),
            3 => ::std::option::Option::Some(DirectoryEntry::IMAGE_DIRECTORY_ENTRY_EXCEPTION),
            4 => ::std::option::Option::Some(DirectoryEntry::IMAGE_DIRECTORY_ENTRY_SECURITY),
            5 => ::std::option::Option::Some(DirectoryEntry::IMAGE_DIRECTORY_ENTRY_BASERELOC),
            6 => ::std::option::Option::Some(DirectoryEntry::IMAGE_DIRECTORY_ENTRY_DEBUG),
            7 => ::std::option::Option::Some(DirectoryEntry::IMAGE_DIRECTORY_ENTRY_COPYRIGHT),
            8 => ::std::option::Option::Some(DirectoryEntry::IMAGE_DIRECTORY_ENTRY_ARCHITECTURE),
            9 => ::std::option::Option::Some(DirectoryEntry::IMAGE_DIRECTORY_ENTRY_GLOBALPTR),
            10 => ::std::option::Option::Some(DirectoryEntry::IMAGE_DIRECTORY_ENTRY_TLS),
            11 => ::std::option::Option::Some(DirectoryEntry::IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG),
            12 => ::std::option::Option::Some(DirectoryEntry::IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT),
            13 => ::std::option::Option::Some(DirectoryEntry::IMAGE_DIRECTORY_ENTRY_IAT),
            14 => ::std::option::Option::Some(DirectoryEntry::IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT),
            15 => ::std::option::Option::Some(DirectoryEntry::IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DirectoryEntry> {
        match str {
            "IMAGE_DIRECTORY_ENTRY_EXPORT" => ::std::option::Option::Some(DirectoryEntry::IMAGE_DIRECTORY_ENTRY_EXPORT),
            "IMAGE_DIRECTORY_ENTRY_IMPORT" => ::std::option::Option::Some(DirectoryEntry::IMAGE_DIRECTORY_ENTRY_IMPORT),
            "IMAGE_DIRECTORY_ENTRY_RESOURCE" => ::std::option::Option::Some(DirectoryEntry::IMAGE_DIRECTORY_ENTRY_RESOURCE),
            "IMAGE_DIRECTORY_ENTRY_EXCEPTION" => ::std::option::Option::Some(DirectoryEntry::IMAGE_DIRECTORY_ENTRY_EXCEPTION),
            "IMAGE_DIRECTORY_ENTRY_SECURITY" => ::std::option::Option::Some(DirectoryEntry::IMAGE_DIRECTORY_ENTRY_SECURITY),
            "IMAGE_DIRECTORY_ENTRY_BASERELOC" => ::std::option::Option::Some(DirectoryEntry::IMAGE_DIRECTORY_ENTRY_BASERELOC),
            "IMAGE_DIRECTORY_ENTRY_DEBUG" => ::std::option::Option::Some(DirectoryEntry::IMAGE_DIRECTORY_ENTRY_DEBUG),
            "IMAGE_DIRECTORY_ENTRY_COPYRIGHT" => ::std::option::Option::Some(DirectoryEntry::IMAGE_DIRECTORY_ENTRY_COPYRIGHT),
            "IMAGE_DIRECTORY_ENTRY_ARCHITECTURE" => ::std::option::Option::Some(DirectoryEntry::IMAGE_DIRECTORY_ENTRY_ARCHITECTURE),
            "IMAGE_DIRECTORY_ENTRY_GLOBALPTR" => ::std::option::Option::Some(DirectoryEntry::IMAGE_DIRECTORY_ENTRY_GLOBALPTR),
            "IMAGE_DIRECTORY_ENTRY_TLS" => ::std::option::Option::Some(DirectoryEntry::IMAGE_DIRECTORY_ENTRY_TLS),
            "IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG" => ::std::option::Option::Some(DirectoryEntry::IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG),
            "IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT" => ::std::option::Option::Some(DirectoryEntry::IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT),
            "IMAGE_DIRECTORY_ENTRY_IAT" => ::std::option::Option::Some(DirectoryEntry::IMAGE_DIRECTORY_ENTRY_IAT),
            "IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT" => ::std::option::Option::Some(DirectoryEntry::IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT),
            "IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR" => ::std::option::Option::Some(DirectoryEntry::IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DirectoryEntry] = &[
        DirectoryEntry::IMAGE_DIRECTORY_ENTRY_EXPORT,
        DirectoryEntry::IMAGE_DIRECTORY_ENTRY_IMPORT,
        DirectoryEntry::IMAGE_DIRECTORY_ENTRY_RESOURCE,
        DirectoryEntry::IMAGE_DIRECTORY_ENTRY_EXCEPTION,
        DirectoryEntry::IMAGE_DIRECTORY_ENTRY_SECURITY,
        DirectoryEntry::IMAGE_DIRECTORY_ENTRY_BASERELOC,
        DirectoryEntry::IMAGE_DIRECTORY_ENTRY_DEBUG,
        DirectoryEntry::IMAGE_DIRECTORY_ENTRY_COPYRIGHT,
        DirectoryEntry::IMAGE_DIRECTORY_ENTRY_ARCHITECTURE,
        DirectoryEntry::IMAGE_DIRECTORY_ENTRY_GLOBALPTR,
        DirectoryEntry::IMAGE_DIRECTORY_ENTRY_TLS,
        DirectoryEntry::IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG,
        DirectoryEntry::IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT,
        DirectoryEntry::IMAGE_DIRECTORY_ENTRY_IAT,
        DirectoryEntry::IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT,
        DirectoryEntry::IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR,
    ];
}

impl ::protobuf::EnumFull for DirectoryEntry {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DirectoryEntry").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DirectoryEntry {
    fn default() -> Self {
        DirectoryEntry::IMAGE_DIRECTORY_ENTRY_EXPORT
    }
}

impl DirectoryEntry {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DirectoryEntry>("DirectoryEntry")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:pe.SectionCharacteristics)
pub enum SectionCharacteristics {
    // @@protoc_insertion_point(enum_value:pe.SectionCharacteristics.SECTION_NO_PAD)
    SECTION_NO_PAD = 1,
    // @@protoc_insertion_point(enum_value:pe.SectionCharacteristics.SECTION_CNT_CODE)
    SECTION_CNT_CODE = 2,
    // @@protoc_insertion_point(enum_value:pe.SectionCharacteristics.SECTION_CNT_INITIALIZED_DATA)
    SECTION_CNT_INITIALIZED_DATA = 3,
    // @@protoc_insertion_point(enum_value:pe.SectionCharacteristics.SECTION_CNT_UNINITIALIZED_DATA)
    SECTION_CNT_UNINITIALIZED_DATA = 4,
    // @@protoc_insertion_point(enum_value:pe.SectionCharacteristics.SECTION_LNK_OTHER)
    SECTION_LNK_OTHER = 5,
    // @@protoc_insertion_point(enum_value:pe.SectionCharacteristics.SECTION_LNK_INFO)
    SECTION_LNK_INFO = 6,
    // @@protoc_insertion_point(enum_value:pe.SectionCharacteristics.SECTION_LNK_REMOVE)
    SECTION_LNK_REMOVE = 7,
    // @@protoc_insertion_point(enum_value:pe.SectionCharacteristics.SECTION_LNK_COMDAT)
    SECTION_LNK_COMDAT = 8,
    // @@protoc_insertion_point(enum_value:pe.SectionCharacteristics.SECTION_NO_DEFER_SPEC_EXC)
    SECTION_NO_DEFER_SPEC_EXC = 9,
    // @@protoc_insertion_point(enum_value:pe.SectionCharacteristics.SECTION_GPREL)
    SECTION_GPREL = 10,
    // @@protoc_insertion_point(enum_value:pe.SectionCharacteristics.SECTION_ALIGN_1BYTES)
    SECTION_ALIGN_1BYTES = 11,
    // @@protoc_insertion_point(enum_value:pe.SectionCharacteristics.SECTION_ALIGN_2BYTES)
    SECTION_ALIGN_2BYTES = 12,
    // @@protoc_insertion_point(enum_value:pe.SectionCharacteristics.SECTION_ALIGN_4BYTES)
    SECTION_ALIGN_4BYTES = 13,
    // @@protoc_insertion_point(enum_value:pe.SectionCharacteristics.SECTION_ALIGN_8BYTES)
    SECTION_ALIGN_8BYTES = 14,
    // @@protoc_insertion_point(enum_value:pe.SectionCharacteristics.SECTION_ALIGN_16BYTES)
    SECTION_ALIGN_16BYTES = 15,
    // @@protoc_insertion_point(enum_value:pe.SectionCharacteristics.SECTION_ALIGN_32BYTES)
    SECTION_ALIGN_32BYTES = 16,
    // @@protoc_insertion_point(enum_value:pe.SectionCharacteristics.SECTION_ALIGN_64BYTES)
    SECTION_ALIGN_64BYTES = 17,
    // @@protoc_insertion_point(enum_value:pe.SectionCharacteristics.SECTION_ALIGN_128BYTES)
    SECTION_ALIGN_128BYTES = 18,
    // @@protoc_insertion_point(enum_value:pe.SectionCharacteristics.SECTION_ALIGN_256BYTES)
    SECTION_ALIGN_256BYTES = 19,
    // @@protoc_insertion_point(enum_value:pe.SectionCharacteristics.SECTION_ALIGN_512BYTES)
    SECTION_ALIGN_512BYTES = 20,
    // @@protoc_insertion_point(enum_value:pe.SectionCharacteristics.SECTION_ALIGN_1024BYTES)
    SECTION_ALIGN_1024BYTES = 21,
    // @@protoc_insertion_point(enum_value:pe.SectionCharacteristics.SECTION_ALIGN_2048BYTES)
    SECTION_ALIGN_2048BYTES = 22,
    // @@protoc_insertion_point(enum_value:pe.SectionCharacteristics.SECTION_ALIGN_4096BYTES)
    SECTION_ALIGN_4096BYTES = 23,
    // @@protoc_insertion_point(enum_value:pe.SectionCharacteristics.SECTION_ALIGN_8192BYTES)
    SECTION_ALIGN_8192BYTES = 24,
    // @@protoc_insertion_point(enum_value:pe.SectionCharacteristics.SECTION_ALIGN_MASK)
    SECTION_ALIGN_MASK = 25,
    // @@protoc_insertion_point(enum_value:pe.SectionCharacteristics.SECTION_LNK_NRELOC_OVFL)
    SECTION_LNK_NRELOC_OVFL = 26,
    // @@protoc_insertion_point(enum_value:pe.SectionCharacteristics.SECTION_MEM_DISCARDABLE)
    SECTION_MEM_DISCARDABLE = 27,
    // @@protoc_insertion_point(enum_value:pe.SectionCharacteristics.SECTION_MEM_NOT_CACHED)
    SECTION_MEM_NOT_CACHED = 28,
    // @@protoc_insertion_point(enum_value:pe.SectionCharacteristics.SECTION_MEM_NOT_PAGED)
    SECTION_MEM_NOT_PAGED = 29,
    // @@protoc_insertion_point(enum_value:pe.SectionCharacteristics.SECTION_MEM_SHARED)
    SECTION_MEM_SHARED = 30,
    // @@protoc_insertion_point(enum_value:pe.SectionCharacteristics.SECTION_MEM_EXECUTE)
    SECTION_MEM_EXECUTE = 31,
    // @@protoc_insertion_point(enum_value:pe.SectionCharacteristics.SECTION_MEM_READ)
    SECTION_MEM_READ = 32,
    // @@protoc_insertion_point(enum_value:pe.SectionCharacteristics.SECTION_MEM_WRITE)
    SECTION_MEM_WRITE = 33,
    // @@protoc_insertion_point(enum_value:pe.SectionCharacteristics.SECTION_SCALE_INDEX)
    SECTION_SCALE_INDEX = 34,
}

impl ::protobuf::Enum for SectionCharacteristics {
    const NAME: &'static str = "SectionCharacteristics";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SectionCharacteristics> {
        match value {
            1 => ::std::option::Option::Some(SectionCharacteristics::SECTION_NO_PAD),
            2 => ::std::option::Option::Some(SectionCharacteristics::SECTION_CNT_CODE),
            3 => ::std::option::Option::Some(SectionCharacteristics::SECTION_CNT_INITIALIZED_DATA),
            4 => ::std::option::Option::Some(SectionCharacteristics::SECTION_CNT_UNINITIALIZED_DATA),
            5 => ::std::option::Option::Some(SectionCharacteristics::SECTION_LNK_OTHER),
            6 => ::std::option::Option::Some(SectionCharacteristics::SECTION_LNK_INFO),
            7 => ::std::option::Option::Some(SectionCharacteristics::SECTION_LNK_REMOVE),
            8 => ::std::option::Option::Some(SectionCharacteristics::SECTION_LNK_COMDAT),
            9 => ::std::option::Option::Some(SectionCharacteristics::SECTION_NO_DEFER_SPEC_EXC),
            10 => ::std::option::Option::Some(SectionCharacteristics::SECTION_GPREL),
            11 => ::std::option::Option::Some(SectionCharacteristics::SECTION_ALIGN_1BYTES),
            12 => ::std::option::Option::Some(SectionCharacteristics::SECTION_ALIGN_2BYTES),
            13 => ::std::option::Option::Some(SectionCharacteristics::SECTION_ALIGN_4BYTES),
            14 => ::std::option::Option::Some(SectionCharacteristics::SECTION_ALIGN_8BYTES),
            15 => ::std::option::Option::Some(SectionCharacteristics::SECTION_ALIGN_16BYTES),
            16 => ::std::option::Option::Some(SectionCharacteristics::SECTION_ALIGN_32BYTES),
            17 => ::std::option::Option::Some(SectionCharacteristics::SECTION_ALIGN_64BYTES),
            18 => ::std::option::Option::Some(SectionCharacteristics::SECTION_ALIGN_128BYTES),
            19 => ::std::option::Option::Some(SectionCharacteristics::SECTION_ALIGN_256BYTES),
            20 => ::std::option::Option::Some(SectionCharacteristics::SECTION_ALIGN_512BYTES),
            21 => ::std::option::Option::Some(SectionCharacteristics::SECTION_ALIGN_1024BYTES),
            22 => ::std::option::Option::Some(SectionCharacteristics::SECTION_ALIGN_2048BYTES),
            23 => ::std::option::Option::Some(SectionCharacteristics::SECTION_ALIGN_4096BYTES),
            24 => ::std::option::Option::Some(SectionCharacteristics::SECTION_ALIGN_8192BYTES),
            25 => ::std::option::Option::Some(SectionCharacteristics::SECTION_ALIGN_MASK),
            26 => ::std::option::Option::Some(SectionCharacteristics::SECTION_LNK_NRELOC_OVFL),
            27 => ::std::option::Option::Some(SectionCharacteristics::SECTION_MEM_DISCARDABLE),
            28 => ::std::option::Option::Some(SectionCharacteristics::SECTION_MEM_NOT_CACHED),
            29 => ::std::option::Option::Some(SectionCharacteristics::SECTION_MEM_NOT_PAGED),
            30 => ::std::option::Option::Some(SectionCharacteristics::SECTION_MEM_SHARED),
            31 => ::std::option::Option::Some(SectionCharacteristics::SECTION_MEM_EXECUTE),
            32 => ::std::option::Option::Some(SectionCharacteristics::SECTION_MEM_READ),
            33 => ::std::option::Option::Some(SectionCharacteristics::SECTION_MEM_WRITE),
            34 => ::std::option::Option::Some(SectionCharacteristics::SECTION_SCALE_INDEX),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SectionCharacteristics> {
        match str {
            "SECTION_NO_PAD" => ::std::option::Option::Some(SectionCharacteristics::SECTION_NO_PAD),
            "SECTION_CNT_CODE" => ::std::option::Option::Some(SectionCharacteristics::SECTION_CNT_CODE),
            "SECTION_CNT_INITIALIZED_DATA" => ::std::option::Option::Some(SectionCharacteristics::SECTION_CNT_INITIALIZED_DATA),
            "SECTION_CNT_UNINITIALIZED_DATA" => ::std::option::Option::Some(SectionCharacteristics::SECTION_CNT_UNINITIALIZED_DATA),
            "SECTION_LNK_OTHER" => ::std::option::Option::Some(SectionCharacteristics::SECTION_LNK_OTHER),
            "SECTION_LNK_INFO" => ::std::option::Option::Some(SectionCharacteristics::SECTION_LNK_INFO),
            "SECTION_LNK_REMOVE" => ::std::option::Option::Some(SectionCharacteristics::SECTION_LNK_REMOVE),
            "SECTION_LNK_COMDAT" => ::std::option::Option::Some(SectionCharacteristics::SECTION_LNK_COMDAT),
            "SECTION_NO_DEFER_SPEC_EXC" => ::std::option::Option::Some(SectionCharacteristics::SECTION_NO_DEFER_SPEC_EXC),
            "SECTION_GPREL" => ::std::option::Option::Some(SectionCharacteristics::SECTION_GPREL),
            "SECTION_ALIGN_1BYTES" => ::std::option::Option::Some(SectionCharacteristics::SECTION_ALIGN_1BYTES),
            "SECTION_ALIGN_2BYTES" => ::std::option::Option::Some(SectionCharacteristics::SECTION_ALIGN_2BYTES),
            "SECTION_ALIGN_4BYTES" => ::std::option::Option::Some(SectionCharacteristics::SECTION_ALIGN_4BYTES),
            "SECTION_ALIGN_8BYTES" => ::std::option::Option::Some(SectionCharacteristics::SECTION_ALIGN_8BYTES),
            "SECTION_ALIGN_16BYTES" => ::std::option::Option::Some(SectionCharacteristics::SECTION_ALIGN_16BYTES),
            "SECTION_ALIGN_32BYTES" => ::std::option::Option::Some(SectionCharacteristics::SECTION_ALIGN_32BYTES),
            "SECTION_ALIGN_64BYTES" => ::std::option::Option::Some(SectionCharacteristics::SECTION_ALIGN_64BYTES),
            "SECTION_ALIGN_128BYTES" => ::std::option::Option::Some(SectionCharacteristics::SECTION_ALIGN_128BYTES),
            "SECTION_ALIGN_256BYTES" => ::std::option::Option::Some(SectionCharacteristics::SECTION_ALIGN_256BYTES),
            "SECTION_ALIGN_512BYTES" => ::std::option::Option::Some(SectionCharacteristics::SECTION_ALIGN_512BYTES),
            "SECTION_ALIGN_1024BYTES" => ::std::option::Option::Some(SectionCharacteristics::SECTION_ALIGN_1024BYTES),
            "SECTION_ALIGN_2048BYTES" => ::std::option::Option::Some(SectionCharacteristics::SECTION_ALIGN_2048BYTES),
            "SECTION_ALIGN_4096BYTES" => ::std::option::Option::Some(SectionCharacteristics::SECTION_ALIGN_4096BYTES),
            "SECTION_ALIGN_8192BYTES" => ::std::option::Option::Some(SectionCharacteristics::SECTION_ALIGN_8192BYTES),
            "SECTION_ALIGN_MASK" => ::std::option::Option::Some(SectionCharacteristics::SECTION_ALIGN_MASK),
            "SECTION_LNK_NRELOC_OVFL" => ::std::option::Option::Some(SectionCharacteristics::SECTION_LNK_NRELOC_OVFL),
            "SECTION_MEM_DISCARDABLE" => ::std::option::Option::Some(SectionCharacteristics::SECTION_MEM_DISCARDABLE),
            "SECTION_MEM_NOT_CACHED" => ::std::option::Option::Some(SectionCharacteristics::SECTION_MEM_NOT_CACHED),
            "SECTION_MEM_NOT_PAGED" => ::std::option::Option::Some(SectionCharacteristics::SECTION_MEM_NOT_PAGED),
            "SECTION_MEM_SHARED" => ::std::option::Option::Some(SectionCharacteristics::SECTION_MEM_SHARED),
            "SECTION_MEM_EXECUTE" => ::std::option::Option::Some(SectionCharacteristics::SECTION_MEM_EXECUTE),
            "SECTION_MEM_READ" => ::std::option::Option::Some(SectionCharacteristics::SECTION_MEM_READ),
            "SECTION_MEM_WRITE" => ::std::option::Option::Some(SectionCharacteristics::SECTION_MEM_WRITE),
            "SECTION_SCALE_INDEX" => ::std::option::Option::Some(SectionCharacteristics::SECTION_SCALE_INDEX),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SectionCharacteristics] = &[
        SectionCharacteristics::SECTION_NO_PAD,
        SectionCharacteristics::SECTION_CNT_CODE,
        SectionCharacteristics::SECTION_CNT_INITIALIZED_DATA,
        SectionCharacteristics::SECTION_CNT_UNINITIALIZED_DATA,
        SectionCharacteristics::SECTION_LNK_OTHER,
        SectionCharacteristics::SECTION_LNK_INFO,
        SectionCharacteristics::SECTION_LNK_REMOVE,
        SectionCharacteristics::SECTION_LNK_COMDAT,
        SectionCharacteristics::SECTION_NO_DEFER_SPEC_EXC,
        SectionCharacteristics::SECTION_GPREL,
        SectionCharacteristics::SECTION_ALIGN_1BYTES,
        SectionCharacteristics::SECTION_ALIGN_2BYTES,
        SectionCharacteristics::SECTION_ALIGN_4BYTES,
        SectionCharacteristics::SECTION_ALIGN_8BYTES,
        SectionCharacteristics::SECTION_ALIGN_16BYTES,
        SectionCharacteristics::SECTION_ALIGN_32BYTES,
        SectionCharacteristics::SECTION_ALIGN_64BYTES,
        SectionCharacteristics::SECTION_ALIGN_128BYTES,
        SectionCharacteristics::SECTION_ALIGN_256BYTES,
        SectionCharacteristics::SECTION_ALIGN_512BYTES,
        SectionCharacteristics::SECTION_ALIGN_1024BYTES,
        SectionCharacteristics::SECTION_ALIGN_2048BYTES,
        SectionCharacteristics::SECTION_ALIGN_4096BYTES,
        SectionCharacteristics::SECTION_ALIGN_8192BYTES,
        SectionCharacteristics::SECTION_ALIGN_MASK,
        SectionCharacteristics::SECTION_LNK_NRELOC_OVFL,
        SectionCharacteristics::SECTION_MEM_DISCARDABLE,
        SectionCharacteristics::SECTION_MEM_NOT_CACHED,
        SectionCharacteristics::SECTION_MEM_NOT_PAGED,
        SectionCharacteristics::SECTION_MEM_SHARED,
        SectionCharacteristics::SECTION_MEM_EXECUTE,
        SectionCharacteristics::SECTION_MEM_READ,
        SectionCharacteristics::SECTION_MEM_WRITE,
        SectionCharacteristics::SECTION_SCALE_INDEX,
    ];
}

impl ::protobuf::EnumFull for SectionCharacteristics {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SectionCharacteristics").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            SectionCharacteristics::SECTION_NO_PAD => 0,
            SectionCharacteristics::SECTION_CNT_CODE => 1,
            SectionCharacteristics::SECTION_CNT_INITIALIZED_DATA => 2,
            SectionCharacteristics::SECTION_CNT_UNINITIALIZED_DATA => 3,
            SectionCharacteristics::SECTION_LNK_OTHER => 4,
            SectionCharacteristics::SECTION_LNK_INFO => 5,
            SectionCharacteristics::SECTION_LNK_REMOVE => 6,
            SectionCharacteristics::SECTION_LNK_COMDAT => 7,
            SectionCharacteristics::SECTION_NO_DEFER_SPEC_EXC => 8,
            SectionCharacteristics::SECTION_GPREL => 9,
            SectionCharacteristics::SECTION_ALIGN_1BYTES => 10,
            SectionCharacteristics::SECTION_ALIGN_2BYTES => 11,
            SectionCharacteristics::SECTION_ALIGN_4BYTES => 12,
            SectionCharacteristics::SECTION_ALIGN_8BYTES => 13,
            SectionCharacteristics::SECTION_ALIGN_16BYTES => 14,
            SectionCharacteristics::SECTION_ALIGN_32BYTES => 15,
            SectionCharacteristics::SECTION_ALIGN_64BYTES => 16,
            SectionCharacteristics::SECTION_ALIGN_128BYTES => 17,
            SectionCharacteristics::SECTION_ALIGN_256BYTES => 18,
            SectionCharacteristics::SECTION_ALIGN_512BYTES => 19,
            SectionCharacteristics::SECTION_ALIGN_1024BYTES => 20,
            SectionCharacteristics::SECTION_ALIGN_2048BYTES => 21,
            SectionCharacteristics::SECTION_ALIGN_4096BYTES => 22,
            SectionCharacteristics::SECTION_ALIGN_8192BYTES => 23,
            SectionCharacteristics::SECTION_ALIGN_MASK => 24,
            SectionCharacteristics::SECTION_LNK_NRELOC_OVFL => 25,
            SectionCharacteristics::SECTION_MEM_DISCARDABLE => 26,
            SectionCharacteristics::SECTION_MEM_NOT_CACHED => 27,
            SectionCharacteristics::SECTION_MEM_NOT_PAGED => 28,
            SectionCharacteristics::SECTION_MEM_SHARED => 29,
            SectionCharacteristics::SECTION_MEM_EXECUTE => 30,
            SectionCharacteristics::SECTION_MEM_READ => 31,
            SectionCharacteristics::SECTION_MEM_WRITE => 32,
            SectionCharacteristics::SECTION_SCALE_INDEX => 33,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for SectionCharacteristics {
    fn default() -> Self {
        SectionCharacteristics::SECTION_NO_PAD
    }
}

impl SectionCharacteristics {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SectionCharacteristics>("SectionCharacteristics")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:pe.DllCharacteristics)
pub enum DllCharacteristics {
    // @@protoc_insertion_point(enum_value:pe.DllCharacteristics.HIGH_ENTROPY_VA)
    HIGH_ENTROPY_VA = 32,
    // @@protoc_insertion_point(enum_value:pe.DllCharacteristics.DYNAMIC_BASE)
    DYNAMIC_BASE = 64,
    // @@protoc_insertion_point(enum_value:pe.DllCharacteristics.FORCE_INTEGRITY)
    FORCE_INTEGRITY = 128,
    // @@protoc_insertion_point(enum_value:pe.DllCharacteristics.NX_COMPAT)
    NX_COMPAT = 256,
    // @@protoc_insertion_point(enum_value:pe.DllCharacteristics.NO_ISOLATION)
    NO_ISOLATION = 512,
    // @@protoc_insertion_point(enum_value:pe.DllCharacteristics.NO_SEH)
    NO_SEH = 1024,
    // @@protoc_insertion_point(enum_value:pe.DllCharacteristics.NO_BIND)
    NO_BIND = 2048,
    // @@protoc_insertion_point(enum_value:pe.DllCharacteristics.APPCONTAINER)
    APPCONTAINER = 4096,
    // @@protoc_insertion_point(enum_value:pe.DllCharacteristics.WDM_DRIVER)
    WDM_DRIVER = 8192,
    // @@protoc_insertion_point(enum_value:pe.DllCharacteristics.GUARD_CF)
    GUARD_CF = 16384,
    // @@protoc_insertion_point(enum_value:pe.DllCharacteristics.TERMINAL_SERVER_AWARE)
    TERMINAL_SERVER_AWARE = 32768,
}

impl ::protobuf::Enum for DllCharacteristics {
    const NAME: &'static str = "DllCharacteristics";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DllCharacteristics> {
        match value {
            32 => ::std::option::Option::Some(DllCharacteristics::HIGH_ENTROPY_VA),
            64 => ::std::option::Option::Some(DllCharacteristics::DYNAMIC_BASE),
            128 => ::std::option::Option::Some(DllCharacteristics::FORCE_INTEGRITY),
            256 => ::std::option::Option::Some(DllCharacteristics::NX_COMPAT),
            512 => ::std::option::Option::Some(DllCharacteristics::NO_ISOLATION),
            1024 => ::std::option::Option::Some(DllCharacteristics::NO_SEH),
            2048 => ::std::option::Option::Some(DllCharacteristics::NO_BIND),
            4096 => ::std::option::Option::Some(DllCharacteristics::APPCONTAINER),
            8192 => ::std::option::Option::Some(DllCharacteristics::WDM_DRIVER),
            16384 => ::std::option::Option::Some(DllCharacteristics::GUARD_CF),
            32768 => ::std::option::Option::Some(DllCharacteristics::TERMINAL_SERVER_AWARE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DllCharacteristics> {
        match str {
            "HIGH_ENTROPY_VA" => ::std::option::Option::Some(DllCharacteristics::HIGH_ENTROPY_VA),
            "DYNAMIC_BASE" => ::std::option::Option::Some(DllCharacteristics::DYNAMIC_BASE),
            "FORCE_INTEGRITY" => ::std::option::Option::Some(DllCharacteristics::FORCE_INTEGRITY),
            "NX_COMPAT" => ::std::option::Option::Some(DllCharacteristics::NX_COMPAT),
            "NO_ISOLATION" => ::std::option::Option::Some(DllCharacteristics::NO_ISOLATION),
            "NO_SEH" => ::std::option::Option::Some(DllCharacteristics::NO_SEH),
            "NO_BIND" => ::std::option::Option::Some(DllCharacteristics::NO_BIND),
            "APPCONTAINER" => ::std::option::Option::Some(DllCharacteristics::APPCONTAINER),
            "WDM_DRIVER" => ::std::option::Option::Some(DllCharacteristics::WDM_DRIVER),
            "GUARD_CF" => ::std::option::Option::Some(DllCharacteristics::GUARD_CF),
            "TERMINAL_SERVER_AWARE" => ::std::option::Option::Some(DllCharacteristics::TERMINAL_SERVER_AWARE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DllCharacteristics] = &[
        DllCharacteristics::HIGH_ENTROPY_VA,
        DllCharacteristics::DYNAMIC_BASE,
        DllCharacteristics::FORCE_INTEGRITY,
        DllCharacteristics::NX_COMPAT,
        DllCharacteristics::NO_ISOLATION,
        DllCharacteristics::NO_SEH,
        DllCharacteristics::NO_BIND,
        DllCharacteristics::APPCONTAINER,
        DllCharacteristics::WDM_DRIVER,
        DllCharacteristics::GUARD_CF,
        DllCharacteristics::TERMINAL_SERVER_AWARE,
    ];
}

impl ::protobuf::EnumFull for DllCharacteristics {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DllCharacteristics").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            DllCharacteristics::HIGH_ENTROPY_VA => 0,
            DllCharacteristics::DYNAMIC_BASE => 1,
            DllCharacteristics::FORCE_INTEGRITY => 2,
            DllCharacteristics::NX_COMPAT => 3,
            DllCharacteristics::NO_ISOLATION => 4,
            DllCharacteristics::NO_SEH => 5,
            DllCharacteristics::NO_BIND => 6,
            DllCharacteristics::APPCONTAINER => 7,
            DllCharacteristics::WDM_DRIVER => 8,
            DllCharacteristics::GUARD_CF => 9,
            DllCharacteristics::TERMINAL_SERVER_AWARE => 10,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for DllCharacteristics {
    fn default() -> Self {
        DllCharacteristics::HIGH_ENTROPY_VA
    }
}

impl DllCharacteristics {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DllCharacteristics>("DllCharacteristics")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x08pe.proto\x12\x02pe\x1a\nyara.proto\"\x9f\x1a\n\x02PE\x12\x13\n\x05\
    is_pe\x18\x01\x20\x02(\x08R\x04isPe\x12%\n\x07machine\x18\x02\x20\x01(\
    \x0e2\x0b.pe.MachineR\x07machine\x12+\n\tsubsystem\x18\x03\x20\x01(\x0e2\
    \r.pe.SubsystemR\tsubsystem\x12*\n\nos_version\x18\x04\x20\x01(\x0b2\x0b\
    .pe.VersionR\tosVersion\x128\n\x11subsystem_version\x18\x05\x20\x01(\x0b\
    2\x0b.pe.VersionR\x10subsystemVersion\x120\n\rimage_version\x18\x06\x20\
    \x01(\x0b2\x0b.pe.VersionR\x0cimageVersion\x122\n\x0elinker_version\x18\
    \x07\x20\x01(\x0b2\x0b.pe.VersionR\rlinkerVersion\x124\n\x0copthdr_magic\
    \x18\x08\x20\x01(\x0e2\x11.pe.OptionalMagicR\x0bopthdrMagic\x12E\n\x0fch\
    aracteristics\x18\t\x20\x01(\rR\x0fcharacteristicsB\x1b\x82\x93\x19\x17*\
    \x15flags:Characteristics\x12O\n\x13dll_characteristics\x18\n\x20\x01(\r\
    R\x12dllCharacteristicsB\x1e\x82\x93\x19\x1a*\x18flags:DllCharacteristic\
    s\x12%\n\ttimestamp\x18\x0b\x20\x01(\rR\ttimestampB\x07\x82\x93\x19\x03*\
    \x01t\x12&\n\nimage_base\x18\x0c\x20\x01(\x04R\timageBaseB\x07\x82\x93\
    \x19\x03*\x01x\x12\x1a\n\x08checksum\x18\r\x20\x01(\rR\x08checksum\x12)\
    \n\x0cbase_of_code\x18\x0e\x20\x01(\rR\nbaseOfCodeB\x07\x82\x93\x19\x03*\
    \x01x\x12)\n\x0cbase_of_data\x18\x0f\x20\x01(\rR\nbaseOfDataB\x07\x82\
    \x93\x19\x03*\x01x\x12(\n\x0bentry_point\x18\x10\x20\x01(\rR\nentryPoint\
    B\x07\x82\x93\x19\x03*\x01x\x12/\n\x0fentry_point_raw\x18\x11\x20\x01(\r\
    R\rentryPointRawB\x07\x82\x93\x19\x03*\x01x\x12\x19\n\x08dll_name\x18\
    \x12\x20\x01(\tR\x07dllName\x122\n\x10export_timestamp\x18\x13\x20\x01(\
    \rR\x0fexportTimestampB\x07\x82\x93\x19\x03*\x01t\x124\n\x11section_alig\
    nment\x18\x14\x20\x01(\rR\x10sectionAlignmentB\x07\x82\x93\x19\x03*\x01x\
    \x12.\n\x0efile_alignment\x18\x15\x20\x01(\rR\rfileAlignmentB\x07\x82\
    \x93\x19\x03*\x01x\x12*\n\x0cloader_flags\x18\x16\x20\x01(\rR\x0bloaderF\
    lagsB\x07\x82\x93\x19\x03*\x01x\x12>\n\x17size_of_optional_header\x18\
    \x17\x20\x01(\rR\x14sizeOfOptionalHeaderB\x07\x82\x93\x19\x03*\x01x\x12)\
    \n\x0csize_of_code\x18\x18\x20\x01(\rR\nsizeOfCodeB\x07\x82\x93\x19\x03*\
    \x01x\x12@\n\x18size_of_initialized_data\x18\x19\x20\x01(\rR\x15sizeOfIn\
    itializedDataB\x07\x82\x93\x19\x03*\x01x\x12D\n\x1asize_of_uninitialized\
    _data\x18\x1a\x20\x01(\rR\x17sizeOfUninitializedDataB\x07\x82\x93\x19\
    \x03*\x01x\x12+\n\rsize_of_image\x18\x1b\x20\x01(\rR\x0bsizeOfImageB\x07\
    \x82\x93\x19\x03*\x01x\x12/\n\x0fsize_of_headers\x18\x1c\x20\x01(\rR\rsi\
    zeOfHeadersB\x07\x82\x93\x19\x03*\x01x\x12:\n\x15size_of_stack_reserve\
    \x18\x1d\x20\x01(\x04R\x12sizeOfStackReserveB\x07\x82\x93\x19\x03*\x01x\
    \x128\n\x14size_of_stack_commit\x18\x1e\x20\x01(\x04R\x11sizeOfStackComm\
    itB\x07\x82\x93\x19\x03*\x01x\x128\n\x14size_of_heap_reserve\x18\x1f\x20\
    \x01(\x04R\x11sizeOfHeapReserveB\x07\x82\x93\x19\x03*\x01x\x126\n\x13siz\
    e_of_heap_commit\x18\x20\x20\x01(\x04R\x10sizeOfHeapCommitB\x07\x82\x93\
    \x19\x03*\x01x\x12>\n\x17pointer_to_symbol_table\x18!\x20\x01(\rR\x14poi\
    nterToSymbolTableB\x07\x82\x93\x19\x03*\x01x\x12.\n\x13win32_version_val\
    ue\x18\"\x20\x01(\rR\x11win32VersionValue\x12*\n\x11number_of_symbols\
    \x18#\x20\x01(\rR\x0fnumberOfSymbols\x124\n\x17number_of_rva_and_sizes\
    \x18$\x20\x01(\rR\x13numberOfRvaAndSizes\x12\x7f\n\x12number_of_sections\
    \x18%\x20\x01(\rR\x10numberOfSectionsBQ\x82\x93\x19M2K\n\x18this\x20fiel\
    d\x20is\x20deprecated\x12\x1fuse\x20`pe.sections.len()`\x20instead\x1a\
    \x0esections.len()\x12?\n\x1cnumber_of_imported_functions\x18&\x20\x01(\
    \x04R\x19numberOfImportedFunctions\x12N\n$number_of_delayed_imported_fun\
    ctions\x18'\x20\x01(\x04R\x20numberOfDelayedImportedFunctions\x12\x83\
    \x01\n\x13number_of_resources\x18(\x20\x01(\x04R\x11numberOfResourcesBS\
    \x82\x93\x19O2M\n\x18this\x20field\x20is\x20deprecated\x12\x20use\x20`pe\
    .resources.len()`\x20instead\x1a\x0fresources.len()\x125\n\x17number_of_\
    version_infos\x18)\x20\x01(\x04R\x14numberOfVersionInfos\x12*\n\x11numbe\
    r_of_imports\x18*\x20\x01(\x04R\x0fnumberOfImports\x129\n\x19number_of_d\
    elayed_imports\x18+\x20\x01(\x04R\x16numberOfDelayedImports\x12*\n\x11nu\
    mber_of_exports\x18,\x20\x01(\x04R\x0fnumberOfExports\x12\x87\x01\n\x14n\
    umber_of_signatures\x18-\x20\x01(\x04R\x12numberOfSignaturesBU\x82\x93\
    \x19Q2O\n\x18this\x20field\x20is\x20deprecated\x12!use\x20`pe.signatures\
    .len()`\x20instead\x1a\x10signatures.len()\x12:\n\x0cversion_info\x18.\
    \x20\x03(\x0b2\x17.pe.PE.VersionInfoEntryR\x0bversionInfo\x128\n\x11vers\
    ion_info_list\x18/\x20\x03(\x0b2\x0c.pe.KeyValueR\x0fversionInfoList\x12\
    8\n\x0erich_signature\x180\x20\x01(\x0b2\x11.pe.RichSignatureR\rrichSign\
    ature\x12\x19\n\x08pdb_path\x181\x20\x01(\x0cR\x07pdbPath\x12'\n\x08sect\
    ions\x182\x20\x03(\x0b2\x0b.pe.SectionR\x08sections\x127\n\x10data_direc\
    tories\x183\x20\x03(\x0b2\x0c.pe.DirEntryR\x0fdataDirectories\x126\n\x12\
    resource_timestamp\x184\x20\x01(\x04R\x11resourceTimestampB\x07\x82\x93\
    \x19\x03*\x01t\x126\n\x10resource_version\x185\x20\x01(\x0b2\x0b.pe.Vers\
    ionR\x0fresourceVersion\x12*\n\tresources\x186\x20\x03(\x0b2\x0c.pe.Reso\
    urceR\tresources\x121\n\x0eimport_details\x187\x20\x03(\x0b2\n.pe.Import\
    R\rimportDetails\x12@\n\x16delayed_import_details\x188\x20\x03(\x0b2\n.p\
    e.ImportR\x14delayedImportDetails\x121\n\x0eexport_details\x189\x20\x03(\
    \x0b2\n.pe.ExportR\rexportDetails\x12\x1b\n\tis_signed\x18:\x20\x01(\x08\
    R\x08isSigned\x12-\n\nsignatures\x18;\x20\x03(\x0b2\r.pe.SignatureR\nsig\
    natures\x12%\n\x07overlay\x18<\x20\x01(\x0b2\x0b.pe.OverlayR\x07overlay\
    \x1a>\n\x10VersionInfoEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"5\n\x07Versi\
    on\x12\x14\n\x05major\x18\x01\x20\x02(\rR\x05major\x12\x14\n\x05minor\
    \x18\x02\x20\x02(\rR\x05minor\"2\n\x08KeyValue\x12\x10\n\x03key\x18\x01\
    \x20\x02(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x02(\tR\x05value\"Y\n\
    \x08DirEntry\x120\n\x0fvirtual_address\x18\x01\x20\x02(\rR\x0evirtualAdd\
    ressB\x07\x82\x93\x19\x03*\x01x\x12\x1b\n\x04size\x18\x02\x20\x02(\rR\
    \x04sizeB\x07\x82\x93\x19\x03*\x01x\"\xa4\x02\n\x08Resource\x12\x1f\n\
    \x06length\x18\x01\x20\x02(\rR\x06lengthB\x07\x82\x93\x19\x03*\x01x\x12\
    \x19\n\x03rva\x18\x02\x20\x02(\rR\x03rvaB\x07\x82\x93\x19\x03*\x01x\x12\
    \x1f\n\x06offset\x18\x03\x20\x01(\rR\x06offsetB\x07\x82\x93\x19\x03*\x01\
    x\x12$\n\x04type\x18\x04\x20\x01(\x0e2\x10.pe.ResourceTypeR\x04type\x12\
    \x0e\n\x02id\x18\x05\x20\x01(\rR\x02id\x12\x1a\n\x08language\x18\x06\x20\
    \x01(\rR\x08language\x12\x1f\n\x0btype_string\x18\x07\x20\x01(\x0cR\ntyp\
    eString\x12\x1f\n\x0bname_string\x18\x08\x20\x01(\x0cR\nnameString\x12'\
    \n\x0flanguage_string\x18\t\x20\x01(\x0cR\x0elanguageString\"\x87\x01\n\
    \x06Import\x12!\n\x0clibrary_name\x18\x01\x20\x02(\tR\x0blibraryName\x12\
    .\n\x13number_of_functions\x18\x02\x20\x02(\x04R\x11numberOfFunctions\
    \x12*\n\tfunctions\x18\x03\x20\x03(\x0b2\x0c.pe.FunctionR\tfunctions\"\
    \x95\x01\n\x06Export\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\
    \x18\n\x07ordinal\x18\x02\x20\x02(\rR\x07ordinal\x12\x19\n\x03rva\x18\
    \x03\x20\x02(\rR\x03rvaB\x07\x82\x93\x19\x03*\x01x\x12\x1f\n\x06offset\
    \x18\x04\x20\x01(\rR\x06offsetB\x07\x82\x93\x19\x03*\x01x\x12!\n\x0cforw\
    ard_name\x18\x05\x20\x01(\tR\x0bforwardName\"S\n\x08Function\x12\x12\n\
    \x04name\x18\x01\x20\x01(\tR\x04name\x12\x18\n\x07ordinal\x18\x02\x20\
    \x01(\rR\x07ordinal\x12\x19\n\x03rva\x18\x03\x20\x02(\rR\x03rvaB\x07\x82\
    \x93\x19\x03*\x01x\"\xb4\x05\n\tSignature\x12\x18\n\x07subject\x18\x01\
    \x20\x01(\tR\x07subject\x12\x16\n\x06issuer\x18\x02\x20\x01(\tR\x06issue\
    r\x12\x1e\n\nthumbprint\x18\x03\x20\x01(\tR\nthumbprint\x12\x18\n\x07ver\
    sion\x18\x04\x20\x01(\x03R\x07version\x12\x1c\n\talgorithm\x18\x05\x20\
    \x01(\tR\talgorithm\x12#\n\ralgorithm_oid\x18\x06\x20\x01(\tR\x0calgorit\
    hmOid\x12\x16\n\x06serial\x18\x07\x20\x01(\tR\x06serial\x12&\n\nnot_befo\
    re\x18\x08\x20\x01(\x03R\tnotBeforeB\x07\x82\x93\x19\x03*\x01t\x12$\n\tn\
    ot_after\x18\t\x20\x01(\x03R\x08notAfterB\x07\x82\x93\x19\x03*\x01t\x12\
    \x1a\n\x08verified\x18\n\x20\x01(\x08R\x08verified\x12\x1d\n\ndigest_alg\
    \x18\x0b\x20\x01(\tR\tdigestAlg\x12\x16\n\x06digest\x18\x0c\x20\x01(\tR\
    \x06digest\x12\x1f\n\x0bfile_digest\x18\r\x20\x01(\tR\nfileDigest\x124\n\
    \x16number_of_certificates\x18\x0e\x20\x01(\x04R\x14numberOfCertificates\
    \x12>\n\x1bnumber_of_countersignatures\x18\x0f\x20\x01(\x04R\x19numberOf\
    Countersignatures\x12/\n\x0bsigner_info\x18\x10\x20\x01(\x0b2\x0e.pe.Sig\
    nerInfoR\nsignerInfo\x123\n\x0ccertificates\x18\x11\x20\x03(\x0b2\x0f.pe\
    .CertificateR\x0ccertificates\x12B\n\x11countersignatures\x18\x12\x20\
    \x03(\x0b2\x14.pe.CounterSignatureR\x11countersignatures\"\xaa\x01\n\nSi\
    gnerInfo\x12!\n\x0cprogram_name\x18\x01\x20\x01(\tR\x0bprogramName\x12\
    \x1b\n\tmore_info\x18\x02\x20\x01(\tR\x08moreInfo\x12\x16\n\x06digest\
    \x18\x03\x20\x01(\tR\x06digest\x12\x1d\n\ndigest_alg\x18\x04\x20\x01(\tR\
    \tdigestAlg\x12%\n\x05chain\x18\x05\x20\x03(\x0b2\x0f.pe.CertificateR\
    \x05chain\"\xa2\x02\n\x0bCertificate\x12\x16\n\x06issuer\x18\x01\x20\x01\
    (\tR\x06issuer\x12\x18\n\x07subject\x18\x02\x20\x01(\tR\x07subject\x12\
    \x1e\n\nthumbprint\x18\x03\x20\x01(\tR\nthumbprint\x12\x18\n\x07version\
    \x18\x04\x20\x01(\x03R\x07version\x12\x1c\n\talgorithm\x18\x05\x20\x01(\
    \tR\talgorithm\x12#\n\ralgorithm_oid\x18\x06\x20\x01(\tR\x0calgorithmOid\
    \x12\x16\n\x06serial\x18\x07\x20\x01(\tR\x06serial\x12&\n\nnot_before\
    \x18\x08\x20\x01(\x03R\tnotBeforeB\x07\x82\x93\x19\x03*\x01t\x12$\n\tnot\
    _after\x18\t\x20\x01(\x03R\x08notAfterB\x07\x82\x93\x19\x03*\x01t\"\xb2\
    \x01\n\x10CounterSignature\x12\x1a\n\x08verified\x18\x01\x20\x01(\x08R\
    \x08verified\x12$\n\tsign_time\x18\x02\x20\x01(\x03R\x08signTimeB\x07\
    \x82\x93\x19\x03*\x01t\x12\x16\n\x06digest\x18\x0c\x20\x01(\tR\x06digest\
    \x12\x1d\n\ndigest_alg\x18\x03\x20\x01(\tR\tdigestAlg\x12%\n\x05chain\
    \x18\x04\x20\x03(\x0b2\x0f.pe.CertificateR\x05chain\"\xac\x04\n\x07Secti\
    on\x12\x12\n\x04name\x18\x01\x20\x02(\x0cR\x04name\x12\x1b\n\tfull_name\
    \x18\x02\x20\x02(\x0cR\x08fullName\x12L\n\x0fcharacteristics\x18\x03\x20\
    \x02(\rR\x0fcharacteristicsB\"\x82\x93\x19\x1e*\x1cflags:SectionCharacte\
    ristics\x12+\n\rraw_data_size\x18\x04\x20\x02(\rR\x0brawDataSizeB\x07\
    \x82\x93\x19\x03*\x01x\x12/\n\x0fraw_data_offset\x18\x05\x20\x02(\rR\rra\
    wDataOffsetB\x07\x82\x93\x19\x03*\x01x\x120\n\x0fvirtual_address\x18\x06\
    \x20\x02(\rR\x0evirtualAddressB\x07\x82\x93\x19\x03*\x01x\x12*\n\x0cvirt\
    ual_size\x18\x07\x20\x02(\rR\x0bvirtualSizeB\x07\x82\x93\x19\x03*\x01x\
    \x12=\n\x16pointer_to_relocations\x18\x08\x20\x02(\rR\x14pointerToReloca\
    tionsB\x07\x82\x93\x19\x03*\x01x\x12>\n\x17pointer_to_line_numbers\x18\t\
    \x20\x02(\rR\x14pointerToLineNumbersB\x07\x82\x93\x19\x03*\x01x\x122\n\
    \x15number_of_relocations\x18\n\x20\x02(\rR\x13numberOfRelocations\x123\
    \n\x16number_of_line_numbers\x18\x0b\x20\x02(\rR\x13numberOfLineNumbers\
    \"\xc1\x01\n\rRichSignature\x12\x1f\n\x06offset\x18\x01\x20\x02(\rR\x06o\
    ffsetB\x07\x82\x93\x19\x03*\x01x\x12\x1f\n\x06length\x18\x02\x20\x02(\rR\
    \x06lengthB\x07\x82\x93\x19\x03*\x01x\x12\x10\n\x03key\x18\x03\x20\x02(\
    \rR\x03key\x12\x19\n\x08raw_data\x18\x04\x20\x02(\x0cR\x07rawData\x12\
    \x1d\n\nclear_data\x18\x05\x20\x02(\x0cR\tclearData\x12\"\n\x05tools\x18\
    \x06\x20\x03(\x0b2\x0c.pe.RichToolR\x05tools\"R\n\x08RichTool\x12\x16\n\
    \x06toolid\x18\x01\x20\x02(\rR\x06toolid\x12\x18\n\x07version\x18\x02\
    \x20\x02(\rR\x07version\x12\x14\n\x05times\x18\x03\x20\x02(\rR\x05times\
    \"G\n\x07Overlay\x12\x1f\n\x06offset\x18\x01\x20\x02(\x04R\x06offsetB\
    \x07\x82\x93\x19\x03*\x01x\x12\x1b\n\x04size\x18\x02\x20\x02(\x04R\x04si\
    zeB\x07\x82\x93\x19\x03*\x01x*\xd0\x04\n\x0cResourceType\x12\x18\n\x14RE\
    SOURCE_TYPE_CURSOR\x10\x01\x12\x18\n\x14RESOURCE_TYPE_BITMAP\x10\x02\x12\
    \x16\n\x12RESOURCE_TYPE_ICON\x10\x03\x12\x16\n\x12RESOURCE_TYPE_MENU\x10\
    \x04\x12\x18\n\x14RESOURCE_TYPE_DIALOG\x10\x05\x12\x18\n\x14RESOURCE_TYP\
    E_STRING\x10\x06\x12\x19\n\x15RESOURCE_TYPE_FONTDIR\x10\x07\x12\x16\n\
    \x12RESOURCE_TYPE_FONT\x10\x08\x12\x1d\n\x19RESOURCE_TYPE_ACCELERATOR\
    \x10\t\x12\x18\n\x14RESOURCE_TYPE_RCDATA\x10\n\x12\x1e\n\x1aRESOURCE_TYP\
    E_MESSAGETABLE\x10\x0b\x12\x1e\n\x1aRESOURCE_TYPE_GROUP_CURSOR\x10\x0c\
    \x12\x1c\n\x18RESOURCE_TYPE_GROUP_ICON\x10\x0e\x12\x19\n\x15RESOURCE_TYP\
    E_VERSION\x10\x10\x12\x1c\n\x18RESOURCE_TYPE_DLGINCLUDE\x10\x11\x12\x1a\
    \n\x16RESOURCE_TYPE_PLUGPLAY\x10\x13\x12\x15\n\x11RESOURCE_TYPE_VXD\x10\
    \x14\x12\x1b\n\x17RESOURCE_TYPE_ANICURSOR\x10\x15\x12\x19\n\x15RESOURCE_\
    TYPE_ANIICON\x10\x16\x12\x16\n\x12RESOURCE_TYPE_HTML\x10\x17\x12\x1a\n\
    \x16RESOURCE_TYPE_MANIFEST\x10\x18\x1a\x06\x92\x93\x19\x02\x10\x01*\xd1\
    \x03\n\x07Machine\x12\x13\n\x0fMACHINE_UNKNOWN\x10\0\x12\x11\n\x0cMACHIN\
    E_AM33\x10\xd3\x03\x12\x13\n\rMACHINE_AMD64\x10\xe4\x8c\x02\x12\x10\n\
    \x0bMACHINE_ARM\x10\xc0\x03\x12\x12\n\rMACHINE_ARMNT\x10\xc4\x03\x12\x13\
    \n\rMACHINE_ARM64\x10\xe4\xd4\x02\x12\x10\n\x0bMACHINE_EBC\x10\xbc\x1d\
    \x12\x11\n\x0cMACHINE_I386\x10\xcc\x02\x12\x11\n\x0cMACHINE_IA64\x10\x80\
    \x04\x12\x12\n\x0cMACHINE_M32R\x10\xc1\xa0\x02\x12\x13\n\x0eMACHINE_MIPS\
    16\x10\xe6\x04\x12\x14\n\x0fMACHINE_MIPSFPU\x10\xe6\x06\x12\x16\n\x11MAC\
    HINE_MIPSFPU16\x10\xe6\x08\x12\x14\n\x0fMACHINE_POWERPC\x10\xf0\x03\x12\
    \x16\n\x11MACHINE_POWERPCFP\x10\xf1\x03\x12\x12\n\rMACHINE_R4000\x10\xe6\
    \x02\x12\x10\n\x0bMACHINE_SH3\x10\xa2\x03\x12\x13\n\x0eMACHINE_SH3DSP\
    \x10\xa3\x03\x12\x10\n\x0bMACHINE_SH4\x10\xa6\x03\x12\x10\n\x0bMACHINE_S\
    H5\x10\xa8\x03\x12\x12\n\rMACHINE_THUMB\x10\xc2\x03\x12\x16\n\x11MACHINE\
    _WCEMIPSV2\x10\xe9\x02\x1a\x06\x92\x93\x19\x02\x10\x01*\xa3\x03\n\tSubsy\
    stem\x12\x15\n\x11SUBSYSTEM_UNKNOWN\x10\0\x12\x14\n\x10SUBSYSTEM_NATIVE\
    \x10\x01\x12\x19\n\x15SUBSYSTEM_WINDOWS_GUI\x10\x02\x12\x19\n\x15SUBSYST\
    EM_WINDOWS_CUI\x10\x03\x12\x15\n\x11SUBSYSTEM_OS2_CUI\x10\x05\x12\x17\n\
    \x13SUBSYSTEM_POSIX_CUI\x10\x07\x12\x1c\n\x18SUBSYSTEM_NATIVE_WINDOWS\
    \x10\x08\x12\x1c\n\x18SUBSYSTEM_WINDOWS_CE_GUI\x10\t\x12\x1d\n\x19SUBSYS\
    TEM_EFI_APPLICATION\x10\n\x12%\n!SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER\x10\
    \x0b\x12\x20\n\x1cSUBSYSTEM_EFI_RUNTIME_DRIVER\x10\x0c\x12\x1b\n\x17SUBS\
    YSTEM_EFI_ROM_IMAGE\x10\r\x12\x12\n\x0eSUBSYSTEM_XBOX\x10\x0e\x12&\n\"SU\
    BSYSTEM_WINDOWS_BOOT_APPLICATION\x10\x10\x1a\x06\x92\x93\x19\x02\x10\x01\
    *N\n\x0bImportFlags\x12\x13\n\x0fIMPORT_STANDARD\x10\x01\x12\x12\n\x0eIM\
    PORT_DELAYED\x10\x02\x12\x0e\n\nIMPORT_ANY\x10\x03\x1a\x06\x92\x93\x19\
    \x02\x10\x01*\xe2\x02\n\x0fCharacteristics\x12\x13\n\x0fRELOCS_STRIPPED\
    \x10\x01\x12\x14\n\x10EXECUTABLE_IMAGE\x10\x02\x12\x16\n\x12LINE_NUMS_ST\
    RIPPED\x10\x04\x12\x17\n\x13LOCAL_SYMS_STRIPPED\x10\x08\x12\x15\n\x11AGG\
    RESIVE_WS_TRIM\x10\x10\x12\x17\n\x13LARGE_ADDRESS_AWARE\x10\x20\x12\x16\
    \n\x11BYTES_REVERSED_LO\x10\x80\x01\x12\x12\n\rMACHINE_32BIT\x10\x80\x02\
    \x12\x13\n\x0eDEBUG_STRIPPED\x10\x80\x04\x12\x1c\n\x17REMOVABLE_RUN_FROM\
    _SWAP\x10\x80\x08\x12\x16\n\x11NET_RUN_FROM_SWAP\x10\x80\x10\x12\x0b\n\
    \x06SYSTEM\x10\x80\x20\x12\x08\n\x03DLL\x10\x80@\x12\x14\n\x0eUP_SYSTEM_\
    ONLY\x10\x80\x80\x01\x12\x17\n\x11BYTES_REVERSED_HI\x10\x80\x80\x02\x1a\
    \x06\x92\x93\x19\x02\x10\x01*\x82\x01\n\rOptionalMagic\x12\"\n\x1dIMAGE_\
    NT_OPTIONAL_HDR32_MAGIC\x10\x8b\x02\x12\"\n\x1dIMAGE_NT_OPTIONAL_HDR64_M\
    AGIC\x10\x8b\x04\x12!\n\x1cIMAGE_ROM_OPTIONAL_HDR_MAGIC\x10\x87\x02\x1a\
    \x06\x92\x93\x19\x02\x10\x01*\xe0\x05\n\x0eDirectoryEntry\x12(\n\x1cIMAG\
    E_DIRECTORY_ENTRY_EXPORT\x10\0\x1a\x06\x9a\x93\x19\x02\x08\0\x12(\n\x1cI\
    MAGE_DIRECTORY_ENTRY_IMPORT\x10\x01\x1a\x06\x9a\x93\x19\x02\x08\x01\x12*\
    \n\x1eIMAGE_DIRECTORY_ENTRY_RESOURCE\x10\x02\x1a\x06\x9a\x93\x19\x02\x08\
    \x02\x12+\n\x1fIMAGE_DIRECTORY_ENTRY_EXCEPTION\x10\x03\x1a\x06\x9a\x93\
    \x19\x02\x08\x03\x12*\n\x1eIMAGE_DIRECTORY_ENTRY_SECURITY\x10\x04\x1a\
    \x06\x9a\x93\x19\x02\x08\x04\x12+\n\x1fIMAGE_DIRECTORY_ENTRY_BASERELOC\
    \x10\x05\x1a\x06\x9a\x93\x19\x02\x08\x05\x12'\n\x1bIMAGE_DIRECTORY_ENTRY\
    _DEBUG\x10\x06\x1a\x06\x9a\x93\x19\x02\x08\x06\x12+\n\x1fIMAGE_DIRECTORY\
    _ENTRY_COPYRIGHT\x10\x07\x1a\x06\x9a\x93\x19\x02\x08\x07\x12.\n\"IMAGE_D\
    IRECTORY_ENTRY_ARCHITECTURE\x10\x08\x1a\x06\x9a\x93\x19\x02\x08\x07\x12+\
    \n\x1fIMAGE_DIRECTORY_ENTRY_GLOBALPTR\x10\t\x1a\x06\x9a\x93\x19\x02\x08\
    \x08\x12%\n\x19IMAGE_DIRECTORY_ENTRY_TLS\x10\n\x1a\x06\x9a\x93\x19\x02\
    \x08\t\x12-\n!IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG\x10\x0b\x1a\x06\x9a\x93\
    \x19\x02\x08\n\x12.\n\"IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT\x10\x0c\x1a\
    \x06\x9a\x93\x19\x02\x08\x0b\x12%\n\x19IMAGE_DIRECTORY_ENTRY_IAT\x10\r\
    \x1a\x06\x9a\x93\x19\x02\x08\x0c\x12.\n\"IMAGE_DIRECTORY_ENTRY_DELAY_IMP\
    ORT\x10\x0e\x1a\x06\x9a\x93\x19\x02\x08\r\x120\n$IMAGE_DIRECTORY_ENTRY_C\
    OM_DESCRIPTOR\x10\x0f\x1a\x06\x9a\x93\x19\x02\x08\x0e\x1a\x06\x92\x93\
    \x19\x02\x10\x01*\x81\n\n\x16SectionCharacteristics\x12\x1a\n\x0eSECTION\
    _NO_PAD\x10\x01\x1a\x06\x9a\x93\x19\x02\x08\x08\x12\x1c\n\x10SECTION_CNT\
    _CODE\x10\x02\x1a\x06\x9a\x93\x19\x02\x08\x20\x12(\n\x1cSECTION_CNT_INIT\
    IALIZED_DATA\x10\x03\x1a\x06\x9a\x93\x19\x02\x08@\x12+\n\x1eSECTION_CNT_\
    UNINITIALIZED_DATA\x10\x04\x1a\x07\x9a\x93\x19\x03\x08\x80\x01\x12\x1e\n\
    \x11SECTION_LNK_OTHER\x10\x05\x1a\x07\x9a\x93\x19\x03\x08\x80\x02\x12\
    \x1d\n\x10SECTION_LNK_INFO\x10\x06\x1a\x07\x9a\x93\x19\x03\x08\x80\x04\
    \x12\x1f\n\x12SECTION_LNK_REMOVE\x10\x07\x1a\x07\x9a\x93\x19\x03\x08\x80\
    \x10\x12\x1f\n\x12SECTION_LNK_COMDAT\x10\x08\x1a\x07\x9a\x93\x19\x03\x08\
    \x80\x20\x12'\n\x19SECTION_NO_DEFER_SPEC_EXC\x10\t\x1a\x08\x9a\x93\x19\
    \x04\x08\x80\x80\x01\x12\x1b\n\rSECTION_GPREL\x10\n\x1a\x08\x9a\x93\x19\
    \x04\x08\x80\x80\x02\x12\"\n\x14SECTION_ALIGN_1BYTES\x10\x0b\x1a\x08\x9a\
    \x93\x19\x04\x08\x80\x80@\x12#\n\x14SECTION_ALIGN_2BYTES\x10\x0c\x1a\t\
    \x9a\x93\x19\x05\x08\x80\x80\x80\x01\x12#\n\x14SECTION_ALIGN_4BYTES\x10\
    \r\x1a\t\x9a\x93\x19\x05\x08\x80\x80\xc0\x01\x12#\n\x14SECTION_ALIGN_8BY\
    TES\x10\x0e\x1a\t\x9a\x93\x19\x05\x08\x80\x80\x80\x02\x12$\n\x15SECTION_\
    ALIGN_16BYTES\x10\x0f\x1a\t\x9a\x93\x19\x05\x08\x80\x80\xc0\x02\x12$\n\
    \x15SECTION_ALIGN_32BYTES\x10\x10\x1a\t\x9a\x93\x19\x05\x08\x80\x80\x80\
    \x03\x12$\n\x15SECTION_ALIGN_64BYTES\x10\x11\x1a\t\x9a\x93\x19\x05\x08\
    \x80\x80\xc0\x03\x12%\n\x16SECTION_ALIGN_128BYTES\x10\x12\x1a\t\x9a\x93\
    \x19\x05\x08\x80\x80\x80\x04\x12%\n\x16SECTION_ALIGN_256BYTES\x10\x13\
    \x1a\t\x9a\x93\x19\x05\x08\x80\x80\xc0\x04\x12%\n\x16SECTION_ALIGN_512BY\
    TES\x10\x14\x1a\t\x9a\x93\x19\x05\x08\x80\x80\x80\x05\x12&\n\x17SECTION_\
    ALIGN_1024BYTES\x10\x15\x1a\t\x9a\x93\x19\x05\x08\x80\x80\xc0\x05\x12&\n\
    \x17SECTION_ALIGN_2048BYTES\x10\x16\x1a\t\x9a\x93\x19\x05\x08\x80\x80\
    \x80\x06\x12&\n\x17SECTION_ALIGN_4096BYTES\x10\x17\x1a\t\x9a\x93\x19\x05\
    \x08\x80\x80\xc0\x06\x12&\n\x17SECTION_ALIGN_8192BYTES\x10\x18\x1a\t\x9a\
    \x93\x19\x05\x08\x80\x80\x80\x07\x12!\n\x12SECTION_ALIGN_MASK\x10\x19\
    \x1a\t\x9a\x93\x19\x05\x08\x80\x80\xc0\x07\x12&\n\x17SECTION_LNK_NRELOC_\
    OVFL\x10\x1a\x1a\t\x9a\x93\x19\x05\x08\x80\x80\x80\x08\x12&\n\x17SECTION\
    _MEM_DISCARDABLE\x10\x1b\x1a\t\x9a\x93\x19\x05\x08\x80\x80\x80\x10\x12%\
    \n\x16SECTION_MEM_NOT_CACHED\x10\x1c\x1a\t\x9a\x93\x19\x05\x08\x80\x80\
    \x80\x20\x12$\n\x15SECTION_MEM_NOT_PAGED\x10\x1d\x1a\t\x9a\x93\x19\x05\
    \x08\x80\x80\x80@\x12\"\n\x12SECTION_MEM_SHARED\x10\x1e\x1a\n\x9a\x93\
    \x19\x06\x08\x80\x80\x80\x80\x01\x12#\n\x13SECTION_MEM_EXECUTE\x10\x1f\
    \x1a\n\x9a\x93\x19\x06\x08\x80\x80\x80\x80\x02\x12\x20\n\x10SECTION_MEM_\
    READ\x10\x20\x1a\n\x9a\x93\x19\x06\x08\x80\x80\x80\x80\x04\x12!\n\x11SEC\
    TION_MEM_WRITE\x10!\x1a\n\x9a\x93\x19\x06\x08\x80\x80\x80\x80\x08\x12\
    \x1f\n\x13SECTION_SCALE_INDEX\x10\"\x1a\x06\x9a\x93\x19\x02\x08\x01\x1a\
    \x06\x92\x93\x19\x02\x10\x01*\xe8\x01\n\x12DllCharacteristics\x12\x13\n\
    \x0fHIGH_ENTROPY_VA\x10\x20\x12\x10\n\x0cDYNAMIC_BASE\x10@\x12\x14\n\x0f\
    FORCE_INTEGRITY\x10\x80\x01\x12\x0e\n\tNX_COMPAT\x10\x80\x02\x12\x11\n\
    \x0cNO_ISOLATION\x10\x80\x04\x12\x0b\n\x06NO_SEH\x10\x80\x08\x12\x0c\n\
    \x07NO_BIND\x10\x80\x10\x12\x11\n\x0cAPPCONTAINER\x10\x80\x20\x12\x0f\n\
    \nWDM_DRIVER\x10\x80@\x12\x0e\n\x08GUARD_CF\x10\x80\x80\x01\x12\x1b\n\
    \x15TERMINAL_SERVER_AWARE\x10\x80\x80\x02\x1a\x06\x92\x93\x19\x02\x10\
    \x01B\x1e\xfa\x92\x19\x1a\n\x02pe\x12\x05pe.PE\x1a\x02pe\"\tpe-moduleb\
    \x06proto2\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::yara::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(16);
            messages.push(PE::generated_message_descriptor_data());
            messages.push(Version::generated_message_descriptor_data());
            messages.push(KeyValue::generated_message_descriptor_data());
            messages.push(DirEntry::generated_message_descriptor_data());
            messages.push(Resource::generated_message_descriptor_data());
            messages.push(Import::generated_message_descriptor_data());
            messages.push(Export::generated_message_descriptor_data());
            messages.push(Function::generated_message_descriptor_data());
            messages.push(Signature::generated_message_descriptor_data());
            messages.push(SignerInfo::generated_message_descriptor_data());
            messages.push(Certificate::generated_message_descriptor_data());
            messages.push(CounterSignature::generated_message_descriptor_data());
            messages.push(Section::generated_message_descriptor_data());
            messages.push(RichSignature::generated_message_descriptor_data());
            messages.push(RichTool::generated_message_descriptor_data());
            messages.push(Overlay::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(9);
            enums.push(ResourceType::generated_enum_descriptor_data());
            enums.push(Machine::generated_enum_descriptor_data());
            enums.push(Subsystem::generated_enum_descriptor_data());
            enums.push(ImportFlags::generated_enum_descriptor_data());
            enums.push(Characteristics::generated_enum_descriptor_data());
            enums.push(OptionalMagic::generated_enum_descriptor_data());
            enums.push(DirectoryEntry::generated_enum_descriptor_data());
            enums.push(SectionCharacteristics::generated_enum_descriptor_data());
            enums.push(DllCharacteristics::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
