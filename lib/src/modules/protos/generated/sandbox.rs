// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `vt/sandbox.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

// @@protoc_insertion_point(message:vt.fileanalysis.BehaviourSummary)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BehaviourSummary {
    // message fields
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.files_opened)
    pub files_opened: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.files_written)
    pub files_written: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.files_deleted)
    pub files_deleted: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.files_copied)
    pub files_copied: ::std::vec::Vec<FileCopy>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.files_attribute_changed)
    pub files_attribute_changed: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.files_dropped)
    pub files_dropped: ::std::vec::Vec<DroppedFile>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.hosts_file)
    pub hosts_file: ::std::string::String,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.processes_list)
    pub processes_list: ::std::vec::Vec<ProcessItem>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.processes_created)
    pub processes_created: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.processes_terminated)
    pub processes_terminated: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.processes_killed)
    pub processes_killed: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.processes_injected)
    pub processes_injected: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.command_executions)
    pub command_executions: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.services_opened)
    pub services_opened: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.services_created)
    pub services_created: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.services_started)
    pub services_started: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.services_stopped)
    pub services_stopped: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.services_deleted)
    pub services_deleted: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.services_bound)
    pub services_bound: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.windows_searched)
    pub windows_searched: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.windows_hidden)
    pub windows_hidden: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.permissions_checked)
    pub permissions_checked: ::std::vec::Vec<PermissionCheck>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.permissions_requested)
    pub permissions_requested: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.mutexes_opened)
    pub mutexes_opened: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.mutexes_created)
    pub mutexes_created: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.signals_observed)
    pub signals_observed: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.signals_hooked)
    pub signals_hooked: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.modules_loaded)
    pub modules_loaded: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.calls_highlighted)
    pub calls_highlighted: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.invokes)
    pub invokes: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.crypto_algorithms_observed)
    pub crypto_algorithms_observed: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.crypto_keys)
    pub crypto_keys: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.crypto_plain_text)
    pub crypto_plain_text: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.encoding_algorithms_observed)
    pub encoding_algorithms_observed: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.text_decoded)
    pub text_decoded: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.text_highlighted)
    pub text_highlighted: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.tags)
    pub tags: ::std::vec::Vec<::protobuf::EnumOrUnknown<BehaviourTag>>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.databases_opened)
    pub databases_opened: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.databases_deleted)
    pub databases_deleted: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.registry_keys_opened)
    pub registry_keys_opened: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.registry_keys_set)
    pub registry_keys_set: ::std::vec::Vec<KeyValue>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.registry_keys_deleted)
    pub registry_keys_deleted: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.system_property_lookups)
    pub system_property_lookups: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.system_property_sets)
    pub system_property_sets: ::std::vec::Vec<KeyValue>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.shared_preferences_lookups)
    pub shared_preferences_lookups: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.shared_preferences_sets)
    pub shared_preferences_sets: ::std::vec::Vec<KeyValue>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.content_model_observers)
    pub content_model_observers: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.content_model_sets)
    pub content_model_sets: ::std::vec::Vec<KeyValue>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.activities_started)
    pub activities_started: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.http_conversations)
    pub http_conversations: ::std::vec::Vec<HttpConversation>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.dns_lookups)
    pub dns_lookups: ::std::vec::Vec<DnsLookup>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.ip_traffic)
    pub ip_traffic: ::std::vec::Vec<IpTraffic>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.sms_sent)
    pub sms_sent: ::std::vec::Vec<Sms>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.verdicts)
    pub verdicts: ::std::vec::Vec<::protobuf::EnumOrUnknown<VerdictTag>>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.verdict_confidence)
    pub verdict_confidence: i32,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.verdict_labels)
    pub verdict_labels: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.ja3_digests)
    pub ja3_digests: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.memory_pattern_ips)
    pub memory_pattern_ips: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.memory_pattern_domains)
    pub memory_pattern_domains: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.memory_pattern_urls)
    pub memory_pattern_urls: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.smtp_conversations)
    pub smtp_conversations: ::std::vec::Vec<SmtpConversation>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.ids_alerts)
    pub ids_alerts: ::std::vec::Vec<super::net_analysis::CrowdSourcedIdsResults>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.tls)
    pub tls: ::std::vec::Vec<TLS>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.mitre_attack_techniques)
    pub mitre_attack_techniques: ::std::vec::Vec<MitreAttackTechnique>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.sigma_analysis_results)
    pub sigma_analysis_results: ::std::vec::Vec<super::sigma::SigmaMatch>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.signature_matches)
    pub signature_matches: ::std::vec::Vec<SignatureMatch>,
    // @@protoc_insertion_point(field:vt.fileanalysis.BehaviourSummary.mbc)
    pub mbc: ::std::vec::Vec<MalwareBehaviorCatalog>,
    // special fields
    // @@protoc_insertion_point(special_field:vt.fileanalysis.BehaviourSummary.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BehaviourSummary {
    fn default() -> &'a BehaviourSummary {
        <BehaviourSummary as ::protobuf::Message>::default_instance()
    }
}

impl BehaviourSummary {
    pub fn new() -> BehaviourSummary {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(67);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "files_opened",
            |m: &BehaviourSummary| { &m.files_opened },
            |m: &mut BehaviourSummary| { &mut m.files_opened },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "files_written",
            |m: &BehaviourSummary| { &m.files_written },
            |m: &mut BehaviourSummary| { &mut m.files_written },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "files_deleted",
            |m: &BehaviourSummary| { &m.files_deleted },
            |m: &mut BehaviourSummary| { &mut m.files_deleted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "files_copied",
            |m: &BehaviourSummary| { &m.files_copied },
            |m: &mut BehaviourSummary| { &mut m.files_copied },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "files_attribute_changed",
            |m: &BehaviourSummary| { &m.files_attribute_changed },
            |m: &mut BehaviourSummary| { &mut m.files_attribute_changed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "files_dropped",
            |m: &BehaviourSummary| { &m.files_dropped },
            |m: &mut BehaviourSummary| { &mut m.files_dropped },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hosts_file",
            |m: &BehaviourSummary| { &m.hosts_file },
            |m: &mut BehaviourSummary| { &mut m.hosts_file },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "processes_list",
            |m: &BehaviourSummary| { &m.processes_list },
            |m: &mut BehaviourSummary| { &mut m.processes_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "processes_created",
            |m: &BehaviourSummary| { &m.processes_created },
            |m: &mut BehaviourSummary| { &mut m.processes_created },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "processes_terminated",
            |m: &BehaviourSummary| { &m.processes_terminated },
            |m: &mut BehaviourSummary| { &mut m.processes_terminated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "processes_killed",
            |m: &BehaviourSummary| { &m.processes_killed },
            |m: &mut BehaviourSummary| { &mut m.processes_killed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "processes_injected",
            |m: &BehaviourSummary| { &m.processes_injected },
            |m: &mut BehaviourSummary| { &mut m.processes_injected },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "command_executions",
            |m: &BehaviourSummary| { &m.command_executions },
            |m: &mut BehaviourSummary| { &mut m.command_executions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "services_opened",
            |m: &BehaviourSummary| { &m.services_opened },
            |m: &mut BehaviourSummary| { &mut m.services_opened },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "services_created",
            |m: &BehaviourSummary| { &m.services_created },
            |m: &mut BehaviourSummary| { &mut m.services_created },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "services_started",
            |m: &BehaviourSummary| { &m.services_started },
            |m: &mut BehaviourSummary| { &mut m.services_started },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "services_stopped",
            |m: &BehaviourSummary| { &m.services_stopped },
            |m: &mut BehaviourSummary| { &mut m.services_stopped },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "services_deleted",
            |m: &BehaviourSummary| { &m.services_deleted },
            |m: &mut BehaviourSummary| { &mut m.services_deleted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "services_bound",
            |m: &BehaviourSummary| { &m.services_bound },
            |m: &mut BehaviourSummary| { &mut m.services_bound },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "windows_searched",
            |m: &BehaviourSummary| { &m.windows_searched },
            |m: &mut BehaviourSummary| { &mut m.windows_searched },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "windows_hidden",
            |m: &BehaviourSummary| { &m.windows_hidden },
            |m: &mut BehaviourSummary| { &mut m.windows_hidden },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "permissions_checked",
            |m: &BehaviourSummary| { &m.permissions_checked },
            |m: &mut BehaviourSummary| { &mut m.permissions_checked },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "permissions_requested",
            |m: &BehaviourSummary| { &m.permissions_requested },
            |m: &mut BehaviourSummary| { &mut m.permissions_requested },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "mutexes_opened",
            |m: &BehaviourSummary| { &m.mutexes_opened },
            |m: &mut BehaviourSummary| { &mut m.mutexes_opened },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "mutexes_created",
            |m: &BehaviourSummary| { &m.mutexes_created },
            |m: &mut BehaviourSummary| { &mut m.mutexes_created },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "signals_observed",
            |m: &BehaviourSummary| { &m.signals_observed },
            |m: &mut BehaviourSummary| { &mut m.signals_observed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "signals_hooked",
            |m: &BehaviourSummary| { &m.signals_hooked },
            |m: &mut BehaviourSummary| { &mut m.signals_hooked },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "modules_loaded",
            |m: &BehaviourSummary| { &m.modules_loaded },
            |m: &mut BehaviourSummary| { &mut m.modules_loaded },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "calls_highlighted",
            |m: &BehaviourSummary| { &m.calls_highlighted },
            |m: &mut BehaviourSummary| { &mut m.calls_highlighted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "invokes",
            |m: &BehaviourSummary| { &m.invokes },
            |m: &mut BehaviourSummary| { &mut m.invokes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "crypto_algorithms_observed",
            |m: &BehaviourSummary| { &m.crypto_algorithms_observed },
            |m: &mut BehaviourSummary| { &mut m.crypto_algorithms_observed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "crypto_keys",
            |m: &BehaviourSummary| { &m.crypto_keys },
            |m: &mut BehaviourSummary| { &mut m.crypto_keys },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "crypto_plain_text",
            |m: &BehaviourSummary| { &m.crypto_plain_text },
            |m: &mut BehaviourSummary| { &mut m.crypto_plain_text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "encoding_algorithms_observed",
            |m: &BehaviourSummary| { &m.encoding_algorithms_observed },
            |m: &mut BehaviourSummary| { &mut m.encoding_algorithms_observed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "text_decoded",
            |m: &BehaviourSummary| { &m.text_decoded },
            |m: &mut BehaviourSummary| { &mut m.text_decoded },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "text_highlighted",
            |m: &BehaviourSummary| { &m.text_highlighted },
            |m: &mut BehaviourSummary| { &mut m.text_highlighted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tags",
            |m: &BehaviourSummary| { &m.tags },
            |m: &mut BehaviourSummary| { &mut m.tags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "databases_opened",
            |m: &BehaviourSummary| { &m.databases_opened },
            |m: &mut BehaviourSummary| { &mut m.databases_opened },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "databases_deleted",
            |m: &BehaviourSummary| { &m.databases_deleted },
            |m: &mut BehaviourSummary| { &mut m.databases_deleted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "registry_keys_opened",
            |m: &BehaviourSummary| { &m.registry_keys_opened },
            |m: &mut BehaviourSummary| { &mut m.registry_keys_opened },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "registry_keys_set",
            |m: &BehaviourSummary| { &m.registry_keys_set },
            |m: &mut BehaviourSummary| { &mut m.registry_keys_set },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "registry_keys_deleted",
            |m: &BehaviourSummary| { &m.registry_keys_deleted },
            |m: &mut BehaviourSummary| { &mut m.registry_keys_deleted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "system_property_lookups",
            |m: &BehaviourSummary| { &m.system_property_lookups },
            |m: &mut BehaviourSummary| { &mut m.system_property_lookups },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "system_property_sets",
            |m: &BehaviourSummary| { &m.system_property_sets },
            |m: &mut BehaviourSummary| { &mut m.system_property_sets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "shared_preferences_lookups",
            |m: &BehaviourSummary| { &m.shared_preferences_lookups },
            |m: &mut BehaviourSummary| { &mut m.shared_preferences_lookups },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "shared_preferences_sets",
            |m: &BehaviourSummary| { &m.shared_preferences_sets },
            |m: &mut BehaviourSummary| { &mut m.shared_preferences_sets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "content_model_observers",
            |m: &BehaviourSummary| { &m.content_model_observers },
            |m: &mut BehaviourSummary| { &mut m.content_model_observers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "content_model_sets",
            |m: &BehaviourSummary| { &m.content_model_sets },
            |m: &mut BehaviourSummary| { &mut m.content_model_sets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "activities_started",
            |m: &BehaviourSummary| { &m.activities_started },
            |m: &mut BehaviourSummary| { &mut m.activities_started },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "http_conversations",
            |m: &BehaviourSummary| { &m.http_conversations },
            |m: &mut BehaviourSummary| { &mut m.http_conversations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dns_lookups",
            |m: &BehaviourSummary| { &m.dns_lookups },
            |m: &mut BehaviourSummary| { &mut m.dns_lookups },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ip_traffic",
            |m: &BehaviourSummary| { &m.ip_traffic },
            |m: &mut BehaviourSummary| { &mut m.ip_traffic },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sms_sent",
            |m: &BehaviourSummary| { &m.sms_sent },
            |m: &mut BehaviourSummary| { &mut m.sms_sent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "verdicts",
            |m: &BehaviourSummary| { &m.verdicts },
            |m: &mut BehaviourSummary| { &mut m.verdicts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "verdict_confidence",
            |m: &BehaviourSummary| { &m.verdict_confidence },
            |m: &mut BehaviourSummary| { &mut m.verdict_confidence },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "verdict_labels",
            |m: &BehaviourSummary| { &m.verdict_labels },
            |m: &mut BehaviourSummary| { &mut m.verdict_labels },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ja3_digests",
            |m: &BehaviourSummary| { &m.ja3_digests },
            |m: &mut BehaviourSummary| { &mut m.ja3_digests },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "memory_pattern_ips",
            |m: &BehaviourSummary| { &m.memory_pattern_ips },
            |m: &mut BehaviourSummary| { &mut m.memory_pattern_ips },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "memory_pattern_domains",
            |m: &BehaviourSummary| { &m.memory_pattern_domains },
            |m: &mut BehaviourSummary| { &mut m.memory_pattern_domains },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "memory_pattern_urls",
            |m: &BehaviourSummary| { &m.memory_pattern_urls },
            |m: &mut BehaviourSummary| { &mut m.memory_pattern_urls },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "smtp_conversations",
            |m: &BehaviourSummary| { &m.smtp_conversations },
            |m: &mut BehaviourSummary| { &mut m.smtp_conversations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids_alerts",
            |m: &BehaviourSummary| { &m.ids_alerts },
            |m: &mut BehaviourSummary| { &mut m.ids_alerts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tls",
            |m: &BehaviourSummary| { &m.tls },
            |m: &mut BehaviourSummary| { &mut m.tls },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "mitre_attack_techniques",
            |m: &BehaviourSummary| { &m.mitre_attack_techniques },
            |m: &mut BehaviourSummary| { &mut m.mitre_attack_techniques },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sigma_analysis_results",
            |m: &BehaviourSummary| { &m.sigma_analysis_results },
            |m: &mut BehaviourSummary| { &mut m.sigma_analysis_results },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "signature_matches",
            |m: &BehaviourSummary| { &m.signature_matches },
            |m: &mut BehaviourSummary| { &mut m.signature_matches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "mbc",
            |m: &BehaviourSummary| { &m.mbc },
            |m: &mut BehaviourSummary| { &mut m.mbc },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BehaviourSummary>(
            "BehaviourSummary",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BehaviourSummary {
    const NAME: &'static str = "BehaviourSummary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.files_opened.push(is.read_string()?);
                },
                18 => {
                    self.files_written.push(is.read_string()?);
                },
                26 => {
                    self.files_deleted.push(is.read_string()?);
                },
                34 => {
                    self.files_copied.push(is.read_message()?);
                },
                42 => {
                    self.files_attribute_changed.push(is.read_string()?);
                },
                50 => {
                    self.files_dropped.push(is.read_message()?);
                },
                58 => {
                    self.hosts_file = is.read_string()?;
                },
                602 => {
                    self.processes_list.push(is.read_message()?);
                },
                74 => {
                    self.processes_created.push(is.read_string()?);
                },
                82 => {
                    self.processes_terminated.push(is.read_string()?);
                },
                90 => {
                    self.processes_killed.push(is.read_string()?);
                },
                98 => {
                    self.processes_injected.push(is.read_string()?);
                },
                106 => {
                    self.command_executions.push(is.read_string()?);
                },
                114 => {
                    self.services_opened.push(is.read_string()?);
                },
                122 => {
                    self.services_created.push(is.read_string()?);
                },
                130 => {
                    self.services_started.push(is.read_string()?);
                },
                138 => {
                    self.services_stopped.push(is.read_string()?);
                },
                146 => {
                    self.services_deleted.push(is.read_string()?);
                },
                154 => {
                    self.services_bound.push(is.read_string()?);
                },
                162 => {
                    self.windows_searched.push(is.read_string()?);
                },
                170 => {
                    self.windows_hidden.push(is.read_string()?);
                },
                178 => {
                    self.permissions_checked.push(is.read_message()?);
                },
                186 => {
                    self.permissions_requested.push(is.read_string()?);
                },
                194 => {
                    self.mutexes_opened.push(is.read_string()?);
                },
                202 => {
                    self.mutexes_created.push(is.read_string()?);
                },
                210 => {
                    self.signals_observed.push(is.read_string()?);
                },
                218 => {
                    self.signals_hooked.push(is.read_string()?);
                },
                226 => {
                    self.modules_loaded.push(is.read_string()?);
                },
                234 => {
                    self.calls_highlighted.push(is.read_string()?);
                },
                242 => {
                    self.invokes.push(is.read_string()?);
                },
                250 => {
                    self.crypto_algorithms_observed.push(is.read_string()?);
                },
                258 => {
                    self.crypto_keys.push(is.read_string()?);
                },
                266 => {
                    self.crypto_plain_text.push(is.read_string()?);
                },
                274 => {
                    self.encoding_algorithms_observed.push(is.read_string()?);
                },
                282 => {
                    self.text_decoded.push(is.read_string()?);
                },
                290 => {
                    self.text_highlighted.push(is.read_string()?);
                },
                296 => {
                    self.tags.push(is.read_enum_or_unknown()?);
                },
                298 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.tags)?
                },
                442 => {
                    self.databases_opened.push(is.read_string()?);
                },
                450 => {
                    self.databases_deleted.push(is.read_string()?);
                },
                306 => {
                    self.registry_keys_opened.push(is.read_string()?);
                },
                314 => {
                    self.registry_keys_set.push(is.read_message()?);
                },
                322 => {
                    self.registry_keys_deleted.push(is.read_string()?);
                },
                330 => {
                    self.system_property_lookups.push(is.read_string()?);
                },
                338 => {
                    self.system_property_sets.push(is.read_message()?);
                },
                346 => {
                    self.shared_preferences_lookups.push(is.read_string()?);
                },
                354 => {
                    self.shared_preferences_sets.push(is.read_message()?);
                },
                362 => {
                    self.content_model_observers.push(is.read_string()?);
                },
                370 => {
                    self.content_model_sets.push(is.read_message()?);
                },
                378 => {
                    self.activities_started.push(is.read_string()?);
                },
                386 => {
                    self.http_conversations.push(is.read_message()?);
                },
                394 => {
                    self.dns_lookups.push(is.read_message()?);
                },
                402 => {
                    self.ip_traffic.push(is.read_message()?);
                },
                410 => {
                    self.sms_sent.push(is.read_message()?);
                },
                416 => {
                    self.verdicts.push(is.read_enum_or_unknown()?);
                },
                418 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.verdicts)?
                },
                488 => {
                    self.verdict_confidence = is.read_int32()?;
                },
                522 => {
                    self.verdict_labels.push(is.read_string()?);
                },
                458 => {
                    self.ja3_digests.push(is.read_string()?);
                },
                466 => {
                    self.memory_pattern_ips.push(is.read_string()?);
                },
                474 => {
                    self.memory_pattern_domains.push(is.read_string()?);
                },
                482 => {
                    self.memory_pattern_urls.push(is.read_string()?);
                },
                514 => {
                    self.smtp_conversations.push(is.read_message()?);
                },
                546 => {
                    self.ids_alerts.push(is.read_message()?);
                },
                554 => {
                    self.tls.push(is.read_message()?);
                },
                562 => {
                    self.mitre_attack_techniques.push(is.read_message()?);
                },
                570 => {
                    self.sigma_analysis_results.push(is.read_message()?);
                },
                578 => {
                    self.signature_matches.push(is.read_message()?);
                },
                594 => {
                    self.mbc.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.files_opened {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.files_written {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.files_deleted {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.files_copied {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.files_attribute_changed {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.files_dropped {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.hosts_file.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.hosts_file);
        }
        for value in &self.processes_list {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.processes_created {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        for value in &self.processes_terminated {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        for value in &self.processes_killed {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        for value in &self.processes_injected {
            my_size += ::protobuf::rt::string_size(12, &value);
        };
        for value in &self.command_executions {
            my_size += ::protobuf::rt::string_size(13, &value);
        };
        for value in &self.services_opened {
            my_size += ::protobuf::rt::string_size(14, &value);
        };
        for value in &self.services_created {
            my_size += ::protobuf::rt::string_size(15, &value);
        };
        for value in &self.services_started {
            my_size += ::protobuf::rt::string_size(16, &value);
        };
        for value in &self.services_stopped {
            my_size += ::protobuf::rt::string_size(17, &value);
        };
        for value in &self.services_deleted {
            my_size += ::protobuf::rt::string_size(18, &value);
        };
        for value in &self.services_bound {
            my_size += ::protobuf::rt::string_size(19, &value);
        };
        for value in &self.windows_searched {
            my_size += ::protobuf::rt::string_size(20, &value);
        };
        for value in &self.windows_hidden {
            my_size += ::protobuf::rt::string_size(21, &value);
        };
        for value in &self.permissions_checked {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.permissions_requested {
            my_size += ::protobuf::rt::string_size(23, &value);
        };
        for value in &self.mutexes_opened {
            my_size += ::protobuf::rt::string_size(24, &value);
        };
        for value in &self.mutexes_created {
            my_size += ::protobuf::rt::string_size(25, &value);
        };
        for value in &self.signals_observed {
            my_size += ::protobuf::rt::string_size(26, &value);
        };
        for value in &self.signals_hooked {
            my_size += ::protobuf::rt::string_size(27, &value);
        };
        for value in &self.modules_loaded {
            my_size += ::protobuf::rt::string_size(28, &value);
        };
        for value in &self.calls_highlighted {
            my_size += ::protobuf::rt::string_size(29, &value);
        };
        for value in &self.invokes {
            my_size += ::protobuf::rt::string_size(30, &value);
        };
        for value in &self.crypto_algorithms_observed {
            my_size += ::protobuf::rt::string_size(31, &value);
        };
        for value in &self.crypto_keys {
            my_size += ::protobuf::rt::string_size(32, &value);
        };
        for value in &self.crypto_plain_text {
            my_size += ::protobuf::rt::string_size(33, &value);
        };
        for value in &self.encoding_algorithms_observed {
            my_size += ::protobuf::rt::string_size(34, &value);
        };
        for value in &self.text_decoded {
            my_size += ::protobuf::rt::string_size(35, &value);
        };
        for value in &self.text_highlighted {
            my_size += ::protobuf::rt::string_size(36, &value);
        };
        my_size += ::protobuf::rt::vec_packed_enum_or_unknown_size(37, &self.tags);
        for value in &self.databases_opened {
            my_size += ::protobuf::rt::string_size(55, &value);
        };
        for value in &self.databases_deleted {
            my_size += ::protobuf::rt::string_size(56, &value);
        };
        for value in &self.registry_keys_opened {
            my_size += ::protobuf::rt::string_size(38, &value);
        };
        for value in &self.registry_keys_set {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.registry_keys_deleted {
            my_size += ::protobuf::rt::string_size(40, &value);
        };
        for value in &self.system_property_lookups {
            my_size += ::protobuf::rt::string_size(41, &value);
        };
        for value in &self.system_property_sets {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.shared_preferences_lookups {
            my_size += ::protobuf::rt::string_size(43, &value);
        };
        for value in &self.shared_preferences_sets {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.content_model_observers {
            my_size += ::protobuf::rt::string_size(45, &value);
        };
        for value in &self.content_model_sets {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.activities_started {
            my_size += ::protobuf::rt::string_size(47, &value);
        };
        for value in &self.http_conversations {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.dns_lookups {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.ip_traffic {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.sms_sent {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::vec_packed_enum_or_unknown_size(52, &self.verdicts);
        if self.verdict_confidence != 0 {
            my_size += ::protobuf::rt::int32_size(61, self.verdict_confidence);
        }
        for value in &self.verdict_labels {
            my_size += ::protobuf::rt::string_size(65, &value);
        };
        for value in &self.ja3_digests {
            my_size += ::protobuf::rt::string_size(57, &value);
        };
        for value in &self.memory_pattern_ips {
            my_size += ::protobuf::rt::string_size(58, &value);
        };
        for value in &self.memory_pattern_domains {
            my_size += ::protobuf::rt::string_size(59, &value);
        };
        for value in &self.memory_pattern_urls {
            my_size += ::protobuf::rt::string_size(60, &value);
        };
        for value in &self.smtp_conversations {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.ids_alerts {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.tls {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.mitre_attack_techniques {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.sigma_analysis_results {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.signature_matches {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.mbc {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.files_opened {
            os.write_string(1, &v)?;
        };
        for v in &self.files_written {
            os.write_string(2, &v)?;
        };
        for v in &self.files_deleted {
            os.write_string(3, &v)?;
        };
        for v in &self.files_copied {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.files_attribute_changed {
            os.write_string(5, &v)?;
        };
        for v in &self.files_dropped {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if !self.hosts_file.is_empty() {
            os.write_string(7, &self.hosts_file)?;
        }
        for v in &self.processes_list {
            ::protobuf::rt::write_message_field_with_cached_size(75, v, os)?;
        };
        for v in &self.processes_created {
            os.write_string(9, &v)?;
        };
        for v in &self.processes_terminated {
            os.write_string(10, &v)?;
        };
        for v in &self.processes_killed {
            os.write_string(11, &v)?;
        };
        for v in &self.processes_injected {
            os.write_string(12, &v)?;
        };
        for v in &self.command_executions {
            os.write_string(13, &v)?;
        };
        for v in &self.services_opened {
            os.write_string(14, &v)?;
        };
        for v in &self.services_created {
            os.write_string(15, &v)?;
        };
        for v in &self.services_started {
            os.write_string(16, &v)?;
        };
        for v in &self.services_stopped {
            os.write_string(17, &v)?;
        };
        for v in &self.services_deleted {
            os.write_string(18, &v)?;
        };
        for v in &self.services_bound {
            os.write_string(19, &v)?;
        };
        for v in &self.windows_searched {
            os.write_string(20, &v)?;
        };
        for v in &self.windows_hidden {
            os.write_string(21, &v)?;
        };
        for v in &self.permissions_checked {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        };
        for v in &self.permissions_requested {
            os.write_string(23, &v)?;
        };
        for v in &self.mutexes_opened {
            os.write_string(24, &v)?;
        };
        for v in &self.mutexes_created {
            os.write_string(25, &v)?;
        };
        for v in &self.signals_observed {
            os.write_string(26, &v)?;
        };
        for v in &self.signals_hooked {
            os.write_string(27, &v)?;
        };
        for v in &self.modules_loaded {
            os.write_string(28, &v)?;
        };
        for v in &self.calls_highlighted {
            os.write_string(29, &v)?;
        };
        for v in &self.invokes {
            os.write_string(30, &v)?;
        };
        for v in &self.crypto_algorithms_observed {
            os.write_string(31, &v)?;
        };
        for v in &self.crypto_keys {
            os.write_string(32, &v)?;
        };
        for v in &self.crypto_plain_text {
            os.write_string(33, &v)?;
        };
        for v in &self.encoding_algorithms_observed {
            os.write_string(34, &v)?;
        };
        for v in &self.text_decoded {
            os.write_string(35, &v)?;
        };
        for v in &self.text_highlighted {
            os.write_string(36, &v)?;
        };
        os.write_repeated_packed_enum_or_unknown(37, &self.tags)?;
        for v in &self.databases_opened {
            os.write_string(55, &v)?;
        };
        for v in &self.databases_deleted {
            os.write_string(56, &v)?;
        };
        for v in &self.registry_keys_opened {
            os.write_string(38, &v)?;
        };
        for v in &self.registry_keys_set {
            ::protobuf::rt::write_message_field_with_cached_size(39, v, os)?;
        };
        for v in &self.registry_keys_deleted {
            os.write_string(40, &v)?;
        };
        for v in &self.system_property_lookups {
            os.write_string(41, &v)?;
        };
        for v in &self.system_property_sets {
            ::protobuf::rt::write_message_field_with_cached_size(42, v, os)?;
        };
        for v in &self.shared_preferences_lookups {
            os.write_string(43, &v)?;
        };
        for v in &self.shared_preferences_sets {
            ::protobuf::rt::write_message_field_with_cached_size(44, v, os)?;
        };
        for v in &self.content_model_observers {
            os.write_string(45, &v)?;
        };
        for v in &self.content_model_sets {
            ::protobuf::rt::write_message_field_with_cached_size(46, v, os)?;
        };
        for v in &self.activities_started {
            os.write_string(47, &v)?;
        };
        for v in &self.http_conversations {
            ::protobuf::rt::write_message_field_with_cached_size(48, v, os)?;
        };
        for v in &self.dns_lookups {
            ::protobuf::rt::write_message_field_with_cached_size(49, v, os)?;
        };
        for v in &self.ip_traffic {
            ::protobuf::rt::write_message_field_with_cached_size(50, v, os)?;
        };
        for v in &self.sms_sent {
            ::protobuf::rt::write_message_field_with_cached_size(51, v, os)?;
        };
        os.write_repeated_packed_enum_or_unknown(52, &self.verdicts)?;
        if self.verdict_confidence != 0 {
            os.write_int32(61, self.verdict_confidence)?;
        }
        for v in &self.verdict_labels {
            os.write_string(65, &v)?;
        };
        for v in &self.ja3_digests {
            os.write_string(57, &v)?;
        };
        for v in &self.memory_pattern_ips {
            os.write_string(58, &v)?;
        };
        for v in &self.memory_pattern_domains {
            os.write_string(59, &v)?;
        };
        for v in &self.memory_pattern_urls {
            os.write_string(60, &v)?;
        };
        for v in &self.smtp_conversations {
            ::protobuf::rt::write_message_field_with_cached_size(64, v, os)?;
        };
        for v in &self.ids_alerts {
            ::protobuf::rt::write_message_field_with_cached_size(68, v, os)?;
        };
        for v in &self.tls {
            ::protobuf::rt::write_message_field_with_cached_size(69, v, os)?;
        };
        for v in &self.mitre_attack_techniques {
            ::protobuf::rt::write_message_field_with_cached_size(70, v, os)?;
        };
        for v in &self.sigma_analysis_results {
            ::protobuf::rt::write_message_field_with_cached_size(71, v, os)?;
        };
        for v in &self.signature_matches {
            ::protobuf::rt::write_message_field_with_cached_size(72, v, os)?;
        };
        for v in &self.mbc {
            ::protobuf::rt::write_message_field_with_cached_size(74, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BehaviourSummary {
        BehaviourSummary::new()
    }

    fn clear(&mut self) {
        self.files_opened.clear();
        self.files_written.clear();
        self.files_deleted.clear();
        self.files_copied.clear();
        self.files_attribute_changed.clear();
        self.files_dropped.clear();
        self.hosts_file.clear();
        self.processes_list.clear();
        self.processes_created.clear();
        self.processes_terminated.clear();
        self.processes_killed.clear();
        self.processes_injected.clear();
        self.command_executions.clear();
        self.services_opened.clear();
        self.services_created.clear();
        self.services_started.clear();
        self.services_stopped.clear();
        self.services_deleted.clear();
        self.services_bound.clear();
        self.windows_searched.clear();
        self.windows_hidden.clear();
        self.permissions_checked.clear();
        self.permissions_requested.clear();
        self.mutexes_opened.clear();
        self.mutexes_created.clear();
        self.signals_observed.clear();
        self.signals_hooked.clear();
        self.modules_loaded.clear();
        self.calls_highlighted.clear();
        self.invokes.clear();
        self.crypto_algorithms_observed.clear();
        self.crypto_keys.clear();
        self.crypto_plain_text.clear();
        self.encoding_algorithms_observed.clear();
        self.text_decoded.clear();
        self.text_highlighted.clear();
        self.tags.clear();
        self.databases_opened.clear();
        self.databases_deleted.clear();
        self.registry_keys_opened.clear();
        self.registry_keys_set.clear();
        self.registry_keys_deleted.clear();
        self.system_property_lookups.clear();
        self.system_property_sets.clear();
        self.shared_preferences_lookups.clear();
        self.shared_preferences_sets.clear();
        self.content_model_observers.clear();
        self.content_model_sets.clear();
        self.activities_started.clear();
        self.http_conversations.clear();
        self.dns_lookups.clear();
        self.ip_traffic.clear();
        self.sms_sent.clear();
        self.verdicts.clear();
        self.verdict_confidence = 0;
        self.verdict_labels.clear();
        self.ja3_digests.clear();
        self.memory_pattern_ips.clear();
        self.memory_pattern_domains.clear();
        self.memory_pattern_urls.clear();
        self.smtp_conversations.clear();
        self.ids_alerts.clear();
        self.tls.clear();
        self.mitre_attack_techniques.clear();
        self.sigma_analysis_results.clear();
        self.signature_matches.clear();
        self.mbc.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BehaviourSummary {
        static instance: BehaviourSummary = BehaviourSummary {
            files_opened: ::std::vec::Vec::new(),
            files_written: ::std::vec::Vec::new(),
            files_deleted: ::std::vec::Vec::new(),
            files_copied: ::std::vec::Vec::new(),
            files_attribute_changed: ::std::vec::Vec::new(),
            files_dropped: ::std::vec::Vec::new(),
            hosts_file: ::std::string::String::new(),
            processes_list: ::std::vec::Vec::new(),
            processes_created: ::std::vec::Vec::new(),
            processes_terminated: ::std::vec::Vec::new(),
            processes_killed: ::std::vec::Vec::new(),
            processes_injected: ::std::vec::Vec::new(),
            command_executions: ::std::vec::Vec::new(),
            services_opened: ::std::vec::Vec::new(),
            services_created: ::std::vec::Vec::new(),
            services_started: ::std::vec::Vec::new(),
            services_stopped: ::std::vec::Vec::new(),
            services_deleted: ::std::vec::Vec::new(),
            services_bound: ::std::vec::Vec::new(),
            windows_searched: ::std::vec::Vec::new(),
            windows_hidden: ::std::vec::Vec::new(),
            permissions_checked: ::std::vec::Vec::new(),
            permissions_requested: ::std::vec::Vec::new(),
            mutexes_opened: ::std::vec::Vec::new(),
            mutexes_created: ::std::vec::Vec::new(),
            signals_observed: ::std::vec::Vec::new(),
            signals_hooked: ::std::vec::Vec::new(),
            modules_loaded: ::std::vec::Vec::new(),
            calls_highlighted: ::std::vec::Vec::new(),
            invokes: ::std::vec::Vec::new(),
            crypto_algorithms_observed: ::std::vec::Vec::new(),
            crypto_keys: ::std::vec::Vec::new(),
            crypto_plain_text: ::std::vec::Vec::new(),
            encoding_algorithms_observed: ::std::vec::Vec::new(),
            text_decoded: ::std::vec::Vec::new(),
            text_highlighted: ::std::vec::Vec::new(),
            tags: ::std::vec::Vec::new(),
            databases_opened: ::std::vec::Vec::new(),
            databases_deleted: ::std::vec::Vec::new(),
            registry_keys_opened: ::std::vec::Vec::new(),
            registry_keys_set: ::std::vec::Vec::new(),
            registry_keys_deleted: ::std::vec::Vec::new(),
            system_property_lookups: ::std::vec::Vec::new(),
            system_property_sets: ::std::vec::Vec::new(),
            shared_preferences_lookups: ::std::vec::Vec::new(),
            shared_preferences_sets: ::std::vec::Vec::new(),
            content_model_observers: ::std::vec::Vec::new(),
            content_model_sets: ::std::vec::Vec::new(),
            activities_started: ::std::vec::Vec::new(),
            http_conversations: ::std::vec::Vec::new(),
            dns_lookups: ::std::vec::Vec::new(),
            ip_traffic: ::std::vec::Vec::new(),
            sms_sent: ::std::vec::Vec::new(),
            verdicts: ::std::vec::Vec::new(),
            verdict_confidence: 0,
            verdict_labels: ::std::vec::Vec::new(),
            ja3_digests: ::std::vec::Vec::new(),
            memory_pattern_ips: ::std::vec::Vec::new(),
            memory_pattern_domains: ::std::vec::Vec::new(),
            memory_pattern_urls: ::std::vec::Vec::new(),
            smtp_conversations: ::std::vec::Vec::new(),
            ids_alerts: ::std::vec::Vec::new(),
            tls: ::std::vec::Vec::new(),
            mitre_attack_techniques: ::std::vec::Vec::new(),
            sigma_analysis_results: ::std::vec::Vec::new(),
            signature_matches: ::std::vec::Vec::new(),
            mbc: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BehaviourSummary {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BehaviourSummary").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BehaviourSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BehaviourSummary {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:vt.fileanalysis.TLS)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TLS {
    // message fields
    // @@protoc_insertion_point(field:vt.fileanalysis.TLS.subject)
    pub subject: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.TLS.issuer)
    pub issuer: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.TLS.serial_number)
    pub serial_number: ::std::string::String,
    // @@protoc_insertion_point(field:vt.fileanalysis.TLS.thumbprint)
    pub thumbprint: ::std::string::String,
    // @@protoc_insertion_point(field:vt.fileanalysis.TLS.version)
    pub version: ::std::string::String,
    // @@protoc_insertion_point(field:vt.fileanalysis.TLS.sni)
    pub sni: ::std::string::String,
    // @@protoc_insertion_point(field:vt.fileanalysis.TLS.ja3)
    pub ja3: ::std::string::String,
    // @@protoc_insertion_point(field:vt.fileanalysis.TLS.ja3s)
    pub ja3s: ::std::string::String,
    // @@protoc_insertion_point(field:vt.fileanalysis.TLS.ja4)
    pub ja4: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:vt.fileanalysis.TLS.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TLS {
    fn default() -> &'a TLS {
        <TLS as ::protobuf::Message>::default_instance()
    }
}

impl TLS {
    pub fn new() -> TLS {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "subject",
            |m: &TLS| { &m.subject },
            |m: &mut TLS| { &mut m.subject },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "issuer",
            |m: &TLS| { &m.issuer },
            |m: &mut TLS| { &mut m.issuer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "serial_number",
            |m: &TLS| { &m.serial_number },
            |m: &mut TLS| { &mut m.serial_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "thumbprint",
            |m: &TLS| { &m.thumbprint },
            |m: &mut TLS| { &mut m.thumbprint },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version",
            |m: &TLS| { &m.version },
            |m: &mut TLS| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sni",
            |m: &TLS| { &m.sni },
            |m: &mut TLS| { &mut m.sni },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ja3",
            |m: &TLS| { &m.ja3 },
            |m: &mut TLS| { &mut m.ja3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ja3s",
            |m: &TLS| { &m.ja3s },
            |m: &mut TLS| { &mut m.ja3s },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ja4",
            |m: &TLS| { &m.ja4 },
            |m: &mut TLS| { &mut m.ja4 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TLS>(
            "TLS",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TLS {
    const NAME: &'static str = "TLS";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.subject.insert(key, value);
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.issuer.insert(key, value);
                },
                26 => {
                    self.serial_number = is.read_string()?;
                },
                34 => {
                    self.thumbprint = is.read_string()?;
                },
                42 => {
                    self.version = is.read_string()?;
                },
                50 => {
                    self.sni = is.read_string()?;
                },
                58 => {
                    self.ja3 = is.read_string()?;
                },
                66 => {
                    self.ja3s = is.read_string()?;
                },
                82 => {
                    self.ja4 = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.subject {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.issuer {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if !self.serial_number.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.serial_number);
        }
        if !self.thumbprint.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.thumbprint);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.version);
        }
        if !self.sni.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.sni);
        }
        if !self.ja3.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.ja3);
        }
        if !self.ja3s.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.ja3s);
        }
        if !self.ja4.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.ja4);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.subject {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        for (k, v) in &self.issuer {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if !self.serial_number.is_empty() {
            os.write_string(3, &self.serial_number)?;
        }
        if !self.thumbprint.is_empty() {
            os.write_string(4, &self.thumbprint)?;
        }
        if !self.version.is_empty() {
            os.write_string(5, &self.version)?;
        }
        if !self.sni.is_empty() {
            os.write_string(6, &self.sni)?;
        }
        if !self.ja3.is_empty() {
            os.write_string(7, &self.ja3)?;
        }
        if !self.ja3s.is_empty() {
            os.write_string(8, &self.ja3s)?;
        }
        if !self.ja4.is_empty() {
            os.write_string(10, &self.ja4)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TLS {
        TLS::new()
    }

    fn clear(&mut self) {
        self.subject.clear();
        self.issuer.clear();
        self.serial_number.clear();
        self.thumbprint.clear();
        self.version.clear();
        self.sni.clear();
        self.ja3.clear();
        self.ja3s.clear();
        self.ja4.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TLS {
        static instance: ::protobuf::rt::Lazy<TLS> = ::protobuf::rt::Lazy::new();
        instance.get(TLS::new)
    }
}

impl ::protobuf::MessageFull for TLS {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TLS").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TLS {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TLS {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:vt.fileanalysis.FileCopy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FileCopy {
    // message fields
    // @@protoc_insertion_point(field:vt.fileanalysis.FileCopy.source)
    pub source: ::std::string::String,
    // @@protoc_insertion_point(field:vt.fileanalysis.FileCopy.destination)
    pub destination: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:vt.fileanalysis.FileCopy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileCopy {
    fn default() -> &'a FileCopy {
        <FileCopy as ::protobuf::Message>::default_instance()
    }
}

impl FileCopy {
    pub fn new() -> FileCopy {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "source",
            |m: &FileCopy| { &m.source },
            |m: &mut FileCopy| { &mut m.source },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "destination",
            |m: &FileCopy| { &m.destination },
            |m: &mut FileCopy| { &mut m.destination },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileCopy>(
            "FileCopy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileCopy {
    const NAME: &'static str = "FileCopy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.source = is.read_string()?;
                },
                18 => {
                    self.destination = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.source.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.source);
        }
        if !self.destination.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.destination);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.source.is_empty() {
            os.write_string(1, &self.source)?;
        }
        if !self.destination.is_empty() {
            os.write_string(2, &self.destination)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileCopy {
        FileCopy::new()
    }

    fn clear(&mut self) {
        self.source.clear();
        self.destination.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileCopy {
        static instance: FileCopy = FileCopy {
            source: ::std::string::String::new(),
            destination: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileCopy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileCopy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileCopy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileCopy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:vt.fileanalysis.DroppedFile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DroppedFile {
    // message fields
    // @@protoc_insertion_point(field:vt.fileanalysis.DroppedFile.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:vt.fileanalysis.DroppedFile.sha256)
    pub sha256: ::std::string::String,
    // @@protoc_insertion_point(field:vt.fileanalysis.DroppedFile.type)
    pub type_: ::protobuf::EnumOrUnknown<super::filetypes::FileType>,
    // @@protoc_insertion_point(field:vt.fileanalysis.DroppedFile.download_url)
    pub download_url: ::std::string::String,
    // @@protoc_insertion_point(field:vt.fileanalysis.DroppedFile.process_name)
    pub process_name: ::std::string::String,
    // @@protoc_insertion_point(field:vt.fileanalysis.DroppedFile.process_id)
    pub process_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:vt.fileanalysis.DroppedFile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DroppedFile {
    fn default() -> &'a DroppedFile {
        <DroppedFile as ::protobuf::Message>::default_instance()
    }
}

impl DroppedFile {
    pub fn new() -> DroppedFile {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &DroppedFile| { &m.path },
            |m: &mut DroppedFile| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sha256",
            |m: &DroppedFile| { &m.sha256 },
            |m: &mut DroppedFile| { &mut m.sha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &DroppedFile| { &m.type_ },
            |m: &mut DroppedFile| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "download_url",
            |m: &DroppedFile| { &m.download_url },
            |m: &mut DroppedFile| { &mut m.download_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "process_name",
            |m: &DroppedFile| { &m.process_name },
            |m: &mut DroppedFile| { &mut m.process_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "process_id",
            |m: &DroppedFile| { &m.process_id },
            |m: &mut DroppedFile| { &mut m.process_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DroppedFile>(
            "DroppedFile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DroppedFile {
    const NAME: &'static str = "DroppedFile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = is.read_string()?;
                },
                18 => {
                    self.sha256 = is.read_string()?;
                },
                24 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                42 => {
                    self.download_url = is.read_string()?;
                },
                50 => {
                    self.process_name = is.read_string()?;
                },
                58 => {
                    self.process_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        if !self.sha256.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.sha256);
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(super::filetypes::FileType::UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(3, self.type_.value());
        }
        if !self.download_url.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.download_url);
        }
        if !self.process_name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.process_name);
        }
        if !self.process_id.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.process_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        if !self.sha256.is_empty() {
            os.write_string(2, &self.sha256)?;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(super::filetypes::FileType::UNKNOWN) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if !self.download_url.is_empty() {
            os.write_string(5, &self.download_url)?;
        }
        if !self.process_name.is_empty() {
            os.write_string(6, &self.process_name)?;
        }
        if !self.process_id.is_empty() {
            os.write_string(7, &self.process_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DroppedFile {
        DroppedFile::new()
    }

    fn clear(&mut self) {
        self.path.clear();
        self.sha256.clear();
        self.type_ = ::protobuf::EnumOrUnknown::new(super::filetypes::FileType::UNKNOWN);
        self.download_url.clear();
        self.process_name.clear();
        self.process_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DroppedFile {
        static instance: DroppedFile = DroppedFile {
            path: ::std::string::String::new(),
            sha256: ::std::string::String::new(),
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            download_url: ::std::string::String::new(),
            process_name: ::std::string::String::new(),
            process_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DroppedFile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DroppedFile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DroppedFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DroppedFile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:vt.fileanalysis.PermissionCheck)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PermissionCheck {
    // message fields
    // @@protoc_insertion_point(field:vt.fileanalysis.PermissionCheck.permission)
    pub permission: ::std::string::String,
    // @@protoc_insertion_point(field:vt.fileanalysis.PermissionCheck.owner)
    pub owner: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:vt.fileanalysis.PermissionCheck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PermissionCheck {
    fn default() -> &'a PermissionCheck {
        <PermissionCheck as ::protobuf::Message>::default_instance()
    }
}

impl PermissionCheck {
    pub fn new() -> PermissionCheck {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "permission",
            |m: &PermissionCheck| { &m.permission },
            |m: &mut PermissionCheck| { &mut m.permission },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "owner",
            |m: &PermissionCheck| { &m.owner },
            |m: &mut PermissionCheck| { &mut m.owner },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PermissionCheck>(
            "PermissionCheck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PermissionCheck {
    const NAME: &'static str = "PermissionCheck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.permission = is.read_string()?;
                },
                18 => {
                    self.owner = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.permission.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.permission);
        }
        if !self.owner.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.owner);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.permission.is_empty() {
            os.write_string(1, &self.permission)?;
        }
        if !self.owner.is_empty() {
            os.write_string(2, &self.owner)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PermissionCheck {
        PermissionCheck::new()
    }

    fn clear(&mut self) {
        self.permission.clear();
        self.owner.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PermissionCheck {
        static instance: PermissionCheck = PermissionCheck {
            permission: ::std::string::String::new(),
            owner: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PermissionCheck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PermissionCheck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PermissionCheck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PermissionCheck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:vt.fileanalysis.KeyValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct KeyValue {
    // message fields
    // @@protoc_insertion_point(field:vt.fileanalysis.KeyValue.key)
    pub key: ::std::string::String,
    // @@protoc_insertion_point(field:vt.fileanalysis.KeyValue.value)
    pub value: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:vt.fileanalysis.KeyValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KeyValue {
    fn default() -> &'a KeyValue {
        <KeyValue as ::protobuf::Message>::default_instance()
    }
}

impl KeyValue {
    pub fn new() -> KeyValue {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &KeyValue| { &m.key },
            |m: &mut KeyValue| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &KeyValue| { &m.value },
            |m: &mut KeyValue| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KeyValue>(
            "KeyValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KeyValue {
    const NAME: &'static str = "KeyValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = is.read_string()?;
                },
                18 => {
                    self.value = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KeyValue {
        KeyValue::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KeyValue {
        static instance: KeyValue = KeyValue {
            key: ::std::string::String::new(),
            value: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KeyValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KeyValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KeyValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:vt.fileanalysis.HttpConversation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HttpConversation {
    // message fields
    // @@protoc_insertion_point(field:vt.fileanalysis.HttpConversation.url)
    pub url: ::std::string::String,
    // @@protoc_insertion_point(field:vt.fileanalysis.HttpConversation.request_method)
    pub request_method: ::protobuf::EnumOrUnknown<http_conversation::RequestMethod>,
    // @@protoc_insertion_point(field:vt.fileanalysis.HttpConversation.request_headers)
    pub request_headers: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.HttpConversation.response_headers)
    pub response_headers: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.HttpConversation.response_status_code)
    pub response_status_code: i32,
    // @@protoc_insertion_point(field:vt.fileanalysis.HttpConversation.response_body_filetype)
    pub response_body_filetype: ::protobuf::EnumOrUnknown<super::filetypes::FileType>,
    // @@protoc_insertion_point(field:vt.fileanalysis.HttpConversation.response_body_first_ten_bytes)
    pub response_body_first_ten_bytes: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:vt.fileanalysis.HttpConversation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HttpConversation {
    fn default() -> &'a HttpConversation {
        <HttpConversation as ::protobuf::Message>::default_instance()
    }
}

impl HttpConversation {
    pub fn new() -> HttpConversation {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "url",
            |m: &HttpConversation| { &m.url },
            |m: &mut HttpConversation| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "request_method",
            |m: &HttpConversation| { &m.request_method },
            |m: &mut HttpConversation| { &mut m.request_method },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "request_headers",
            |m: &HttpConversation| { &m.request_headers },
            |m: &mut HttpConversation| { &mut m.request_headers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "response_headers",
            |m: &HttpConversation| { &m.response_headers },
            |m: &mut HttpConversation| { &mut m.response_headers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "response_status_code",
            |m: &HttpConversation| { &m.response_status_code },
            |m: &mut HttpConversation| { &mut m.response_status_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "response_body_filetype",
            |m: &HttpConversation| { &m.response_body_filetype },
            |m: &mut HttpConversation| { &mut m.response_body_filetype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "response_body_first_ten_bytes",
            |m: &HttpConversation| { &m.response_body_first_ten_bytes },
            |m: &mut HttpConversation| { &mut m.response_body_first_ten_bytes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HttpConversation>(
            "HttpConversation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HttpConversation {
    const NAME: &'static str = "HttpConversation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.url = is.read_string()?;
                },
                16 => {
                    self.request_method = is.read_enum_or_unknown()?;
                },
                26 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.request_headers.insert(key, value);
                },
                34 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.response_headers.insert(key, value);
                },
                40 => {
                    self.response_status_code = is.read_int32()?;
                },
                48 => {
                    self.response_body_filetype = is.read_enum_or_unknown()?;
                },
                58 => {
                    self.response_body_first_ten_bytes = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.url);
        }
        if self.request_method != ::protobuf::EnumOrUnknown::new(http_conversation::RequestMethod::UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(2, self.request_method.value());
        }
        for (k, v) in &self.request_headers {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.response_headers {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if self.response_status_code != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.response_status_code);
        }
        if self.response_body_filetype != ::protobuf::EnumOrUnknown::new(super::filetypes::FileType::UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(6, self.response_body_filetype.value());
        }
        if !self.response_body_first_ten_bytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.response_body_first_ten_bytes);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.url.is_empty() {
            os.write_string(1, &self.url)?;
        }
        if self.request_method != ::protobuf::EnumOrUnknown::new(http_conversation::RequestMethod::UNKNOWN) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.request_method))?;
        }
        for (k, v) in &self.request_headers {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(26)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        for (k, v) in &self.response_headers {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(34)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if self.response_status_code != 0 {
            os.write_int32(5, self.response_status_code)?;
        }
        if self.response_body_filetype != ::protobuf::EnumOrUnknown::new(super::filetypes::FileType::UNKNOWN) {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&self.response_body_filetype))?;
        }
        if !self.response_body_first_ten_bytes.is_empty() {
            os.write_bytes(7, &self.response_body_first_ten_bytes)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HttpConversation {
        HttpConversation::new()
    }

    fn clear(&mut self) {
        self.url.clear();
        self.request_method = ::protobuf::EnumOrUnknown::new(http_conversation::RequestMethod::UNKNOWN);
        self.request_headers.clear();
        self.response_headers.clear();
        self.response_status_code = 0;
        self.response_body_filetype = ::protobuf::EnumOrUnknown::new(super::filetypes::FileType::UNKNOWN);
        self.response_body_first_ten_bytes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HttpConversation {
        static instance: ::protobuf::rt::Lazy<HttpConversation> = ::protobuf::rt::Lazy::new();
        instance.get(HttpConversation::new)
    }
}

impl ::protobuf::MessageFull for HttpConversation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HttpConversation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HttpConversation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HttpConversation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `HttpConversation`
pub mod http_conversation {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:vt.fileanalysis.HttpConversation.RequestMethod)
    pub enum RequestMethod {
        // @@protoc_insertion_point(enum_value:vt.fileanalysis.HttpConversation.RequestMethod.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:vt.fileanalysis.HttpConversation.RequestMethod.GET)
        GET = 1,
        // @@protoc_insertion_point(enum_value:vt.fileanalysis.HttpConversation.RequestMethod.HEAD)
        HEAD = 2,
        // @@protoc_insertion_point(enum_value:vt.fileanalysis.HttpConversation.RequestMethod.POST)
        POST = 3,
        // @@protoc_insertion_point(enum_value:vt.fileanalysis.HttpConversation.RequestMethod.PUT)
        PUT = 4,
        // @@protoc_insertion_point(enum_value:vt.fileanalysis.HttpConversation.RequestMethod.DELETE)
        DELETE = 5,
        // @@protoc_insertion_point(enum_value:vt.fileanalysis.HttpConversation.RequestMethod.TRACE)
        TRACE = 6,
        // @@protoc_insertion_point(enum_value:vt.fileanalysis.HttpConversation.RequestMethod.OPTIONS)
        OPTIONS = 7,
        // @@protoc_insertion_point(enum_value:vt.fileanalysis.HttpConversation.RequestMethod.CONNECT)
        CONNECT = 8,
        // @@protoc_insertion_point(enum_value:vt.fileanalysis.HttpConversation.RequestMethod.PATCH)
        PATCH = 9,
        // @@protoc_insertion_point(enum_value:vt.fileanalysis.HttpConversation.RequestMethod.PROPFIND)
        PROPFIND = 10,
        // @@protoc_insertion_point(enum_value:vt.fileanalysis.HttpConversation.RequestMethod.SETUP)
        SETUP = 11,
        // @@protoc_insertion_point(enum_value:vt.fileanalysis.HttpConversation.RequestMethod.UNLOCK)
        UNLOCK = 12,
    }

    impl ::protobuf::Enum for RequestMethod {
        const NAME: &'static str = "RequestMethod";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<RequestMethod> {
            match value {
                0 => ::std::option::Option::Some(RequestMethod::UNKNOWN),
                1 => ::std::option::Option::Some(RequestMethod::GET),
                2 => ::std::option::Option::Some(RequestMethod::HEAD),
                3 => ::std::option::Option::Some(RequestMethod::POST),
                4 => ::std::option::Option::Some(RequestMethod::PUT),
                5 => ::std::option::Option::Some(RequestMethod::DELETE),
                6 => ::std::option::Option::Some(RequestMethod::TRACE),
                7 => ::std::option::Option::Some(RequestMethod::OPTIONS),
                8 => ::std::option::Option::Some(RequestMethod::CONNECT),
                9 => ::std::option::Option::Some(RequestMethod::PATCH),
                10 => ::std::option::Option::Some(RequestMethod::PROPFIND),
                11 => ::std::option::Option::Some(RequestMethod::SETUP),
                12 => ::std::option::Option::Some(RequestMethod::UNLOCK),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<RequestMethod> {
            match str {
                "UNKNOWN" => ::std::option::Option::Some(RequestMethod::UNKNOWN),
                "GET" => ::std::option::Option::Some(RequestMethod::GET),
                "HEAD" => ::std::option::Option::Some(RequestMethod::HEAD),
                "POST" => ::std::option::Option::Some(RequestMethod::POST),
                "PUT" => ::std::option::Option::Some(RequestMethod::PUT),
                "DELETE" => ::std::option::Option::Some(RequestMethod::DELETE),
                "TRACE" => ::std::option::Option::Some(RequestMethod::TRACE),
                "OPTIONS" => ::std::option::Option::Some(RequestMethod::OPTIONS),
                "CONNECT" => ::std::option::Option::Some(RequestMethod::CONNECT),
                "PATCH" => ::std::option::Option::Some(RequestMethod::PATCH),
                "PROPFIND" => ::std::option::Option::Some(RequestMethod::PROPFIND),
                "SETUP" => ::std::option::Option::Some(RequestMethod::SETUP),
                "UNLOCK" => ::std::option::Option::Some(RequestMethod::UNLOCK),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [RequestMethod] = &[
            RequestMethod::UNKNOWN,
            RequestMethod::GET,
            RequestMethod::HEAD,
            RequestMethod::POST,
            RequestMethod::PUT,
            RequestMethod::DELETE,
            RequestMethod::TRACE,
            RequestMethod::OPTIONS,
            RequestMethod::CONNECT,
            RequestMethod::PATCH,
            RequestMethod::PROPFIND,
            RequestMethod::SETUP,
            RequestMethod::UNLOCK,
        ];
    }

    impl ::protobuf::EnumFull for RequestMethod {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("HttpConversation.RequestMethod").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for RequestMethod {
        fn default() -> Self {
            RequestMethod::UNKNOWN
        }
    }

    impl RequestMethod {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<RequestMethod>("HttpConversation.RequestMethod")
        }
    }
}

// @@protoc_insertion_point(message:vt.fileanalysis.DnsLookup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DnsLookup {
    // message fields
    // @@protoc_insertion_point(field:vt.fileanalysis.DnsLookup.hostname)
    pub hostname: ::std::string::String,
    // @@protoc_insertion_point(field:vt.fileanalysis.DnsLookup.resolved_ips)
    pub resolved_ips: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.DnsLookup.txt_records)
    pub txt_records: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:vt.fileanalysis.DnsLookup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DnsLookup {
    fn default() -> &'a DnsLookup {
        <DnsLookup as ::protobuf::Message>::default_instance()
    }
}

impl DnsLookup {
    pub fn new() -> DnsLookup {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hostname",
            |m: &DnsLookup| { &m.hostname },
            |m: &mut DnsLookup| { &mut m.hostname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "resolved_ips",
            |m: &DnsLookup| { &m.resolved_ips },
            |m: &mut DnsLookup| { &mut m.resolved_ips },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "txt_records",
            |m: &DnsLookup| { &m.txt_records },
            |m: &mut DnsLookup| { &mut m.txt_records },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DnsLookup>(
            "DnsLookup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DnsLookup {
    const NAME: &'static str = "DnsLookup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.hostname = is.read_string()?;
                },
                18 => {
                    self.resolved_ips.push(is.read_string()?);
                },
                26 => {
                    self.txt_records.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.hostname.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.hostname);
        }
        for value in &self.resolved_ips {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.txt_records {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.hostname.is_empty() {
            os.write_string(1, &self.hostname)?;
        }
        for v in &self.resolved_ips {
            os.write_string(2, &v)?;
        };
        for v in &self.txt_records {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DnsLookup {
        DnsLookup::new()
    }

    fn clear(&mut self) {
        self.hostname.clear();
        self.resolved_ips.clear();
        self.txt_records.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DnsLookup {
        static instance: DnsLookup = DnsLookup {
            hostname: ::std::string::String::new(),
            resolved_ips: ::std::vec::Vec::new(),
            txt_records: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DnsLookup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DnsLookup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DnsLookup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DnsLookup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:vt.fileanalysis.IpTraffic)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IpTraffic {
    // message fields
    // @@protoc_insertion_point(field:vt.fileanalysis.IpTraffic.destination_ip)
    pub destination_ip: ::std::string::String,
    // @@protoc_insertion_point(field:vt.fileanalysis.IpTraffic.destination_port)
    pub destination_port: i32,
    // @@protoc_insertion_point(field:vt.fileanalysis.IpTraffic.transport_layer_protocol)
    pub transport_layer_protocol: ::protobuf::EnumOrUnknown<ip_traffic::TransportLayerProtocol>,
    // @@protoc_insertion_point(field:vt.fileanalysis.IpTraffic.destination_ip_asn)
    pub destination_ip_asn: i64,
    // @@protoc_insertion_point(field:vt.fileanalysis.IpTraffic.destination_ip_as_int)
    pub destination_ip_as_int: i64,
    // special fields
    // @@protoc_insertion_point(special_field:vt.fileanalysis.IpTraffic.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IpTraffic {
    fn default() -> &'a IpTraffic {
        <IpTraffic as ::protobuf::Message>::default_instance()
    }
}

impl IpTraffic {
    pub fn new() -> IpTraffic {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "destination_ip",
            |m: &IpTraffic| { &m.destination_ip },
            |m: &mut IpTraffic| { &mut m.destination_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "destination_port",
            |m: &IpTraffic| { &m.destination_port },
            |m: &mut IpTraffic| { &mut m.destination_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "transport_layer_protocol",
            |m: &IpTraffic| { &m.transport_layer_protocol },
            |m: &mut IpTraffic| { &mut m.transport_layer_protocol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "destination_ip_asn",
            |m: &IpTraffic| { &m.destination_ip_asn },
            |m: &mut IpTraffic| { &mut m.destination_ip_asn },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "destination_ip_as_int",
            |m: &IpTraffic| { &m.destination_ip_as_int },
            |m: &mut IpTraffic| { &mut m.destination_ip_as_int },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IpTraffic>(
            "IpTraffic",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IpTraffic {
    const NAME: &'static str = "IpTraffic";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.destination_ip = is.read_string()?;
                },
                16 => {
                    self.destination_port = is.read_int32()?;
                },
                24 => {
                    self.transport_layer_protocol = is.read_enum_or_unknown()?;
                },
                32 => {
                    self.destination_ip_asn = is.read_int64()?;
                },
                40 => {
                    self.destination_ip_as_int = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.destination_ip.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.destination_ip);
        }
        if self.destination_port != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.destination_port);
        }
        if self.transport_layer_protocol != ::protobuf::EnumOrUnknown::new(ip_traffic::TransportLayerProtocol::UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(3, self.transport_layer_protocol.value());
        }
        if self.destination_ip_asn != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.destination_ip_asn);
        }
        if self.destination_ip_as_int != 0 {
            my_size += ::protobuf::rt::int64_size(5, self.destination_ip_as_int);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.destination_ip.is_empty() {
            os.write_string(1, &self.destination_ip)?;
        }
        if self.destination_port != 0 {
            os.write_int32(2, self.destination_port)?;
        }
        if self.transport_layer_protocol != ::protobuf::EnumOrUnknown::new(ip_traffic::TransportLayerProtocol::UNKNOWN) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.transport_layer_protocol))?;
        }
        if self.destination_ip_asn != 0 {
            os.write_int64(4, self.destination_ip_asn)?;
        }
        if self.destination_ip_as_int != 0 {
            os.write_int64(5, self.destination_ip_as_int)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IpTraffic {
        IpTraffic::new()
    }

    fn clear(&mut self) {
        self.destination_ip.clear();
        self.destination_port = 0;
        self.transport_layer_protocol = ::protobuf::EnumOrUnknown::new(ip_traffic::TransportLayerProtocol::UNKNOWN);
        self.destination_ip_asn = 0;
        self.destination_ip_as_int = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IpTraffic {
        static instance: IpTraffic = IpTraffic {
            destination_ip: ::std::string::String::new(),
            destination_port: 0,
            transport_layer_protocol: ::protobuf::EnumOrUnknown::from_i32(0),
            destination_ip_asn: 0,
            destination_ip_as_int: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IpTraffic {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IpTraffic").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IpTraffic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IpTraffic {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `IpTraffic`
pub mod ip_traffic {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:vt.fileanalysis.IpTraffic.TransportLayerProtocol)
    pub enum TransportLayerProtocol {
        // @@protoc_insertion_point(enum_value:vt.fileanalysis.IpTraffic.TransportLayerProtocol.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:vt.fileanalysis.IpTraffic.TransportLayerProtocol.ICMP)
        ICMP = 1,
        // @@protoc_insertion_point(enum_value:vt.fileanalysis.IpTraffic.TransportLayerProtocol.IGMP)
        IGMP = 2,
        // @@protoc_insertion_point(enum_value:vt.fileanalysis.IpTraffic.TransportLayerProtocol.TCP)
        TCP = 6,
        // @@protoc_insertion_point(enum_value:vt.fileanalysis.IpTraffic.TransportLayerProtocol.UDP)
        UDP = 17,
        // @@protoc_insertion_point(enum_value:vt.fileanalysis.IpTraffic.TransportLayerProtocol.ESP)
        ESP = 50,
        // @@protoc_insertion_point(enum_value:vt.fileanalysis.IpTraffic.TransportLayerProtocol.AH)
        AH = 51,
        // @@protoc_insertion_point(enum_value:vt.fileanalysis.IpTraffic.TransportLayerProtocol.L2TP)
        L2TP = 115,
        // @@protoc_insertion_point(enum_value:vt.fileanalysis.IpTraffic.TransportLayerProtocol.SCTP)
        SCTP = 132,
    }

    impl ::protobuf::Enum for TransportLayerProtocol {
        const NAME: &'static str = "TransportLayerProtocol";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<TransportLayerProtocol> {
            match value {
                0 => ::std::option::Option::Some(TransportLayerProtocol::UNKNOWN),
                1 => ::std::option::Option::Some(TransportLayerProtocol::ICMP),
                2 => ::std::option::Option::Some(TransportLayerProtocol::IGMP),
                6 => ::std::option::Option::Some(TransportLayerProtocol::TCP),
                17 => ::std::option::Option::Some(TransportLayerProtocol::UDP),
                50 => ::std::option::Option::Some(TransportLayerProtocol::ESP),
                51 => ::std::option::Option::Some(TransportLayerProtocol::AH),
                115 => ::std::option::Option::Some(TransportLayerProtocol::L2TP),
                132 => ::std::option::Option::Some(TransportLayerProtocol::SCTP),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<TransportLayerProtocol> {
            match str {
                "UNKNOWN" => ::std::option::Option::Some(TransportLayerProtocol::UNKNOWN),
                "ICMP" => ::std::option::Option::Some(TransportLayerProtocol::ICMP),
                "IGMP" => ::std::option::Option::Some(TransportLayerProtocol::IGMP),
                "TCP" => ::std::option::Option::Some(TransportLayerProtocol::TCP),
                "UDP" => ::std::option::Option::Some(TransportLayerProtocol::UDP),
                "ESP" => ::std::option::Option::Some(TransportLayerProtocol::ESP),
                "AH" => ::std::option::Option::Some(TransportLayerProtocol::AH),
                "L2TP" => ::std::option::Option::Some(TransportLayerProtocol::L2TP),
                "SCTP" => ::std::option::Option::Some(TransportLayerProtocol::SCTP),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [TransportLayerProtocol] = &[
            TransportLayerProtocol::UNKNOWN,
            TransportLayerProtocol::ICMP,
            TransportLayerProtocol::IGMP,
            TransportLayerProtocol::TCP,
            TransportLayerProtocol::UDP,
            TransportLayerProtocol::ESP,
            TransportLayerProtocol::AH,
            TransportLayerProtocol::L2TP,
            TransportLayerProtocol::SCTP,
        ];
    }

    impl ::protobuf::EnumFull for TransportLayerProtocol {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("IpTraffic.TransportLayerProtocol").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                TransportLayerProtocol::UNKNOWN => 0,
                TransportLayerProtocol::ICMP => 1,
                TransportLayerProtocol::IGMP => 2,
                TransportLayerProtocol::TCP => 3,
                TransportLayerProtocol::UDP => 4,
                TransportLayerProtocol::ESP => 5,
                TransportLayerProtocol::AH => 6,
                TransportLayerProtocol::L2TP => 7,
                TransportLayerProtocol::SCTP => 8,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for TransportLayerProtocol {
        fn default() -> Self {
            TransportLayerProtocol::UNKNOWN
        }
    }

    impl TransportLayerProtocol {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TransportLayerProtocol>("IpTraffic.TransportLayerProtocol")
        }
    }
}

// @@protoc_insertion_point(message:vt.fileanalysis.SmtpConversation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SmtpConversation {
    // message fields
    // @@protoc_insertion_point(field:vt.fileanalysis.SmtpConversation.hostname)
    pub hostname: ::std::string::String,
    // @@protoc_insertion_point(field:vt.fileanalysis.SmtpConversation.destination_ip)
    pub destination_ip: ::std::string::String,
    // @@protoc_insertion_point(field:vt.fileanalysis.SmtpConversation.destination_port)
    pub destination_port: u32,
    // @@protoc_insertion_point(field:vt.fileanalysis.SmtpConversation.smtp_from)
    pub smtp_from: ::std::string::String,
    // @@protoc_insertion_point(field:vt.fileanalysis.SmtpConversation.smtp_to)
    pub smtp_to: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.SmtpConversation.message_from)
    pub message_from: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.SmtpConversation.message_to)
    pub message_to: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.SmtpConversation.message_cc)
    pub message_cc: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.SmtpConversation.message_bcc)
    pub message_bcc: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.SmtpConversation.timestamp)
    pub timestamp: ::std::string::String,
    // @@protoc_insertion_point(field:vt.fileanalysis.SmtpConversation.subject)
    pub subject: ::std::string::String,
    // @@protoc_insertion_point(field:vt.fileanalysis.SmtpConversation.html_body)
    pub html_body: ::std::string::String,
    // @@protoc_insertion_point(field:vt.fileanalysis.SmtpConversation.txt_body)
    pub txt_body: ::std::string::String,
    // @@protoc_insertion_point(field:vt.fileanalysis.SmtpConversation.auth_user)
    pub auth_user: ::std::string::String,
    // @@protoc_insertion_point(field:vt.fileanalysis.SmtpConversation.auth_pass)
    pub auth_pass: ::std::string::String,
    // @@protoc_insertion_point(field:vt.fileanalysis.SmtpConversation.headers)
    pub headers: ::std::vec::Vec<KeyValue>,
    // @@protoc_insertion_point(field:vt.fileanalysis.SmtpConversation.attachments)
    pub attachments: ::std::vec::Vec<DroppedFile>,
    // @@protoc_insertion_point(field:vt.fileanalysis.SmtpConversation.x_mailer)
    pub x_mailer: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:vt.fileanalysis.SmtpConversation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SmtpConversation {
    fn default() -> &'a SmtpConversation {
        <SmtpConversation as ::protobuf::Message>::default_instance()
    }
}

impl SmtpConversation {
    pub fn new() -> SmtpConversation {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(18);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hostname",
            |m: &SmtpConversation| { &m.hostname },
            |m: &mut SmtpConversation| { &mut m.hostname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "destination_ip",
            |m: &SmtpConversation| { &m.destination_ip },
            |m: &mut SmtpConversation| { &mut m.destination_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "destination_port",
            |m: &SmtpConversation| { &m.destination_port },
            |m: &mut SmtpConversation| { &mut m.destination_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "smtp_from",
            |m: &SmtpConversation| { &m.smtp_from },
            |m: &mut SmtpConversation| { &mut m.smtp_from },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "smtp_to",
            |m: &SmtpConversation| { &m.smtp_to },
            |m: &mut SmtpConversation| { &mut m.smtp_to },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "message_from",
            |m: &SmtpConversation| { &m.message_from },
            |m: &mut SmtpConversation| { &mut m.message_from },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "message_to",
            |m: &SmtpConversation| { &m.message_to },
            |m: &mut SmtpConversation| { &mut m.message_to },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "message_cc",
            |m: &SmtpConversation| { &m.message_cc },
            |m: &mut SmtpConversation| { &mut m.message_cc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "message_bcc",
            |m: &SmtpConversation| { &m.message_bcc },
            |m: &mut SmtpConversation| { &mut m.message_bcc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timestamp",
            |m: &SmtpConversation| { &m.timestamp },
            |m: &mut SmtpConversation| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "subject",
            |m: &SmtpConversation| { &m.subject },
            |m: &mut SmtpConversation| { &mut m.subject },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "html_body",
            |m: &SmtpConversation| { &m.html_body },
            |m: &mut SmtpConversation| { &mut m.html_body },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "txt_body",
            |m: &SmtpConversation| { &m.txt_body },
            |m: &mut SmtpConversation| { &mut m.txt_body },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "auth_user",
            |m: &SmtpConversation| { &m.auth_user },
            |m: &mut SmtpConversation| { &mut m.auth_user },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "auth_pass",
            |m: &SmtpConversation| { &m.auth_pass },
            |m: &mut SmtpConversation| { &mut m.auth_pass },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "headers",
            |m: &SmtpConversation| { &m.headers },
            |m: &mut SmtpConversation| { &mut m.headers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "attachments",
            |m: &SmtpConversation| { &m.attachments },
            |m: &mut SmtpConversation| { &mut m.attachments },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "x_mailer",
            |m: &SmtpConversation| { &m.x_mailer },
            |m: &mut SmtpConversation| { &mut m.x_mailer },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SmtpConversation>(
            "SmtpConversation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SmtpConversation {
    const NAME: &'static str = "SmtpConversation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.hostname = is.read_string()?;
                },
                18 => {
                    self.destination_ip = is.read_string()?;
                },
                24 => {
                    self.destination_port = is.read_uint32()?;
                },
                34 => {
                    self.smtp_from = is.read_string()?;
                },
                42 => {
                    self.smtp_to.push(is.read_string()?);
                },
                50 => {
                    self.message_from.push(is.read_string()?);
                },
                58 => {
                    self.message_to.push(is.read_string()?);
                },
                66 => {
                    self.message_cc.push(is.read_string()?);
                },
                74 => {
                    self.message_bcc.push(is.read_string()?);
                },
                82 => {
                    self.timestamp = is.read_string()?;
                },
                90 => {
                    self.subject = is.read_string()?;
                },
                98 => {
                    self.html_body = is.read_string()?;
                },
                106 => {
                    self.txt_body = is.read_string()?;
                },
                114 => {
                    self.auth_user = is.read_string()?;
                },
                122 => {
                    self.auth_pass = is.read_string()?;
                },
                130 => {
                    self.headers.push(is.read_message()?);
                },
                138 => {
                    self.attachments.push(is.read_message()?);
                },
                146 => {
                    self.x_mailer = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.hostname.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.hostname);
        }
        if !self.destination_ip.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.destination_ip);
        }
        if self.destination_port != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.destination_port);
        }
        if !self.smtp_from.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.smtp_from);
        }
        for value in &self.smtp_to {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.message_from {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in &self.message_to {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        for value in &self.message_cc {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        for value in &self.message_bcc {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        if !self.timestamp.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.timestamp);
        }
        if !self.subject.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.subject);
        }
        if !self.html_body.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.html_body);
        }
        if !self.txt_body.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.txt_body);
        }
        if !self.auth_user.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.auth_user);
        }
        if !self.auth_pass.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.auth_pass);
        }
        for value in &self.headers {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.attachments {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.x_mailer.is_empty() {
            my_size += ::protobuf::rt::string_size(18, &self.x_mailer);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.hostname.is_empty() {
            os.write_string(1, &self.hostname)?;
        }
        if !self.destination_ip.is_empty() {
            os.write_string(2, &self.destination_ip)?;
        }
        if self.destination_port != 0 {
            os.write_uint32(3, self.destination_port)?;
        }
        if !self.smtp_from.is_empty() {
            os.write_string(4, &self.smtp_from)?;
        }
        for v in &self.smtp_to {
            os.write_string(5, &v)?;
        };
        for v in &self.message_from {
            os.write_string(6, &v)?;
        };
        for v in &self.message_to {
            os.write_string(7, &v)?;
        };
        for v in &self.message_cc {
            os.write_string(8, &v)?;
        };
        for v in &self.message_bcc {
            os.write_string(9, &v)?;
        };
        if !self.timestamp.is_empty() {
            os.write_string(10, &self.timestamp)?;
        }
        if !self.subject.is_empty() {
            os.write_string(11, &self.subject)?;
        }
        if !self.html_body.is_empty() {
            os.write_string(12, &self.html_body)?;
        }
        if !self.txt_body.is_empty() {
            os.write_string(13, &self.txt_body)?;
        }
        if !self.auth_user.is_empty() {
            os.write_string(14, &self.auth_user)?;
        }
        if !self.auth_pass.is_empty() {
            os.write_string(15, &self.auth_pass)?;
        }
        for v in &self.headers {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        };
        for v in &self.attachments {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        };
        if !self.x_mailer.is_empty() {
            os.write_string(18, &self.x_mailer)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SmtpConversation {
        SmtpConversation::new()
    }

    fn clear(&mut self) {
        self.hostname.clear();
        self.destination_ip.clear();
        self.destination_port = 0;
        self.smtp_from.clear();
        self.smtp_to.clear();
        self.message_from.clear();
        self.message_to.clear();
        self.message_cc.clear();
        self.message_bcc.clear();
        self.timestamp.clear();
        self.subject.clear();
        self.html_body.clear();
        self.txt_body.clear();
        self.auth_user.clear();
        self.auth_pass.clear();
        self.headers.clear();
        self.attachments.clear();
        self.x_mailer.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SmtpConversation {
        static instance: SmtpConversation = SmtpConversation {
            hostname: ::std::string::String::new(),
            destination_ip: ::std::string::String::new(),
            destination_port: 0,
            smtp_from: ::std::string::String::new(),
            smtp_to: ::std::vec::Vec::new(),
            message_from: ::std::vec::Vec::new(),
            message_to: ::std::vec::Vec::new(),
            message_cc: ::std::vec::Vec::new(),
            message_bcc: ::std::vec::Vec::new(),
            timestamp: ::std::string::String::new(),
            subject: ::std::string::String::new(),
            html_body: ::std::string::String::new(),
            txt_body: ::std::string::String::new(),
            auth_user: ::std::string::String::new(),
            auth_pass: ::std::string::String::new(),
            headers: ::std::vec::Vec::new(),
            attachments: ::std::vec::Vec::new(),
            x_mailer: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SmtpConversation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SmtpConversation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SmtpConversation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SmtpConversation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:vt.fileanalysis.Sms)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Sms {
    // message fields
    // @@protoc_insertion_point(field:vt.fileanalysis.Sms.destination)
    pub destination: ::std::string::String,
    // @@protoc_insertion_point(field:vt.fileanalysis.Sms.body)
    pub body: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:vt.fileanalysis.Sms.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Sms {
    fn default() -> &'a Sms {
        <Sms as ::protobuf::Message>::default_instance()
    }
}

impl Sms {
    pub fn new() -> Sms {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "destination",
            |m: &Sms| { &m.destination },
            |m: &mut Sms| { &mut m.destination },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "body",
            |m: &Sms| { &m.body },
            |m: &mut Sms| { &mut m.body },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Sms>(
            "Sms",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Sms {
    const NAME: &'static str = "Sms";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.destination = is.read_string()?;
                },
                18 => {
                    self.body = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.destination.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.destination);
        }
        if !self.body.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.body);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.destination.is_empty() {
            os.write_string(1, &self.destination)?;
        }
        if !self.body.is_empty() {
            os.write_string(2, &self.body)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Sms {
        Sms::new()
    }

    fn clear(&mut self) {
        self.destination.clear();
        self.body.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Sms {
        static instance: Sms = Sms {
            destination: ::std::string::String::new(),
            body: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Sms {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Sms").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Sms {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Sms {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:vt.fileanalysis.SignatureMatch)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SignatureMatch {
    // message fields
    // @@protoc_insertion_point(field:vt.fileanalysis.SignatureMatch.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:vt.fileanalysis.SignatureMatch.format)
    pub format: ::protobuf::EnumOrUnknown<signature_match::SignatureFormat>,
    // @@protoc_insertion_point(field:vt.fileanalysis.SignatureMatch.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:vt.fileanalysis.SignatureMatch.description)
    pub description: ::std::string::String,
    // @@protoc_insertion_point(field:vt.fileanalysis.SignatureMatch.authors)
    pub authors: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.SignatureMatch.events)
    pub events: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.SignatureMatch.match_data)
    pub match_data: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.SignatureMatch.rule_src)
    pub rule_src: ::std::string::String,
    // @@protoc_insertion_point(field:vt.fileanalysis.SignatureMatch.severity)
    pub severity: ::protobuf::EnumOrUnknown<ImpactSeverity>,
    // special fields
    // @@protoc_insertion_point(special_field:vt.fileanalysis.SignatureMatch.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SignatureMatch {
    fn default() -> &'a SignatureMatch {
        <SignatureMatch as ::protobuf::Message>::default_instance()
    }
}

impl SignatureMatch {
    pub fn new() -> SignatureMatch {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &SignatureMatch| { &m.id },
            |m: &mut SignatureMatch| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "format",
            |m: &SignatureMatch| { &m.format },
            |m: &mut SignatureMatch| { &mut m.format },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &SignatureMatch| { &m.name },
            |m: &mut SignatureMatch| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &SignatureMatch| { &m.description },
            |m: &mut SignatureMatch| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "authors",
            |m: &SignatureMatch| { &m.authors },
            |m: &mut SignatureMatch| { &mut m.authors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "events",
            |m: &SignatureMatch| { &m.events },
            |m: &mut SignatureMatch| { &mut m.events },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "match_data",
            |m: &SignatureMatch| { &m.match_data },
            |m: &mut SignatureMatch| { &mut m.match_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rule_src",
            |m: &SignatureMatch| { &m.rule_src },
            |m: &mut SignatureMatch| { &mut m.rule_src },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "severity",
            |m: &SignatureMatch| { &m.severity },
            |m: &mut SignatureMatch| { &mut m.severity },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SignatureMatch>(
            "SignatureMatch",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SignatureMatch {
    const NAME: &'static str = "SignatureMatch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                16 => {
                    self.format = is.read_enum_or_unknown()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.description = is.read_string()?;
                },
                42 => {
                    self.authors.push(is.read_string()?);
                },
                50 => {
                    self.events.push(is.read_string()?);
                },
                58 => {
                    self.match_data.push(is.read_string()?);
                },
                66 => {
                    self.rule_src = is.read_string()?;
                },
                72 => {
                    self.severity = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.format != ::protobuf::EnumOrUnknown::new(signature_match::SignatureFormat::SIG_FORMAT_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(2, self.format.value());
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.description);
        }
        for value in &self.authors {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.events {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in &self.match_data {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if !self.rule_src.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.rule_src);
        }
        if self.severity != ::protobuf::EnumOrUnknown::new(ImpactSeverity::IMPACT_SEVERITY_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(9, self.severity.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.format != ::protobuf::EnumOrUnknown::new(signature_match::SignatureFormat::SIG_FORMAT_UNKNOWN) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.format))?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(4, &self.description)?;
        }
        for v in &self.authors {
            os.write_string(5, &v)?;
        };
        for v in &self.events {
            os.write_string(6, &v)?;
        };
        for v in &self.match_data {
            os.write_string(7, &v)?;
        };
        if !self.rule_src.is_empty() {
            os.write_string(8, &self.rule_src)?;
        }
        if self.severity != ::protobuf::EnumOrUnknown::new(ImpactSeverity::IMPACT_SEVERITY_UNKNOWN) {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&self.severity))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SignatureMatch {
        SignatureMatch::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.format = ::protobuf::EnumOrUnknown::new(signature_match::SignatureFormat::SIG_FORMAT_UNKNOWN);
        self.name.clear();
        self.description.clear();
        self.authors.clear();
        self.events.clear();
        self.match_data.clear();
        self.rule_src.clear();
        self.severity = ::protobuf::EnumOrUnknown::new(ImpactSeverity::IMPACT_SEVERITY_UNKNOWN);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SignatureMatch {
        static instance: SignatureMatch = SignatureMatch {
            id: ::std::string::String::new(),
            format: ::protobuf::EnumOrUnknown::from_i32(0),
            name: ::std::string::String::new(),
            description: ::std::string::String::new(),
            authors: ::std::vec::Vec::new(),
            events: ::std::vec::Vec::new(),
            match_data: ::std::vec::Vec::new(),
            rule_src: ::std::string::String::new(),
            severity: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SignatureMatch {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SignatureMatch").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SignatureMatch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignatureMatch {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SignatureMatch`
pub mod signature_match {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:vt.fileanalysis.SignatureMatch.SignatureFormat)
    pub enum SignatureFormat {
        // @@protoc_insertion_point(enum_value:vt.fileanalysis.SignatureMatch.SignatureFormat.SIG_FORMAT_UNKNOWN)
        SIG_FORMAT_UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:vt.fileanalysis.SignatureMatch.SignatureFormat.SIG_FORMAT_YARA)
        SIG_FORMAT_YARA = 1,
        // @@protoc_insertion_point(enum_value:vt.fileanalysis.SignatureMatch.SignatureFormat.SIG_FORMAT_SIGMA)
        SIG_FORMAT_SIGMA = 2,
        // @@protoc_insertion_point(enum_value:vt.fileanalysis.SignatureMatch.SignatureFormat.SIG_FORMAT_CAPA)
        SIG_FORMAT_CAPA = 3,
        // @@protoc_insertion_point(enum_value:vt.fileanalysis.SignatureMatch.SignatureFormat.SIG_FORMAT_OPENIOC)
        SIG_FORMAT_OPENIOC = 4,
        // @@protoc_insertion_point(enum_value:vt.fileanalysis.SignatureMatch.SignatureFormat.SIG_FORMAT_KEYWORD)
        SIG_FORMAT_KEYWORD = 5,
    }

    impl ::protobuf::Enum for SignatureFormat {
        const NAME: &'static str = "SignatureFormat";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<SignatureFormat> {
            match value {
                0 => ::std::option::Option::Some(SignatureFormat::SIG_FORMAT_UNKNOWN),
                1 => ::std::option::Option::Some(SignatureFormat::SIG_FORMAT_YARA),
                2 => ::std::option::Option::Some(SignatureFormat::SIG_FORMAT_SIGMA),
                3 => ::std::option::Option::Some(SignatureFormat::SIG_FORMAT_CAPA),
                4 => ::std::option::Option::Some(SignatureFormat::SIG_FORMAT_OPENIOC),
                5 => ::std::option::Option::Some(SignatureFormat::SIG_FORMAT_KEYWORD),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<SignatureFormat> {
            match str {
                "SIG_FORMAT_UNKNOWN" => ::std::option::Option::Some(SignatureFormat::SIG_FORMAT_UNKNOWN),
                "SIG_FORMAT_YARA" => ::std::option::Option::Some(SignatureFormat::SIG_FORMAT_YARA),
                "SIG_FORMAT_SIGMA" => ::std::option::Option::Some(SignatureFormat::SIG_FORMAT_SIGMA),
                "SIG_FORMAT_CAPA" => ::std::option::Option::Some(SignatureFormat::SIG_FORMAT_CAPA),
                "SIG_FORMAT_OPENIOC" => ::std::option::Option::Some(SignatureFormat::SIG_FORMAT_OPENIOC),
                "SIG_FORMAT_KEYWORD" => ::std::option::Option::Some(SignatureFormat::SIG_FORMAT_KEYWORD),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [SignatureFormat] = &[
            SignatureFormat::SIG_FORMAT_UNKNOWN,
            SignatureFormat::SIG_FORMAT_YARA,
            SignatureFormat::SIG_FORMAT_SIGMA,
            SignatureFormat::SIG_FORMAT_CAPA,
            SignatureFormat::SIG_FORMAT_OPENIOC,
            SignatureFormat::SIG_FORMAT_KEYWORD,
        ];
    }

    impl ::protobuf::EnumFull for SignatureFormat {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("SignatureMatch.SignatureFormat").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for SignatureFormat {
        fn default() -> Self {
            SignatureFormat::SIG_FORMAT_UNKNOWN
        }
    }

    impl SignatureFormat {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SignatureFormat>("SignatureMatch.SignatureFormat")
        }
    }
}

// @@protoc_insertion_point(message:vt.fileanalysis.MitreAttackTechnique)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MitreAttackTechnique {
    // message fields
    // @@protoc_insertion_point(field:vt.fileanalysis.MitreAttackTechnique.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:vt.fileanalysis.MitreAttackTechnique.severity)
    pub severity: ::protobuf::EnumOrUnknown<ImpactSeverity>,
    // @@protoc_insertion_point(field:vt.fileanalysis.MitreAttackTechnique.signature_description)
    pub signature_description: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:vt.fileanalysis.MitreAttackTechnique.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MitreAttackTechnique {
    fn default() -> &'a MitreAttackTechnique {
        <MitreAttackTechnique as ::protobuf::Message>::default_instance()
    }
}

impl MitreAttackTechnique {
    pub fn new() -> MitreAttackTechnique {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &MitreAttackTechnique| { &m.id },
            |m: &mut MitreAttackTechnique| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "severity",
            |m: &MitreAttackTechnique| { &m.severity },
            |m: &mut MitreAttackTechnique| { &mut m.severity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "signature_description",
            |m: &MitreAttackTechnique| { &m.signature_description },
            |m: &mut MitreAttackTechnique| { &mut m.signature_description },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MitreAttackTechnique>(
            "MitreAttackTechnique",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MitreAttackTechnique {
    const NAME: &'static str = "MitreAttackTechnique";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                16 => {
                    self.severity = is.read_enum_or_unknown()?;
                },
                26 => {
                    self.signature_description = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.severity != ::protobuf::EnumOrUnknown::new(ImpactSeverity::IMPACT_SEVERITY_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(2, self.severity.value());
        }
        if !self.signature_description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.signature_description);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.severity != ::protobuf::EnumOrUnknown::new(ImpactSeverity::IMPACT_SEVERITY_UNKNOWN) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.severity))?;
        }
        if !self.signature_description.is_empty() {
            os.write_string(3, &self.signature_description)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MitreAttackTechnique {
        MitreAttackTechnique::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.severity = ::protobuf::EnumOrUnknown::new(ImpactSeverity::IMPACT_SEVERITY_UNKNOWN);
        self.signature_description.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MitreAttackTechnique {
        static instance: MitreAttackTechnique = MitreAttackTechnique {
            id: ::std::string::String::new(),
            severity: ::protobuf::EnumOrUnknown::from_i32(0),
            signature_description: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MitreAttackTechnique {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MitreAttackTechnique").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MitreAttackTechnique {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MitreAttackTechnique {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:vt.fileanalysis.MalwareBehaviorCatalog)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MalwareBehaviorCatalog {
    // message fields
    // @@protoc_insertion_point(field:vt.fileanalysis.MalwareBehaviorCatalog.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:vt.fileanalysis.MalwareBehaviorCatalog.objective)
    pub objective: ::std::string::String,
    // @@protoc_insertion_point(field:vt.fileanalysis.MalwareBehaviorCatalog.behavior)
    pub behavior: ::std::string::String,
    // @@protoc_insertion_point(field:vt.fileanalysis.MalwareBehaviorCatalog.method)
    pub method: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:vt.fileanalysis.MalwareBehaviorCatalog.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MalwareBehaviorCatalog {
    fn default() -> &'a MalwareBehaviorCatalog {
        <MalwareBehaviorCatalog as ::protobuf::Message>::default_instance()
    }
}

impl MalwareBehaviorCatalog {
    pub fn new() -> MalwareBehaviorCatalog {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &MalwareBehaviorCatalog| { &m.id },
            |m: &mut MalwareBehaviorCatalog| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "objective",
            |m: &MalwareBehaviorCatalog| { &m.objective },
            |m: &mut MalwareBehaviorCatalog| { &mut m.objective },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "behavior",
            |m: &MalwareBehaviorCatalog| { &m.behavior },
            |m: &mut MalwareBehaviorCatalog| { &mut m.behavior },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "method",
            |m: &MalwareBehaviorCatalog| { &m.method },
            |m: &mut MalwareBehaviorCatalog| { &mut m.method },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MalwareBehaviorCatalog>(
            "MalwareBehaviorCatalog",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MalwareBehaviorCatalog {
    const NAME: &'static str = "MalwareBehaviorCatalog";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.objective = is.read_string()?;
                },
                26 => {
                    self.behavior = is.read_string()?;
                },
                34 => {
                    self.method = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.objective.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.objective);
        }
        if !self.behavior.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.behavior);
        }
        if !self.method.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.method);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.objective.is_empty() {
            os.write_string(2, &self.objective)?;
        }
        if !self.behavior.is_empty() {
            os.write_string(3, &self.behavior)?;
        }
        if !self.method.is_empty() {
            os.write_string(4, &self.method)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MalwareBehaviorCatalog {
        MalwareBehaviorCatalog::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.objective.clear();
        self.behavior.clear();
        self.method.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MalwareBehaviorCatalog {
        static instance: MalwareBehaviorCatalog = MalwareBehaviorCatalog {
            id: ::std::string::String::new(),
            objective: ::std::string::String::new(),
            behavior: ::std::string::String::new(),
            method: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MalwareBehaviorCatalog {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MalwareBehaviorCatalog").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MalwareBehaviorCatalog {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MalwareBehaviorCatalog {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:vt.fileanalysis.ProcessItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProcessItem {
    // message fields
    // @@protoc_insertion_point(field:vt.fileanalysis.ProcessItem.process_id)
    pub process_id: ::std::string::String,
    // @@protoc_insertion_point(field:vt.fileanalysis.ProcessItem.parent_process_id)
    pub parent_process_id: ::std::string::String,
    // @@protoc_insertion_point(field:vt.fileanalysis.ProcessItem.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:vt.fileanalysis.ProcessItem.start_time)
    pub start_time: u64,
    // @@protoc_insertion_point(field:vt.fileanalysis.ProcessItem.termination_time)
    pub termination_time: u64,
    // @@protoc_insertion_point(field:vt.fileanalysis.ProcessItem.files_opened)
    pub files_opened: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.ProcessItem.files_written)
    pub files_written: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.ProcessItem.files_deleted)
    pub files_deleted: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:vt.fileanalysis.ProcessItem.files_copied)
    pub files_copied: ::std::vec::Vec<FileCopy>,
    // special fields
    // @@protoc_insertion_point(special_field:vt.fileanalysis.ProcessItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProcessItem {
    fn default() -> &'a ProcessItem {
        <ProcessItem as ::protobuf::Message>::default_instance()
    }
}

impl ProcessItem {
    pub fn new() -> ProcessItem {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "process_id",
            |m: &ProcessItem| { &m.process_id },
            |m: &mut ProcessItem| { &mut m.process_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "parent_process_id",
            |m: &ProcessItem| { &m.parent_process_id },
            |m: &mut ProcessItem| { &mut m.parent_process_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ProcessItem| { &m.name },
            |m: &mut ProcessItem| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "start_time",
            |m: &ProcessItem| { &m.start_time },
            |m: &mut ProcessItem| { &mut m.start_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "termination_time",
            |m: &ProcessItem| { &m.termination_time },
            |m: &mut ProcessItem| { &mut m.termination_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "files_opened",
            |m: &ProcessItem| { &m.files_opened },
            |m: &mut ProcessItem| { &mut m.files_opened },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "files_written",
            |m: &ProcessItem| { &m.files_written },
            |m: &mut ProcessItem| { &mut m.files_written },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "files_deleted",
            |m: &ProcessItem| { &m.files_deleted },
            |m: &mut ProcessItem| { &mut m.files_deleted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "files_copied",
            |m: &ProcessItem| { &m.files_copied },
            |m: &mut ProcessItem| { &mut m.files_copied },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProcessItem>(
            "ProcessItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProcessItem {
    const NAME: &'static str = "ProcessItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.process_id = is.read_string()?;
                },
                18 => {
                    self.parent_process_id = is.read_string()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                32 => {
                    self.start_time = is.read_uint64()?;
                },
                40 => {
                    self.termination_time = is.read_uint64()?;
                },
                50 => {
                    self.files_opened.push(is.read_string()?);
                },
                58 => {
                    self.files_written.push(is.read_string()?);
                },
                66 => {
                    self.files_deleted.push(is.read_string()?);
                },
                74 => {
                    self.files_copied.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.process_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.process_id);
        }
        if !self.parent_process_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.parent_process_id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if self.start_time != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.start_time);
        }
        if self.termination_time != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.termination_time);
        }
        for value in &self.files_opened {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in &self.files_written {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        for value in &self.files_deleted {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        for value in &self.files_copied {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.process_id.is_empty() {
            os.write_string(1, &self.process_id)?;
        }
        if !self.parent_process_id.is_empty() {
            os.write_string(2, &self.parent_process_id)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if self.start_time != 0 {
            os.write_uint64(4, self.start_time)?;
        }
        if self.termination_time != 0 {
            os.write_uint64(5, self.termination_time)?;
        }
        for v in &self.files_opened {
            os.write_string(6, &v)?;
        };
        for v in &self.files_written {
            os.write_string(7, &v)?;
        };
        for v in &self.files_deleted {
            os.write_string(8, &v)?;
        };
        for v in &self.files_copied {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProcessItem {
        ProcessItem::new()
    }

    fn clear(&mut self) {
        self.process_id.clear();
        self.parent_process_id.clear();
        self.name.clear();
        self.start_time = 0;
        self.termination_time = 0;
        self.files_opened.clear();
        self.files_written.clear();
        self.files_deleted.clear();
        self.files_copied.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProcessItem {
        static instance: ProcessItem = ProcessItem {
            process_id: ::std::string::String::new(),
            parent_process_id: ::std::string::String::new(),
            name: ::std::string::String::new(),
            start_time: 0,
            termination_time: 0,
            files_opened: ::std::vec::Vec::new(),
            files_written: ::std::vec::Vec::new(),
            files_deleted: ::std::vec::Vec::new(),
            files_copied: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProcessItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProcessItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProcessItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProcessItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:vt.fileanalysis.BehaviourTag)
pub enum BehaviourTag {
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.UNKNOWN_BEHAVIOUR)
    UNKNOWN_BEHAVIOUR = 0,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.DETECT_DEBUG_ENVIRONMENT)
    DETECT_DEBUG_ENVIRONMENT = 1,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.DIRECT_CPU_CLOCK_ACCESS)
    DIRECT_CPU_CLOCK_ACCESS = 2,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.LONG_SLEEPS)
    LONG_SLEEPS = 3,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.SELF_DELETE)
    SELF_DELETE = 4,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.HOSTS_MODIFIER)
    HOSTS_MODIFIER = 5,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.INSTALLS_BROWSER_EXTENSION)
    INSTALLS_BROWSER_EXTENSION = 6,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.PASSWORD_DIALOG)
    PASSWORD_DIALOG = 7,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.SUDO)
    SUDO = 8,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.PERSISTENCE)
    PERSISTENCE = 9,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.SENDS_SMS)
    SENDS_SMS = 10,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.CHECKS_GPS)
    CHECKS_GPS = 11,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.FTP_COMMUNICATION)
    FTP_COMMUNICATION = 12,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.SSH_COMMUNICATION)
    SSH_COMMUNICATION = 13,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.TELNET_COMMUNICATION)
    TELNET_COMMUNICATION = 14,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.SMTP_COMMUNICATION)
    SMTP_COMMUNICATION = 15,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.MYSQL_COMMUNICATION)
    MYSQL_COMMUNICATION = 26,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.IRC_COMMUNICATION)
    IRC_COMMUNICATION = 17,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.SUSPICIOUS_DNS)
    SUSPICIOUS_DNS = 18,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.SUSPICIOUS_UDP)
    SUSPICIOUS_UDP = 19,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.BIG_UPSTREAM)
    BIG_UPSTREAM = 20,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.TUNNELING)
    TUNNELING = 21,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.CRYPTO)
    CRYPTO = 22,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.TELEPHONY)
    TELEPHONY = 23,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.RUNTIME_MODULES)
    RUNTIME_MODULES = 24,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.REFLECTION)
    REFLECTION = 25,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.DECRYPTS_EXE)
    DECRYPTS_EXE = 27,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.MACRO_ENVIRON)
    MACRO_ENVIRON = 28,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.MACRO_OPEN_FILE)
    MACRO_OPEN_FILE = 29,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.MACRO_WRITE_FILE)
    MACRO_WRITE_FILE = 30,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.MACRO_HANDLE_FILE)
    MACRO_HANDLE_FILE = 31,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.MACRO_COPY_FILE)
    MACRO_COPY_FILE = 32,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.MACRO_CREATE_FILE)
    MACRO_CREATE_FILE = 33,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.MACRO_RUN_FILE)
    MACRO_RUN_FILE = 34,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.MACRO_HIDE_APP)
    MACRO_HIDE_APP = 35,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.MACRO_POWERSHELL)
    MACRO_POWERSHELL = 36,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.MACRO_CREATE_DIR)
    MACRO_CREATE_DIR = 37,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.MACRO_SAVE_WORKBOOK)
    MACRO_SAVE_WORKBOOK = 38,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.MACRO_CREATE_OLE)
    MACRO_CREATE_OLE = 39,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.MACRO_ENUM_WINDOWS)
    MACRO_ENUM_WINDOWS = 40,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.MACRO_RUN_DLL)
    MACRO_RUN_DLL = 41,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.MACRO_DOWNLOAD_URL)
    MACRO_DOWNLOAD_URL = 42,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.MACRO_SEND_KEYS)
    MACRO_SEND_KEYS = 43,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.MACRO_REGISTRY)
    MACRO_REGISTRY = 44,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.MACRO_ANTI_ANALYSIS)
    MACRO_ANTI_ANALYSIS = 45,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.OBFUSCATED)
    OBFUSCATED = 46,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.CLIPBOARD)
    CLIPBOARD = 47,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.CHECKS_CPU_NAME)
    CHECKS_CPU_NAME = 48,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.CHECKS_DISK_SPACE)
    CHECKS_DISK_SPACE = 49,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.CHECKS_MEMORY_AVAILABLE)
    CHECKS_MEMORY_AVAILABLE = 50,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.CHECKS_HOSTNAME)
    CHECKS_HOSTNAME = 51,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.CHECKS_NETWORK_ADAPTERS)
    CHECKS_NETWORK_ADAPTERS = 52,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.CHECKS_BIOS)
    CHECKS_BIOS = 53,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.CHECKS_PCI_BUS)
    CHECKS_PCI_BUS = 54,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.CHECKS_USB_BUS)
    CHECKS_USB_BUS = 55,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.EXECUTES_DROPPED_FILE)
    EXECUTES_DROPPED_FILE = 56,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.REPEATED_CLOCK_ACCESS)
    REPEATED_CLOCK_ACCESS = 57,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.CHECKS_USER_INPUT)
    CHECKS_USER_INPUT = 58,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.CALLS_WMI)
    CALLS_WMI = 59,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.EVAL_FUNCTION)
    EVAL_FUNCTION = 60,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.IDLE)
    IDLE = 61,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.SERVICE_SCAN)
    SERVICE_SCAN = 62,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.LISTENS)
    LISTENS = 63,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.SETS_PROCESS_NAME)
    SETS_PROCESS_NAME = 64,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.BehaviourTag.QR_CODE)
    QR_CODE = 65,
}

impl ::protobuf::Enum for BehaviourTag {
    const NAME: &'static str = "BehaviourTag";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BehaviourTag> {
        match value {
            0 => ::std::option::Option::Some(BehaviourTag::UNKNOWN_BEHAVIOUR),
            1 => ::std::option::Option::Some(BehaviourTag::DETECT_DEBUG_ENVIRONMENT),
            2 => ::std::option::Option::Some(BehaviourTag::DIRECT_CPU_CLOCK_ACCESS),
            3 => ::std::option::Option::Some(BehaviourTag::LONG_SLEEPS),
            4 => ::std::option::Option::Some(BehaviourTag::SELF_DELETE),
            5 => ::std::option::Option::Some(BehaviourTag::HOSTS_MODIFIER),
            6 => ::std::option::Option::Some(BehaviourTag::INSTALLS_BROWSER_EXTENSION),
            7 => ::std::option::Option::Some(BehaviourTag::PASSWORD_DIALOG),
            8 => ::std::option::Option::Some(BehaviourTag::SUDO),
            9 => ::std::option::Option::Some(BehaviourTag::PERSISTENCE),
            10 => ::std::option::Option::Some(BehaviourTag::SENDS_SMS),
            11 => ::std::option::Option::Some(BehaviourTag::CHECKS_GPS),
            12 => ::std::option::Option::Some(BehaviourTag::FTP_COMMUNICATION),
            13 => ::std::option::Option::Some(BehaviourTag::SSH_COMMUNICATION),
            14 => ::std::option::Option::Some(BehaviourTag::TELNET_COMMUNICATION),
            15 => ::std::option::Option::Some(BehaviourTag::SMTP_COMMUNICATION),
            26 => ::std::option::Option::Some(BehaviourTag::MYSQL_COMMUNICATION),
            17 => ::std::option::Option::Some(BehaviourTag::IRC_COMMUNICATION),
            18 => ::std::option::Option::Some(BehaviourTag::SUSPICIOUS_DNS),
            19 => ::std::option::Option::Some(BehaviourTag::SUSPICIOUS_UDP),
            20 => ::std::option::Option::Some(BehaviourTag::BIG_UPSTREAM),
            21 => ::std::option::Option::Some(BehaviourTag::TUNNELING),
            22 => ::std::option::Option::Some(BehaviourTag::CRYPTO),
            23 => ::std::option::Option::Some(BehaviourTag::TELEPHONY),
            24 => ::std::option::Option::Some(BehaviourTag::RUNTIME_MODULES),
            25 => ::std::option::Option::Some(BehaviourTag::REFLECTION),
            27 => ::std::option::Option::Some(BehaviourTag::DECRYPTS_EXE),
            28 => ::std::option::Option::Some(BehaviourTag::MACRO_ENVIRON),
            29 => ::std::option::Option::Some(BehaviourTag::MACRO_OPEN_FILE),
            30 => ::std::option::Option::Some(BehaviourTag::MACRO_WRITE_FILE),
            31 => ::std::option::Option::Some(BehaviourTag::MACRO_HANDLE_FILE),
            32 => ::std::option::Option::Some(BehaviourTag::MACRO_COPY_FILE),
            33 => ::std::option::Option::Some(BehaviourTag::MACRO_CREATE_FILE),
            34 => ::std::option::Option::Some(BehaviourTag::MACRO_RUN_FILE),
            35 => ::std::option::Option::Some(BehaviourTag::MACRO_HIDE_APP),
            36 => ::std::option::Option::Some(BehaviourTag::MACRO_POWERSHELL),
            37 => ::std::option::Option::Some(BehaviourTag::MACRO_CREATE_DIR),
            38 => ::std::option::Option::Some(BehaviourTag::MACRO_SAVE_WORKBOOK),
            39 => ::std::option::Option::Some(BehaviourTag::MACRO_CREATE_OLE),
            40 => ::std::option::Option::Some(BehaviourTag::MACRO_ENUM_WINDOWS),
            41 => ::std::option::Option::Some(BehaviourTag::MACRO_RUN_DLL),
            42 => ::std::option::Option::Some(BehaviourTag::MACRO_DOWNLOAD_URL),
            43 => ::std::option::Option::Some(BehaviourTag::MACRO_SEND_KEYS),
            44 => ::std::option::Option::Some(BehaviourTag::MACRO_REGISTRY),
            45 => ::std::option::Option::Some(BehaviourTag::MACRO_ANTI_ANALYSIS),
            46 => ::std::option::Option::Some(BehaviourTag::OBFUSCATED),
            47 => ::std::option::Option::Some(BehaviourTag::CLIPBOARD),
            48 => ::std::option::Option::Some(BehaviourTag::CHECKS_CPU_NAME),
            49 => ::std::option::Option::Some(BehaviourTag::CHECKS_DISK_SPACE),
            50 => ::std::option::Option::Some(BehaviourTag::CHECKS_MEMORY_AVAILABLE),
            51 => ::std::option::Option::Some(BehaviourTag::CHECKS_HOSTNAME),
            52 => ::std::option::Option::Some(BehaviourTag::CHECKS_NETWORK_ADAPTERS),
            53 => ::std::option::Option::Some(BehaviourTag::CHECKS_BIOS),
            54 => ::std::option::Option::Some(BehaviourTag::CHECKS_PCI_BUS),
            55 => ::std::option::Option::Some(BehaviourTag::CHECKS_USB_BUS),
            56 => ::std::option::Option::Some(BehaviourTag::EXECUTES_DROPPED_FILE),
            57 => ::std::option::Option::Some(BehaviourTag::REPEATED_CLOCK_ACCESS),
            58 => ::std::option::Option::Some(BehaviourTag::CHECKS_USER_INPUT),
            59 => ::std::option::Option::Some(BehaviourTag::CALLS_WMI),
            60 => ::std::option::Option::Some(BehaviourTag::EVAL_FUNCTION),
            61 => ::std::option::Option::Some(BehaviourTag::IDLE),
            62 => ::std::option::Option::Some(BehaviourTag::SERVICE_SCAN),
            63 => ::std::option::Option::Some(BehaviourTag::LISTENS),
            64 => ::std::option::Option::Some(BehaviourTag::SETS_PROCESS_NAME),
            65 => ::std::option::Option::Some(BehaviourTag::QR_CODE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<BehaviourTag> {
        match str {
            "UNKNOWN_BEHAVIOUR" => ::std::option::Option::Some(BehaviourTag::UNKNOWN_BEHAVIOUR),
            "DETECT_DEBUG_ENVIRONMENT" => ::std::option::Option::Some(BehaviourTag::DETECT_DEBUG_ENVIRONMENT),
            "DIRECT_CPU_CLOCK_ACCESS" => ::std::option::Option::Some(BehaviourTag::DIRECT_CPU_CLOCK_ACCESS),
            "LONG_SLEEPS" => ::std::option::Option::Some(BehaviourTag::LONG_SLEEPS),
            "SELF_DELETE" => ::std::option::Option::Some(BehaviourTag::SELF_DELETE),
            "HOSTS_MODIFIER" => ::std::option::Option::Some(BehaviourTag::HOSTS_MODIFIER),
            "INSTALLS_BROWSER_EXTENSION" => ::std::option::Option::Some(BehaviourTag::INSTALLS_BROWSER_EXTENSION),
            "PASSWORD_DIALOG" => ::std::option::Option::Some(BehaviourTag::PASSWORD_DIALOG),
            "SUDO" => ::std::option::Option::Some(BehaviourTag::SUDO),
            "PERSISTENCE" => ::std::option::Option::Some(BehaviourTag::PERSISTENCE),
            "SENDS_SMS" => ::std::option::Option::Some(BehaviourTag::SENDS_SMS),
            "CHECKS_GPS" => ::std::option::Option::Some(BehaviourTag::CHECKS_GPS),
            "FTP_COMMUNICATION" => ::std::option::Option::Some(BehaviourTag::FTP_COMMUNICATION),
            "SSH_COMMUNICATION" => ::std::option::Option::Some(BehaviourTag::SSH_COMMUNICATION),
            "TELNET_COMMUNICATION" => ::std::option::Option::Some(BehaviourTag::TELNET_COMMUNICATION),
            "SMTP_COMMUNICATION" => ::std::option::Option::Some(BehaviourTag::SMTP_COMMUNICATION),
            "MYSQL_COMMUNICATION" => ::std::option::Option::Some(BehaviourTag::MYSQL_COMMUNICATION),
            "IRC_COMMUNICATION" => ::std::option::Option::Some(BehaviourTag::IRC_COMMUNICATION),
            "SUSPICIOUS_DNS" => ::std::option::Option::Some(BehaviourTag::SUSPICIOUS_DNS),
            "SUSPICIOUS_UDP" => ::std::option::Option::Some(BehaviourTag::SUSPICIOUS_UDP),
            "BIG_UPSTREAM" => ::std::option::Option::Some(BehaviourTag::BIG_UPSTREAM),
            "TUNNELING" => ::std::option::Option::Some(BehaviourTag::TUNNELING),
            "CRYPTO" => ::std::option::Option::Some(BehaviourTag::CRYPTO),
            "TELEPHONY" => ::std::option::Option::Some(BehaviourTag::TELEPHONY),
            "RUNTIME_MODULES" => ::std::option::Option::Some(BehaviourTag::RUNTIME_MODULES),
            "REFLECTION" => ::std::option::Option::Some(BehaviourTag::REFLECTION),
            "DECRYPTS_EXE" => ::std::option::Option::Some(BehaviourTag::DECRYPTS_EXE),
            "MACRO_ENVIRON" => ::std::option::Option::Some(BehaviourTag::MACRO_ENVIRON),
            "MACRO_OPEN_FILE" => ::std::option::Option::Some(BehaviourTag::MACRO_OPEN_FILE),
            "MACRO_WRITE_FILE" => ::std::option::Option::Some(BehaviourTag::MACRO_WRITE_FILE),
            "MACRO_HANDLE_FILE" => ::std::option::Option::Some(BehaviourTag::MACRO_HANDLE_FILE),
            "MACRO_COPY_FILE" => ::std::option::Option::Some(BehaviourTag::MACRO_COPY_FILE),
            "MACRO_CREATE_FILE" => ::std::option::Option::Some(BehaviourTag::MACRO_CREATE_FILE),
            "MACRO_RUN_FILE" => ::std::option::Option::Some(BehaviourTag::MACRO_RUN_FILE),
            "MACRO_HIDE_APP" => ::std::option::Option::Some(BehaviourTag::MACRO_HIDE_APP),
            "MACRO_POWERSHELL" => ::std::option::Option::Some(BehaviourTag::MACRO_POWERSHELL),
            "MACRO_CREATE_DIR" => ::std::option::Option::Some(BehaviourTag::MACRO_CREATE_DIR),
            "MACRO_SAVE_WORKBOOK" => ::std::option::Option::Some(BehaviourTag::MACRO_SAVE_WORKBOOK),
            "MACRO_CREATE_OLE" => ::std::option::Option::Some(BehaviourTag::MACRO_CREATE_OLE),
            "MACRO_ENUM_WINDOWS" => ::std::option::Option::Some(BehaviourTag::MACRO_ENUM_WINDOWS),
            "MACRO_RUN_DLL" => ::std::option::Option::Some(BehaviourTag::MACRO_RUN_DLL),
            "MACRO_DOWNLOAD_URL" => ::std::option::Option::Some(BehaviourTag::MACRO_DOWNLOAD_URL),
            "MACRO_SEND_KEYS" => ::std::option::Option::Some(BehaviourTag::MACRO_SEND_KEYS),
            "MACRO_REGISTRY" => ::std::option::Option::Some(BehaviourTag::MACRO_REGISTRY),
            "MACRO_ANTI_ANALYSIS" => ::std::option::Option::Some(BehaviourTag::MACRO_ANTI_ANALYSIS),
            "OBFUSCATED" => ::std::option::Option::Some(BehaviourTag::OBFUSCATED),
            "CLIPBOARD" => ::std::option::Option::Some(BehaviourTag::CLIPBOARD),
            "CHECKS_CPU_NAME" => ::std::option::Option::Some(BehaviourTag::CHECKS_CPU_NAME),
            "CHECKS_DISK_SPACE" => ::std::option::Option::Some(BehaviourTag::CHECKS_DISK_SPACE),
            "CHECKS_MEMORY_AVAILABLE" => ::std::option::Option::Some(BehaviourTag::CHECKS_MEMORY_AVAILABLE),
            "CHECKS_HOSTNAME" => ::std::option::Option::Some(BehaviourTag::CHECKS_HOSTNAME),
            "CHECKS_NETWORK_ADAPTERS" => ::std::option::Option::Some(BehaviourTag::CHECKS_NETWORK_ADAPTERS),
            "CHECKS_BIOS" => ::std::option::Option::Some(BehaviourTag::CHECKS_BIOS),
            "CHECKS_PCI_BUS" => ::std::option::Option::Some(BehaviourTag::CHECKS_PCI_BUS),
            "CHECKS_USB_BUS" => ::std::option::Option::Some(BehaviourTag::CHECKS_USB_BUS),
            "EXECUTES_DROPPED_FILE" => ::std::option::Option::Some(BehaviourTag::EXECUTES_DROPPED_FILE),
            "REPEATED_CLOCK_ACCESS" => ::std::option::Option::Some(BehaviourTag::REPEATED_CLOCK_ACCESS),
            "CHECKS_USER_INPUT" => ::std::option::Option::Some(BehaviourTag::CHECKS_USER_INPUT),
            "CALLS_WMI" => ::std::option::Option::Some(BehaviourTag::CALLS_WMI),
            "EVAL_FUNCTION" => ::std::option::Option::Some(BehaviourTag::EVAL_FUNCTION),
            "IDLE" => ::std::option::Option::Some(BehaviourTag::IDLE),
            "SERVICE_SCAN" => ::std::option::Option::Some(BehaviourTag::SERVICE_SCAN),
            "LISTENS" => ::std::option::Option::Some(BehaviourTag::LISTENS),
            "SETS_PROCESS_NAME" => ::std::option::Option::Some(BehaviourTag::SETS_PROCESS_NAME),
            "QR_CODE" => ::std::option::Option::Some(BehaviourTag::QR_CODE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [BehaviourTag] = &[
        BehaviourTag::UNKNOWN_BEHAVIOUR,
        BehaviourTag::DETECT_DEBUG_ENVIRONMENT,
        BehaviourTag::DIRECT_CPU_CLOCK_ACCESS,
        BehaviourTag::LONG_SLEEPS,
        BehaviourTag::SELF_DELETE,
        BehaviourTag::HOSTS_MODIFIER,
        BehaviourTag::INSTALLS_BROWSER_EXTENSION,
        BehaviourTag::PASSWORD_DIALOG,
        BehaviourTag::SUDO,
        BehaviourTag::PERSISTENCE,
        BehaviourTag::SENDS_SMS,
        BehaviourTag::CHECKS_GPS,
        BehaviourTag::FTP_COMMUNICATION,
        BehaviourTag::SSH_COMMUNICATION,
        BehaviourTag::TELNET_COMMUNICATION,
        BehaviourTag::SMTP_COMMUNICATION,
        BehaviourTag::MYSQL_COMMUNICATION,
        BehaviourTag::IRC_COMMUNICATION,
        BehaviourTag::SUSPICIOUS_DNS,
        BehaviourTag::SUSPICIOUS_UDP,
        BehaviourTag::BIG_UPSTREAM,
        BehaviourTag::TUNNELING,
        BehaviourTag::CRYPTO,
        BehaviourTag::TELEPHONY,
        BehaviourTag::RUNTIME_MODULES,
        BehaviourTag::REFLECTION,
        BehaviourTag::DECRYPTS_EXE,
        BehaviourTag::MACRO_ENVIRON,
        BehaviourTag::MACRO_OPEN_FILE,
        BehaviourTag::MACRO_WRITE_FILE,
        BehaviourTag::MACRO_HANDLE_FILE,
        BehaviourTag::MACRO_COPY_FILE,
        BehaviourTag::MACRO_CREATE_FILE,
        BehaviourTag::MACRO_RUN_FILE,
        BehaviourTag::MACRO_HIDE_APP,
        BehaviourTag::MACRO_POWERSHELL,
        BehaviourTag::MACRO_CREATE_DIR,
        BehaviourTag::MACRO_SAVE_WORKBOOK,
        BehaviourTag::MACRO_CREATE_OLE,
        BehaviourTag::MACRO_ENUM_WINDOWS,
        BehaviourTag::MACRO_RUN_DLL,
        BehaviourTag::MACRO_DOWNLOAD_URL,
        BehaviourTag::MACRO_SEND_KEYS,
        BehaviourTag::MACRO_REGISTRY,
        BehaviourTag::MACRO_ANTI_ANALYSIS,
        BehaviourTag::OBFUSCATED,
        BehaviourTag::CLIPBOARD,
        BehaviourTag::CHECKS_CPU_NAME,
        BehaviourTag::CHECKS_DISK_SPACE,
        BehaviourTag::CHECKS_MEMORY_AVAILABLE,
        BehaviourTag::CHECKS_HOSTNAME,
        BehaviourTag::CHECKS_NETWORK_ADAPTERS,
        BehaviourTag::CHECKS_BIOS,
        BehaviourTag::CHECKS_PCI_BUS,
        BehaviourTag::CHECKS_USB_BUS,
        BehaviourTag::EXECUTES_DROPPED_FILE,
        BehaviourTag::REPEATED_CLOCK_ACCESS,
        BehaviourTag::CHECKS_USER_INPUT,
        BehaviourTag::CALLS_WMI,
        BehaviourTag::EVAL_FUNCTION,
        BehaviourTag::IDLE,
        BehaviourTag::SERVICE_SCAN,
        BehaviourTag::LISTENS,
        BehaviourTag::SETS_PROCESS_NAME,
        BehaviourTag::QR_CODE,
    ];
}

impl ::protobuf::EnumFull for BehaviourTag {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("BehaviourTag").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            BehaviourTag::UNKNOWN_BEHAVIOUR => 0,
            BehaviourTag::DETECT_DEBUG_ENVIRONMENT => 1,
            BehaviourTag::DIRECT_CPU_CLOCK_ACCESS => 2,
            BehaviourTag::LONG_SLEEPS => 3,
            BehaviourTag::SELF_DELETE => 4,
            BehaviourTag::HOSTS_MODIFIER => 5,
            BehaviourTag::INSTALLS_BROWSER_EXTENSION => 6,
            BehaviourTag::PASSWORD_DIALOG => 7,
            BehaviourTag::SUDO => 8,
            BehaviourTag::PERSISTENCE => 9,
            BehaviourTag::SENDS_SMS => 10,
            BehaviourTag::CHECKS_GPS => 11,
            BehaviourTag::FTP_COMMUNICATION => 12,
            BehaviourTag::SSH_COMMUNICATION => 13,
            BehaviourTag::TELNET_COMMUNICATION => 14,
            BehaviourTag::SMTP_COMMUNICATION => 15,
            BehaviourTag::MYSQL_COMMUNICATION => 16,
            BehaviourTag::IRC_COMMUNICATION => 17,
            BehaviourTag::SUSPICIOUS_DNS => 18,
            BehaviourTag::SUSPICIOUS_UDP => 19,
            BehaviourTag::BIG_UPSTREAM => 20,
            BehaviourTag::TUNNELING => 21,
            BehaviourTag::CRYPTO => 22,
            BehaviourTag::TELEPHONY => 23,
            BehaviourTag::RUNTIME_MODULES => 24,
            BehaviourTag::REFLECTION => 25,
            BehaviourTag::DECRYPTS_EXE => 26,
            BehaviourTag::MACRO_ENVIRON => 27,
            BehaviourTag::MACRO_OPEN_FILE => 28,
            BehaviourTag::MACRO_WRITE_FILE => 29,
            BehaviourTag::MACRO_HANDLE_FILE => 30,
            BehaviourTag::MACRO_COPY_FILE => 31,
            BehaviourTag::MACRO_CREATE_FILE => 32,
            BehaviourTag::MACRO_RUN_FILE => 33,
            BehaviourTag::MACRO_HIDE_APP => 34,
            BehaviourTag::MACRO_POWERSHELL => 35,
            BehaviourTag::MACRO_CREATE_DIR => 36,
            BehaviourTag::MACRO_SAVE_WORKBOOK => 37,
            BehaviourTag::MACRO_CREATE_OLE => 38,
            BehaviourTag::MACRO_ENUM_WINDOWS => 39,
            BehaviourTag::MACRO_RUN_DLL => 40,
            BehaviourTag::MACRO_DOWNLOAD_URL => 41,
            BehaviourTag::MACRO_SEND_KEYS => 42,
            BehaviourTag::MACRO_REGISTRY => 43,
            BehaviourTag::MACRO_ANTI_ANALYSIS => 44,
            BehaviourTag::OBFUSCATED => 45,
            BehaviourTag::CLIPBOARD => 46,
            BehaviourTag::CHECKS_CPU_NAME => 47,
            BehaviourTag::CHECKS_DISK_SPACE => 48,
            BehaviourTag::CHECKS_MEMORY_AVAILABLE => 49,
            BehaviourTag::CHECKS_HOSTNAME => 50,
            BehaviourTag::CHECKS_NETWORK_ADAPTERS => 51,
            BehaviourTag::CHECKS_BIOS => 52,
            BehaviourTag::CHECKS_PCI_BUS => 53,
            BehaviourTag::CHECKS_USB_BUS => 54,
            BehaviourTag::EXECUTES_DROPPED_FILE => 55,
            BehaviourTag::REPEATED_CLOCK_ACCESS => 56,
            BehaviourTag::CHECKS_USER_INPUT => 57,
            BehaviourTag::CALLS_WMI => 58,
            BehaviourTag::EVAL_FUNCTION => 59,
            BehaviourTag::IDLE => 60,
            BehaviourTag::SERVICE_SCAN => 61,
            BehaviourTag::LISTENS => 62,
            BehaviourTag::SETS_PROCESS_NAME => 63,
            BehaviourTag::QR_CODE => 64,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for BehaviourTag {
    fn default() -> Self {
        BehaviourTag::UNKNOWN_BEHAVIOUR
    }
}

impl BehaviourTag {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<BehaviourTag>("BehaviourTag")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:vt.fileanalysis.VerdictTag)
pub enum VerdictTag {
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.VerdictTag.UNKNOWN_VERDICT)
    UNKNOWN_VERDICT = 0,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.VerdictTag.CLEAN)
    CLEAN = 1,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.VerdictTag.MALWARE)
    MALWARE = 2,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.VerdictTag.GREYWARE)
    GREYWARE = 3,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.VerdictTag.RANSOM)
    RANSOM = 4,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.VerdictTag.PHISHING)
    PHISHING = 5,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.VerdictTag.BANKER)
    BANKER = 6,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.VerdictTag.ADWARE)
    ADWARE = 7,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.VerdictTag.EXPLOIT)
    EXPLOIT = 8,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.VerdictTag.EVADER)
    EVADER = 9,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.VerdictTag.RAT)
    RAT = 10,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.VerdictTag.TROJAN)
    TROJAN = 11,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.VerdictTag.SPREADER)
    SPREADER = 12,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.VerdictTag.STEALER)
    STEALER = 13,
}

impl ::protobuf::Enum for VerdictTag {
    const NAME: &'static str = "VerdictTag";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<VerdictTag> {
        match value {
            0 => ::std::option::Option::Some(VerdictTag::UNKNOWN_VERDICT),
            1 => ::std::option::Option::Some(VerdictTag::CLEAN),
            2 => ::std::option::Option::Some(VerdictTag::MALWARE),
            3 => ::std::option::Option::Some(VerdictTag::GREYWARE),
            4 => ::std::option::Option::Some(VerdictTag::RANSOM),
            5 => ::std::option::Option::Some(VerdictTag::PHISHING),
            6 => ::std::option::Option::Some(VerdictTag::BANKER),
            7 => ::std::option::Option::Some(VerdictTag::ADWARE),
            8 => ::std::option::Option::Some(VerdictTag::EXPLOIT),
            9 => ::std::option::Option::Some(VerdictTag::EVADER),
            10 => ::std::option::Option::Some(VerdictTag::RAT),
            11 => ::std::option::Option::Some(VerdictTag::TROJAN),
            12 => ::std::option::Option::Some(VerdictTag::SPREADER),
            13 => ::std::option::Option::Some(VerdictTag::STEALER),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<VerdictTag> {
        match str {
            "UNKNOWN_VERDICT" => ::std::option::Option::Some(VerdictTag::UNKNOWN_VERDICT),
            "CLEAN" => ::std::option::Option::Some(VerdictTag::CLEAN),
            "MALWARE" => ::std::option::Option::Some(VerdictTag::MALWARE),
            "GREYWARE" => ::std::option::Option::Some(VerdictTag::GREYWARE),
            "RANSOM" => ::std::option::Option::Some(VerdictTag::RANSOM),
            "PHISHING" => ::std::option::Option::Some(VerdictTag::PHISHING),
            "BANKER" => ::std::option::Option::Some(VerdictTag::BANKER),
            "ADWARE" => ::std::option::Option::Some(VerdictTag::ADWARE),
            "EXPLOIT" => ::std::option::Option::Some(VerdictTag::EXPLOIT),
            "EVADER" => ::std::option::Option::Some(VerdictTag::EVADER),
            "RAT" => ::std::option::Option::Some(VerdictTag::RAT),
            "TROJAN" => ::std::option::Option::Some(VerdictTag::TROJAN),
            "SPREADER" => ::std::option::Option::Some(VerdictTag::SPREADER),
            "STEALER" => ::std::option::Option::Some(VerdictTag::STEALER),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [VerdictTag] = &[
        VerdictTag::UNKNOWN_VERDICT,
        VerdictTag::CLEAN,
        VerdictTag::MALWARE,
        VerdictTag::GREYWARE,
        VerdictTag::RANSOM,
        VerdictTag::PHISHING,
        VerdictTag::BANKER,
        VerdictTag::ADWARE,
        VerdictTag::EXPLOIT,
        VerdictTag::EVADER,
        VerdictTag::RAT,
        VerdictTag::TROJAN,
        VerdictTag::SPREADER,
        VerdictTag::STEALER,
    ];
}

impl ::protobuf::EnumFull for VerdictTag {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("VerdictTag").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for VerdictTag {
    fn default() -> Self {
        VerdictTag::UNKNOWN_VERDICT
    }
}

impl VerdictTag {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<VerdictTag>("VerdictTag")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:vt.fileanalysis.ImpactSeverity)
pub enum ImpactSeverity {
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.ImpactSeverity.IMPACT_SEVERITY_UNKNOWN)
    IMPACT_SEVERITY_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.ImpactSeverity.IMPACT_SEVERITY_INFO)
    IMPACT_SEVERITY_INFO = 1,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.ImpactSeverity.IMPACT_SEVERITY_LOW)
    IMPACT_SEVERITY_LOW = 2,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.ImpactSeverity.IMPACT_SEVERITY_MEDIUM)
    IMPACT_SEVERITY_MEDIUM = 3,
    // @@protoc_insertion_point(enum_value:vt.fileanalysis.ImpactSeverity.IMPACT_SEVERITY_HIGH)
    IMPACT_SEVERITY_HIGH = 4,
}

impl ::protobuf::Enum for ImpactSeverity {
    const NAME: &'static str = "ImpactSeverity";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ImpactSeverity> {
        match value {
            0 => ::std::option::Option::Some(ImpactSeverity::IMPACT_SEVERITY_UNKNOWN),
            1 => ::std::option::Option::Some(ImpactSeverity::IMPACT_SEVERITY_INFO),
            2 => ::std::option::Option::Some(ImpactSeverity::IMPACT_SEVERITY_LOW),
            3 => ::std::option::Option::Some(ImpactSeverity::IMPACT_SEVERITY_MEDIUM),
            4 => ::std::option::Option::Some(ImpactSeverity::IMPACT_SEVERITY_HIGH),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ImpactSeverity> {
        match str {
            "IMPACT_SEVERITY_UNKNOWN" => ::std::option::Option::Some(ImpactSeverity::IMPACT_SEVERITY_UNKNOWN),
            "IMPACT_SEVERITY_INFO" => ::std::option::Option::Some(ImpactSeverity::IMPACT_SEVERITY_INFO),
            "IMPACT_SEVERITY_LOW" => ::std::option::Option::Some(ImpactSeverity::IMPACT_SEVERITY_LOW),
            "IMPACT_SEVERITY_MEDIUM" => ::std::option::Option::Some(ImpactSeverity::IMPACT_SEVERITY_MEDIUM),
            "IMPACT_SEVERITY_HIGH" => ::std::option::Option::Some(ImpactSeverity::IMPACT_SEVERITY_HIGH),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ImpactSeverity] = &[
        ImpactSeverity::IMPACT_SEVERITY_UNKNOWN,
        ImpactSeverity::IMPACT_SEVERITY_INFO,
        ImpactSeverity::IMPACT_SEVERITY_LOW,
        ImpactSeverity::IMPACT_SEVERITY_MEDIUM,
        ImpactSeverity::IMPACT_SEVERITY_HIGH,
    ];
}

impl ::protobuf::EnumFull for ImpactSeverity {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ImpactSeverity").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ImpactSeverity {
    fn default() -> Self {
        ImpactSeverity::IMPACT_SEVERITY_UNKNOWN
    }
}

impl ImpactSeverity {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ImpactSeverity>("ImpactSeverity")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x10vt/sandbox.proto\x12\x0fvt.fileanalysis\x1a\x12vt/filetypes.proto\
    \x1a\x0evt/sigma.proto\x1a\x1bvt/tools/net_analysis.proto\x1a\nyara.prot\
    o\"\xcd\x1b\n\x10BehaviourSummary\x12!\n\x0cfiles_opened\x18\x01\x20\x03\
    (\tR\x0bfilesOpened\x12#\n\rfiles_written\x18\x02\x20\x03(\tR\x0cfilesWr\
    itten\x12#\n\rfiles_deleted\x18\x03\x20\x03(\tR\x0cfilesDeleted\x12<\n\
    \x0cfiles_copied\x18\x04\x20\x03(\x0b2\x19.vt.fileanalysis.FileCopyR\x0b\
    filesCopied\x126\n\x17files_attribute_changed\x18\x05\x20\x03(\tR\x15fil\
    esAttributeChanged\x12A\n\rfiles_dropped\x18\x06\x20\x03(\x0b2\x1c.vt.fi\
    leanalysis.DroppedFileR\x0cfilesDropped\x12\x1d\n\nhosts_file\x18\x07\
    \x20\x01(\tR\thostsFile\x12C\n\x0eprocesses_list\x18K\x20\x03(\x0b2\x1c.\
    vt.fileanalysis.ProcessItemR\rprocessesList\x12+\n\x11processes_created\
    \x18\t\x20\x03(\tR\x10processesCreated\x121\n\x14processes_terminated\
    \x18\n\x20\x03(\tR\x13processesTerminated\x12)\n\x10processes_killed\x18\
    \x0b\x20\x03(\tR\x0fprocessesKilled\x12-\n\x12processes_injected\x18\x0c\
    \x20\x03(\tR\x11processesInjected\x12-\n\x12command_executions\x18\r\x20\
    \x03(\tR\x11commandExecutions\x12'\n\x0fservices_opened\x18\x0e\x20\x03(\
    \tR\x0eservicesOpened\x12)\n\x10services_created\x18\x0f\x20\x03(\tR\x0f\
    servicesCreated\x12)\n\x10services_started\x18\x10\x20\x03(\tR\x0fservic\
    esStarted\x12)\n\x10services_stopped\x18\x11\x20\x03(\tR\x0fservicesStop\
    ped\x12)\n\x10services_deleted\x18\x12\x20\x03(\tR\x0fservicesDeleted\
    \x12%\n\x0eservices_bound\x18\x13\x20\x03(\tR\rservicesBound\x12)\n\x10w\
    indows_searched\x18\x14\x20\x03(\tR\x0fwindowsSearched\x12%\n\x0ewindows\
    _hidden\x18\x15\x20\x03(\tR\rwindowsHidden\x12Q\n\x13permissions_checked\
    \x18\x16\x20\x03(\x0b2\x20.vt.fileanalysis.PermissionCheckR\x12permissio\
    nsChecked\x123\n\x15permissions_requested\x18\x17\x20\x03(\tR\x14permiss\
    ionsRequested\x12%\n\x0emutexes_opened\x18\x18\x20\x03(\tR\rmutexesOpene\
    d\x12'\n\x0fmutexes_created\x18\x19\x20\x03(\tR\x0emutexesCreated\x12)\n\
    \x10signals_observed\x18\x1a\x20\x03(\tR\x0fsignalsObserved\x12%\n\x0esi\
    gnals_hooked\x18\x1b\x20\x03(\tR\rsignalsHooked\x12%\n\x0emodules_loaded\
    \x18\x1c\x20\x03(\tR\rmodulesLoaded\x12+\n\x11calls_highlighted\x18\x1d\
    \x20\x03(\tR\x10callsHighlighted\x12\x18\n\x07invokes\x18\x1e\x20\x03(\t\
    R\x07invokes\x12<\n\x1acrypto_algorithms_observed\x18\x1f\x20\x03(\tR\
    \x18cryptoAlgorithmsObserved\x12\x1f\n\x0bcrypto_keys\x18\x20\x20\x03(\t\
    R\ncryptoKeys\x12*\n\x11crypto_plain_text\x18!\x20\x03(\tR\x0fcryptoPlai\
    nText\x12@\n\x1cencoding_algorithms_observed\x18\"\x20\x03(\tR\x1aencodi\
    ngAlgorithmsObserved\x12!\n\x0ctext_decoded\x18#\x20\x03(\tR\x0btextDeco\
    ded\x12)\n\x10text_highlighted\x18$\x20\x03(\tR\x0ftextHighlighted\x12?\
    \n\x04tags\x18%\x20\x03(\x0e2\x1d.vt.fileanalysis.BehaviourTagR\x04tagsB\
    \x0c\x82\x93\x19\x08\n\x06traits\x12)\n\x10databases_opened\x187\x20\x03\
    (\tR\x0fdatabasesOpened\x12+\n\x11databases_deleted\x188\x20\x03(\tR\x10\
    databasesDeleted\x120\n\x14registry_keys_opened\x18&\x20\x03(\tR\x12regi\
    stryKeysOpened\x12E\n\x11registry_keys_set\x18'\x20\x03(\x0b2\x19.vt.fil\
    eanalysis.KeyValueR\x0fregistryKeysSet\x122\n\x15registry_keys_deleted\
    \x18(\x20\x03(\tR\x13registryKeysDeleted\x126\n\x17system_property_looku\
    ps\x18)\x20\x03(\tR\x15systemPropertyLookups\x12K\n\x14system_property_s\
    ets\x18*\x20\x03(\x0b2\x19.vt.fileanalysis.KeyValueR\x12systemPropertySe\
    ts\x12<\n\x1ashared_preferences_lookups\x18+\x20\x03(\tR\x18sharedPrefer\
    encesLookups\x12Q\n\x17shared_preferences_sets\x18,\x20\x03(\x0b2\x19.vt\
    .fileanalysis.KeyValueR\x15sharedPreferencesSets\x126\n\x17content_model\
    _observers\x18-\x20\x03(\tR\x15contentModelObservers\x12G\n\x12content_m\
    odel_sets\x18.\x20\x03(\x0b2\x19.vt.fileanalysis.KeyValueR\x10contentMod\
    elSets\x12-\n\x12activities_started\x18/\x20\x03(\tR\x11activitiesStarte\
    d\x12P\n\x12http_conversations\x180\x20\x03(\x0b2!.vt.fileanalysis.HttpC\
    onversationR\x11httpConversations\x12;\n\x0bdns_lookups\x181\x20\x03(\
    \x0b2\x1a.vt.fileanalysis.DnsLookupR\ndnsLookups\x129\n\nip_traffic\x182\
    \x20\x03(\x0b2\x1a.vt.fileanalysis.IpTrafficR\tipTraffic\x12/\n\x08sms_s\
    ent\x183\x20\x03(\x0b2\x14.vt.fileanalysis.SmsR\x07smsSent\x127\n\x08ver\
    dicts\x184\x20\x03(\x0e2\x1b.vt.fileanalysis.VerdictTagR\x08verdicts\x12\
    -\n\x12verdict_confidence\x18=\x20\x01(\x05R\x11verdictConfidence\x12%\n\
    \x0everdict_labels\x18A\x20\x03(\tR\rverdictLabels\x12\x1f\n\x0bja3_dige\
    sts\x189\x20\x03(\tR\nja3Digests\x12,\n\x12memory_pattern_ips\x18:\x20\
    \x03(\tR\x10memoryPatternIps\x124\n\x16memory_pattern_domains\x18;\x20\
    \x03(\tR\x14memoryPatternDomains\x12.\n\x13memory_pattern_urls\x18<\x20\
    \x03(\tR\x11memoryPatternUrls\x12P\n\x12smtp_conversations\x18@\x20\x03(\
    \x0b2!.vt.fileanalysis.SmtpConversationR\x11smtpConversations\x12L\n\nid\
    s_alerts\x18D\x20\x03(\x0b2-.vt.tools.net_analysis.CrowdSourcedIdsResult\
    sR\tidsAlerts\x12&\n\x03tls\x18E\x20\x03(\x0b2\x14.vt.fileanalysis.TLSR\
    \x03tls\x12]\n\x17mitre_attack_techniques\x18F\x20\x03(\x0b2%.vt.fileana\
    lysis.MitreAttackTechniqueR\x15mitreAttackTechniques\x12J\n\x16sigma_ana\
    lysis_results\x18G\x20\x03(\x0b2\x14.vt.sigma.SigmaMatchR\x14sigmaAnalys\
    isResults\x12L\n\x11signature_matches\x18H\x20\x03(\x0b2\x1f.vt.fileanal\
    ysis.SignatureMatchR\x10signatureMatches\x129\n\x03mbc\x18J\x20\x03(\x0b\
    2'.vt.fileanalysis.MalwareBehaviorCatalogR\x03mbc\"\x9c\x03\n\x03TLS\x12\
    ;\n\x07subject\x18\x01\x20\x03(\x0b2!.vt.fileanalysis.TLS.SubjectEntryR\
    \x07subject\x128\n\x06issuer\x18\x02\x20\x03(\x0b2\x20.vt.fileanalysis.T\
    LS.IssuerEntryR\x06issuer\x12#\n\rserial_number\x18\x03\x20\x01(\tR\x0cs\
    erialNumber\x12\x1e\n\nthumbprint\x18\x04\x20\x01(\tR\nthumbprint\x12\
    \x18\n\x07version\x18\x05\x20\x01(\tR\x07version\x12\x10\n\x03sni\x18\
    \x06\x20\x01(\tR\x03sni\x12\x10\n\x03ja3\x18\x07\x20\x01(\tR\x03ja3\x12\
    \x12\n\x04ja3s\x18\x08\x20\x01(\tR\x04ja3s\x12\x10\n\x03ja4\x18\n\x20\
    \x01(\tR\x03ja4\x1a:\n\x0cSubjectEntry\x12\x10\n\x03key\x18\x01\x20\x01(\
    \tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\
    9\n\x0bIssuerEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"D\n\x08FileCopy\x12\
    \x16\n\x06source\x18\x01\x20\x01(\tR\x06source\x12\x20\n\x0bdestination\
    \x18\x02\x20\x01(\tR\x0bdestination\"\xcd\x01\n\x0bDroppedFile\x12\x12\n\
    \x04path\x18\x01\x20\x01(\tR\x04path\x12\x16\n\x06sha256\x18\x02\x20\x01\
    (\tR\x06sha256\x12-\n\x04type\x18\x03\x20\x01(\x0e2\x19.vt.fileanalysis.\
    FileTypeR\x04type\x12!\n\x0cdownload_url\x18\x05\x20\x01(\tR\x0bdownload\
    Url\x12!\n\x0cprocess_name\x18\x06\x20\x01(\tR\x0bprocessName\x12\x1d\n\
    \nprocess_id\x18\x07\x20\x01(\tR\tprocessId\"G\n\x0fPermissionCheck\x12\
    \x1e\n\npermission\x18\x01\x20\x01(\tR\npermission\x12\x14\n\x05owner\
    \x18\x02\x20\x01(\tR\x05owner\"2\n\x08KeyValue\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\"\
    \xcb\x06\n\x10HttpConversation\x12\x10\n\x03url\x18\x01\x20\x01(\tR\x03u\
    rl\x12V\n\x0erequest_method\x18\x02\x20\x01(\x0e2/.vt.fileanalysis.HttpC\
    onversation.RequestMethodR\rrequestMethod\x12^\n\x0frequest_headers\x18\
    \x03\x20\x03(\x0b25.vt.fileanalysis.HttpConversation.RequestHeadersEntry\
    R\x0erequestHeaders\x12a\n\x10response_headers\x18\x04\x20\x03(\x0b26.vt\
    .fileanalysis.HttpConversation.ResponseHeadersEntryR\x0fresponseHeaders\
    \x120\n\x14response_status_code\x18\x05\x20\x01(\x05R\x12responseStatusC\
    ode\x12O\n\x16response_body_filetype\x18\x06\x20\x01(\x0e2\x19.vt.filean\
    alysis.FileTypeR\x14responseBodyFiletype\x12@\n\x1dresponse_body_first_t\
    en_bytes\x18\x07\x20\x01(\x0cR\x19responseBodyFirstTenBytes\x1aA\n\x13Re\
    questHeadersEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1aB\n\x14ResponseHeade\
    rsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\
    \x18\x02\x20\x01(\tR\x05value:\x028\x01\"\xb1\x01\n\rRequestMethod\x12\
    \x0b\n\x07UNKNOWN\x10\0\x12\x07\n\x03GET\x10\x01\x12\x08\n\x04HEAD\x10\
    \x02\x12\x08\n\x04POST\x10\x03\x12\x07\n\x03PUT\x10\x04\x12\n\n\x06DELET\
    E\x10\x05\x12\t\n\x05TRACE\x10\x06\x12\x0b\n\x07OPTIONS\x10\x07\x12\x0b\
    \n\x07CONNECT\x10\x08\x12\t\n\x05PATCH\x10\t\x12\x0c\n\x08PROPFIND\x10\n\
    \x12\t\n\x05SETUP\x10\x0b\x12\n\n\x06UNLOCK\x10\x0c\x1a\x0c\x92\x93\x19\
    \x08\n\x06Method:\n\x8a\x93\x19\x06\n\x04Http\"k\n\tDnsLookup\x12\x1a\n\
    \x08hostname\x18\x01\x20\x01(\tR\x08hostname\x12!\n\x0cresolved_ips\x18\
    \x02\x20\x03(\tR\x0bresolvedIps\x12\x1f\n\x0btxt_records\x18\x03\x20\x03\
    (\tR\ntxtRecords\"\xba\x03\n\tIpTraffic\x12%\n\x0edestination_ip\x18\x01\
    \x20\x01(\tR\rdestinationIp\x12)\n\x10destination_port\x18\x02\x20\x01(\
    \x05R\x0fdestinationPort\x12k\n\x18transport_layer_protocol\x18\x03\x20\
    \x01(\x0e21.vt.fileanalysis.IpTraffic.TransportLayerProtocolR\x16transpo\
    rtLayerProtocol\x12,\n\x12destination_ip_asn\x18\x04\x20\x01(\x03R\x10de\
    stinationIpAsn\x121\n\x15destination_ip_as_int\x18\x05\x20\x01(\x03R\x12\
    destinationIpAsInt\"\x81\x01\n\x16TransportLayerProtocol\x12\x0b\n\x07UN\
    KNOWN\x10\0\x12\x08\n\x04ICMP\x10\x01\x12\x08\n\x04IGMP\x10\x02\x12\x07\
    \n\x03TCP\x10\x06\x12\x07\n\x03UDP\x10\x11\x12\x07\n\x03ESP\x102\x12\x06\
    \n\x02AH\x103\x12\x08\n\x04L2TP\x10s\x12\t\n\x04SCTP\x10\x84\x01\x1a\x0e\
    \x92\x93\x19\n\n\x08Protocol:\t\x8a\x93\x19\x05\n\x03Net\"\xf2\x04\n\x10\
    SmtpConversation\x12\x1a\n\x08hostname\x18\x01\x20\x01(\tR\x08hostname\
    \x12%\n\x0edestination_ip\x18\x02\x20\x01(\tR\rdestinationIp\x12)\n\x10d\
    estination_port\x18\x03\x20\x01(\rR\x0fdestinationPort\x12\x1b\n\tsmtp_f\
    rom\x18\x04\x20\x01(\tR\x08smtpFrom\x12\x17\n\x07smtp_to\x18\x05\x20\x03\
    (\tR\x06smtpTo\x12!\n\x0cmessage_from\x18\x06\x20\x03(\tR\x0bmessageFrom\
    \x12\x1d\n\nmessage_to\x18\x07\x20\x03(\tR\tmessageTo\x12\x1d\n\nmessage\
    _cc\x18\x08\x20\x03(\tR\tmessageCc\x12\x1f\n\x0bmessage_bcc\x18\t\x20\
    \x03(\tR\nmessageBcc\x12\x1c\n\ttimestamp\x18\n\x20\x01(\tR\ttimestamp\
    \x12\x18\n\x07subject\x18\x0b\x20\x01(\tR\x07subject\x12\x1b\n\thtml_bod\
    y\x18\x0c\x20\x01(\tR\x08htmlBody\x12\x19\n\x08txt_body\x18\r\x20\x01(\t\
    R\x07txtBody\x12\x1b\n\tauth_user\x18\x0e\x20\x01(\tR\x08authUser\x12\
    \x1b\n\tauth_pass\x18\x0f\x20\x01(\tR\x08authPass\x123\n\x07headers\x18\
    \x10\x20\x03(\x0b2\x19.vt.fileanalysis.KeyValueR\x07headers\x12>\n\x0bat\
    tachments\x18\x11\x20\x03(\x0b2\x1c.vt.fileanalysis.DroppedFileR\x0batta\
    chments\x12\x19\n\x08x_mailer\x18\x12\x20\x01(\tR\x07xMailer\";\n\x03Sms\
    \x12\x20\n\x0bdestination\x18\x01\x20\x01(\tR\x0bdestination\x12\x12\n\
    \x04body\x18\x02\x20\x01(\tR\x04body\"\xe4\x03\n\x0eSignatureMatch\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12G\n\x06format\x18\x02\x20\x01(\
    \x0e2/.vt.fileanalysis.SignatureMatch.SignatureFormatR\x06format\x12\x12\
    \n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x20\n\x0bdescription\x18\x04\
    \x20\x01(\tR\x0bdescription\x12\x18\n\x07authors\x18\x05\x20\x03(\tR\x07\
    authors\x12\x16\n\x06events\x18\x06\x20\x03(\tR\x06events\x12\x1d\n\nmat\
    ch_data\x18\x07\x20\x03(\tR\tmatchData\x12\x19\n\x08rule_src\x18\x08\x20\
    \x01(\tR\x07ruleSrc\x12;\n\x08severity\x18\t\x20\x01(\x0e2\x1f.vt.filean\
    alysis.ImpactSeverityR\x08severity\"\x99\x01\n\x0fSignatureFormat\x12\
    \x16\n\x12SIG_FORMAT_UNKNOWN\x10\0\x12\x13\n\x0fSIG_FORMAT_YARA\x10\x01\
    \x12\x14\n\x10SIG_FORMAT_SIGMA\x10\x02\x12\x13\n\x0fSIG_FORMAT_CAPA\x10\
    \x03\x12\x16\n\x12SIG_FORMAT_OPENIOC\x10\x04\x12\x16\n\x12SIG_FORMAT_KEY\
    WORD\x10\x05\"\x98\x01\n\x14MitreAttackTechnique\x12\x0e\n\x02id\x18\x01\
    \x20\x01(\tR\x02id\x12;\n\x08severity\x18\x02\x20\x01(\x0e2\x1f.vt.filea\
    nalysis.ImpactSeverityR\x08severity\x123\n\x15signature_description\x18\
    \x03\x20\x01(\tR\x14signatureDescription\"z\n\x16MalwareBehaviorCatalog\
    \x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x1c\n\tobjective\x18\x02\
    \x20\x01(\tR\tobjective\x12\x1a\n\x08behavior\x18\x03\x20\x01(\tR\x08beh\
    avior\x12\x16\n\x06method\x18\x04\x20\x01(\tR\x06method\"\xe1\x02\n\x0bP\
    rocessItem\x12\x1d\n\nprocess_id\x18\x01\x20\x01(\tR\tprocessId\x12*\n\
    \x11parent_process_id\x18\x02\x20\x01(\tR\x0fparentProcessId\x12\x12\n\
    \x04name\x18\x03\x20\x01(\tR\x04name\x12\x1d\n\nstart_time\x18\x04\x20\
    \x01(\x04R\tstartTime\x12)\n\x10termination_time\x18\x05\x20\x01(\x04R\
    \x0fterminationTime\x12!\n\x0cfiles_opened\x18\x06\x20\x03(\tR\x0bfilesO\
    pened\x12#\n\rfiles_written\x18\x07\x20\x03(\tR\x0cfilesWritten\x12#\n\r\
    files_deleted\x18\x08\x20\x03(\tR\x0cfilesDeleted\x12<\n\x0cfiles_copied\
    \x18\t\x20\x03(\x0b2\x19.vt.fileanalysis.FileCopyR\x0bfilesCopied*\xde\n\
    \n\x0cBehaviourTag\x12\x15\n\x11UNKNOWN_BEHAVIOUR\x10\0\x12\x1c\n\x18DET\
    ECT_DEBUG_ENVIRONMENT\x10\x01\x12\x1b\n\x17DIRECT_CPU_CLOCK_ACCESS\x10\
    \x02\x12\x0f\n\x0bLONG_SLEEPS\x10\x03\x12\x0f\n\x0bSELF_DELETE\x10\x04\
    \x12\x12\n\x0eHOSTS_MODIFIER\x10\x05\x12\x1e\n\x1aINSTALLS_BROWSER_EXTEN\
    SION\x10\x06\x12\x13\n\x0fPASSWORD_DIALOG\x10\x07\x12\x08\n\x04SUDO\x10\
    \x08\x12\x0f\n\x0bPERSISTENCE\x10\t\x12\r\n\tSENDS_SMS\x10\n\x12\x0e\n\n\
    CHECKS_GPS\x10\x0b\x12\x15\n\x11FTP_COMMUNICATION\x10\x0c\x12\x15\n\x11S\
    SH_COMMUNICATION\x10\r\x12\x18\n\x14TELNET_COMMUNICATION\x10\x0e\x12\x16\
    \n\x12SMTP_COMMUNICATION\x10\x0f\x12\x17\n\x13MYSQL_COMMUNICATION\x10\
    \x1a\x12\x15\n\x11IRC_COMMUNICATION\x10\x11\x12\x12\n\x0eSUSPICIOUS_DNS\
    \x10\x12\x12\x12\n\x0eSUSPICIOUS_UDP\x10\x13\x12\x10\n\x0cBIG_UPSTREAM\
    \x10\x14\x12\r\n\tTUNNELING\x10\x15\x12\n\n\x06CRYPTO\x10\x16\x12\r\n\tT\
    ELEPHONY\x10\x17\x12\x13\n\x0fRUNTIME_MODULES\x10\x18\x12\x0e\n\nREFLECT\
    ION\x10\x19\x12\x10\n\x0cDECRYPTS_EXE\x10\x1b\x12\x11\n\rMACRO_ENVIRON\
    \x10\x1c\x12\x13\n\x0fMACRO_OPEN_FILE\x10\x1d\x12\x14\n\x10MACRO_WRITE_F\
    ILE\x10\x1e\x12\x15\n\x11MACRO_HANDLE_FILE\x10\x1f\x12\x13\n\x0fMACRO_CO\
    PY_FILE\x10\x20\x12\x15\n\x11MACRO_CREATE_FILE\x10!\x12\x12\n\x0eMACRO_R\
    UN_FILE\x10\"\x12\x12\n\x0eMACRO_HIDE_APP\x10#\x12\x14\n\x10MACRO_POWERS\
    HELL\x10$\x12\x14\n\x10MACRO_CREATE_DIR\x10%\x12\x17\n\x13MACRO_SAVE_WOR\
    KBOOK\x10&\x12\x14\n\x10MACRO_CREATE_OLE\x10'\x12\x16\n\x12MACRO_ENUM_WI\
    NDOWS\x10(\x12\x11\n\rMACRO_RUN_DLL\x10)\x12\x16\n\x12MACRO_DOWNLOAD_URL\
    \x10*\x12\x13\n\x0fMACRO_SEND_KEYS\x10+\x12\x12\n\x0eMACRO_REGISTRY\x10,\
    \x12\x17\n\x13MACRO_ANTI_ANALYSIS\x10-\x12\x0e\n\nOBFUSCATED\x10.\x12\r\
    \n\tCLIPBOARD\x10/\x12\x13\n\x0fCHECKS_CPU_NAME\x100\x12\x15\n\x11CHECKS\
    _DISK_SPACE\x101\x12\x1b\n\x17CHECKS_MEMORY_AVAILABLE\x102\x12\x13\n\x0f\
    CHECKS_HOSTNAME\x103\x12\x1b\n\x17CHECKS_NETWORK_ADAPTERS\x104\x12\x0f\n\
    \x0bCHECKS_BIOS\x105\x12\x12\n\x0eCHECKS_PCI_BUS\x106\x12\x12\n\x0eCHECK\
    S_USB_BUS\x107\x12\x19\n\x15EXECUTES_DROPPED_FILE\x108\x12\x19\n\x15REPE\
    ATED_CLOCK_ACCESS\x109\x12\x15\n\x11CHECKS_USER_INPUT\x10:\x12\r\n\tCALL\
    S_WMI\x10;\x12\x11\n\rEVAL_FUNCTION\x10<\x12\x08\n\x04IDLE\x10=\x12\x10\
    \n\x0cSERVICE_SCAN\x10>\x12\x0b\n\x07LISTENS\x10?\x12\x15\n\x11SETS_PROC\
    ESS_NAME\x10@\x12\x0b\n\x07QR_CODE\x10A\x1a\x14\x92\x93\x19\x10\n\x0eBeh\
    aviourTrait*\xda\x01\n\nVerdictTag\x12\x13\n\x0fUNKNOWN_VERDICT\x10\0\
    \x12\t\n\x05CLEAN\x10\x01\x12\x0b\n\x07MALWARE\x10\x02\x12\x0c\n\x08GREY\
    WARE\x10\x03\x12\n\n\x06RANSOM\x10\x04\x12\x0c\n\x08PHISHING\x10\x05\x12\
    \n\n\x06BANKER\x10\x06\x12\n\n\x06ADWARE\x10\x07\x12\x0b\n\x07EXPLOIT\
    \x10\x08\x12\n\n\x06EVADER\x10\t\x12\x07\n\x03RAT\x10\n\x12\n\n\x06TROJA\
    N\x10\x0b\x12\x0c\n\x08SPREADER\x10\x0c\x12\x0b\n\x07STEALER\x10\r\x1a\
    \x16\x92\x93\x19\x12\n\x10BehaviourVerdict*\x96\x01\n\x0eImpactSeverity\
    \x12\x1b\n\x17IMPACT_SEVERITY_UNKNOWN\x10\0\x12\x18\n\x14IMPACT_SEVERITY\
    _INFO\x10\x01\x12\x17\n\x13IMPACT_SEVERITY_LOW\x10\x02\x12\x1a\n\x16IMPA\
    CT_SEVERITY_MEDIUM\x10\x03\x12\x18\n\x14IMPACT_SEVERITY_HIGH\x10\x04b\
    \x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(4);
            deps.push(super::filetypes::file_descriptor().clone());
            deps.push(super::sigma::file_descriptor().clone());
            deps.push(super::net_analysis::file_descriptor().clone());
            deps.push(super::yara::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(15);
            messages.push(BehaviourSummary::generated_message_descriptor_data());
            messages.push(TLS::generated_message_descriptor_data());
            messages.push(FileCopy::generated_message_descriptor_data());
            messages.push(DroppedFile::generated_message_descriptor_data());
            messages.push(PermissionCheck::generated_message_descriptor_data());
            messages.push(KeyValue::generated_message_descriptor_data());
            messages.push(HttpConversation::generated_message_descriptor_data());
            messages.push(DnsLookup::generated_message_descriptor_data());
            messages.push(IpTraffic::generated_message_descriptor_data());
            messages.push(SmtpConversation::generated_message_descriptor_data());
            messages.push(Sms::generated_message_descriptor_data());
            messages.push(SignatureMatch::generated_message_descriptor_data());
            messages.push(MitreAttackTechnique::generated_message_descriptor_data());
            messages.push(MalwareBehaviorCatalog::generated_message_descriptor_data());
            messages.push(ProcessItem::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(6);
            enums.push(BehaviourTag::generated_enum_descriptor_data());
            enums.push(VerdictTag::generated_enum_descriptor_data());
            enums.push(ImpactSeverity::generated_enum_descriptor_data());
            enums.push(http_conversation::RequestMethod::generated_enum_descriptor_data());
            enums.push(ip_traffic::TransportLayerProtocol::generated_enum_descriptor_data());
            enums.push(signature_match::SignatureFormat::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
