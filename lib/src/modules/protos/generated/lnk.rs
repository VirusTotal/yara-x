// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `lnk.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

// @@protoc_insertion_point(message:lnk.Lnk)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Lnk {
    // message fields
    // @@protoc_insertion_point(field:lnk.Lnk.is_lnk)
    pub is_lnk: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:lnk.Lnk.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:lnk.Lnk.creation_time)
    pub creation_time: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:lnk.Lnk.access_time)
    pub access_time: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:lnk.Lnk.write_time)
    pub write_time: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:lnk.Lnk.file_size)
    pub file_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:lnk.Lnk.file_attributes)
    pub file_attributes: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:lnk.Lnk.icon_location)
    pub icon_location: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:lnk.Lnk.icon_index)
    pub icon_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:lnk.Lnk.show_command)
    pub show_command: ::std::option::Option<::protobuf::EnumOrUnknown<ShowCommand>>,
    // @@protoc_insertion_point(field:lnk.Lnk.drive_type)
    pub drive_type: ::std::option::Option<::protobuf::EnumOrUnknown<DriveType>>,
    // @@protoc_insertion_point(field:lnk.Lnk.drive_serial_number)
    pub drive_serial_number: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:lnk.Lnk.volume_label)
    pub volume_label: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:lnk.Lnk.local_base_path)
    pub local_base_path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:lnk.Lnk.common_path_suffix)
    pub common_path_suffix: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:lnk.Lnk.relative_path)
    pub relative_path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:lnk.Lnk.working_dir)
    pub working_dir: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:lnk.Lnk.cmd_line_args)
    pub cmd_line_args: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:lnk.Lnk.overlay_size)
    pub overlay_size: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:lnk.Lnk.overlay_offset)
    pub overlay_offset: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:lnk.Lnk.tracker_data)
    pub tracker_data: ::protobuf::MessageField<TrackerData>,
    // special fields
    // @@protoc_insertion_point(special_field:lnk.Lnk.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Lnk {
    fn default() -> &'a Lnk {
        <Lnk as ::protobuf::Message>::default_instance()
    }
}

impl Lnk {
    pub fn new() -> Lnk {
        ::std::default::Default::default()
    }

    // required bool is_lnk = 1;

    pub fn is_lnk(&self) -> bool {
        self.is_lnk.unwrap_or(false)
    }

    pub fn clear_is_lnk(&mut self) {
        self.is_lnk = ::std::option::Option::None;
    }

    pub fn has_is_lnk(&self) -> bool {
        self.is_lnk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_lnk(&mut self, v: bool) {
        self.is_lnk = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 creation_time = 3;

    pub fn creation_time(&self) -> u64 {
        self.creation_time.unwrap_or(0)
    }

    pub fn clear_creation_time(&mut self) {
        self.creation_time = ::std::option::Option::None;
    }

    pub fn has_creation_time(&self) -> bool {
        self.creation_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creation_time(&mut self, v: u64) {
        self.creation_time = ::std::option::Option::Some(v);
    }

    // optional uint64 access_time = 4;

    pub fn access_time(&self) -> u64 {
        self.access_time.unwrap_or(0)
    }

    pub fn clear_access_time(&mut self) {
        self.access_time = ::std::option::Option::None;
    }

    pub fn has_access_time(&self) -> bool {
        self.access_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_access_time(&mut self, v: u64) {
        self.access_time = ::std::option::Option::Some(v);
    }

    // optional uint64 write_time = 5;

    pub fn write_time(&self) -> u64 {
        self.write_time.unwrap_or(0)
    }

    pub fn clear_write_time(&mut self) {
        self.write_time = ::std::option::Option::None;
    }

    pub fn has_write_time(&self) -> bool {
        self.write_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_write_time(&mut self, v: u64) {
        self.write_time = ::std::option::Option::Some(v);
    }

    // optional uint32 file_size = 6;

    pub fn file_size(&self) -> u32 {
        self.file_size.unwrap_or(0)
    }

    pub fn clear_file_size(&mut self) {
        self.file_size = ::std::option::Option::None;
    }

    pub fn has_file_size(&self) -> bool {
        self.file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: u32) {
        self.file_size = ::std::option::Option::Some(v);
    }

    // optional uint32 file_attributes = 7;

    pub fn file_attributes(&self) -> u32 {
        self.file_attributes.unwrap_or(0)
    }

    pub fn clear_file_attributes(&mut self) {
        self.file_attributes = ::std::option::Option::None;
    }

    pub fn has_file_attributes(&self) -> bool {
        self.file_attributes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_attributes(&mut self, v: u32) {
        self.file_attributes = ::std::option::Option::Some(v);
    }

    // optional string icon_location = 8;

    pub fn icon_location(&self) -> &str {
        match self.icon_location.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_icon_location(&mut self) {
        self.icon_location = ::std::option::Option::None;
    }

    pub fn has_icon_location(&self) -> bool {
        self.icon_location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon_location(&mut self, v: ::std::string::String) {
        self.icon_location = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon_location(&mut self) -> &mut ::std::string::String {
        if self.icon_location.is_none() {
            self.icon_location = ::std::option::Option::Some(::std::string::String::new());
        }
        self.icon_location.as_mut().unwrap()
    }

    // Take field
    pub fn take_icon_location(&mut self) -> ::std::string::String {
        self.icon_location.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 icon_index = 9;

    pub fn icon_index(&self) -> u32 {
        self.icon_index.unwrap_or(0)
    }

    pub fn clear_icon_index(&mut self) {
        self.icon_index = ::std::option::Option::None;
    }

    pub fn has_icon_index(&self) -> bool {
        self.icon_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon_index(&mut self, v: u32) {
        self.icon_index = ::std::option::Option::Some(v);
    }

    // optional .lnk.ShowCommand show_command = 10;

    pub fn show_command(&self) -> ShowCommand {
        match self.show_command {
            Some(e) => e.enum_value_or(ShowCommand::NORMAL),
            None => ShowCommand::NORMAL,
        }
    }

    pub fn clear_show_command(&mut self) {
        self.show_command = ::std::option::Option::None;
    }

    pub fn has_show_command(&self) -> bool {
        self.show_command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_command(&mut self, v: ShowCommand) {
        self.show_command = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .lnk.DriveType drive_type = 11;

    pub fn drive_type(&self) -> DriveType {
        match self.drive_type {
            Some(e) => e.enum_value_or(DriveType::UNKNOWN),
            None => DriveType::UNKNOWN,
        }
    }

    pub fn clear_drive_type(&mut self) {
        self.drive_type = ::std::option::Option::None;
    }

    pub fn has_drive_type(&self) -> bool {
        self.drive_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_drive_type(&mut self, v: DriveType) {
        self.drive_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 drive_serial_number = 12;

    pub fn drive_serial_number(&self) -> u32 {
        self.drive_serial_number.unwrap_or(0)
    }

    pub fn clear_drive_serial_number(&mut self) {
        self.drive_serial_number = ::std::option::Option::None;
    }

    pub fn has_drive_serial_number(&self) -> bool {
        self.drive_serial_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_drive_serial_number(&mut self, v: u32) {
        self.drive_serial_number = ::std::option::Option::Some(v);
    }

    // optional string volume_label = 13;

    pub fn volume_label(&self) -> &str {
        match self.volume_label.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_volume_label(&mut self) {
        self.volume_label = ::std::option::Option::None;
    }

    pub fn has_volume_label(&self) -> bool {
        self.volume_label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volume_label(&mut self, v: ::std::string::String) {
        self.volume_label = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volume_label(&mut self) -> &mut ::std::string::String {
        if self.volume_label.is_none() {
            self.volume_label = ::std::option::Option::Some(::std::string::String::new());
        }
        self.volume_label.as_mut().unwrap()
    }

    // Take field
    pub fn take_volume_label(&mut self) -> ::std::string::String {
        self.volume_label.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string local_base_path = 14;

    pub fn local_base_path(&self) -> &str {
        match self.local_base_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_local_base_path(&mut self) {
        self.local_base_path = ::std::option::Option::None;
    }

    pub fn has_local_base_path(&self) -> bool {
        self.local_base_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_base_path(&mut self, v: ::std::string::String) {
        self.local_base_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local_base_path(&mut self) -> &mut ::std::string::String {
        if self.local_base_path.is_none() {
            self.local_base_path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.local_base_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_local_base_path(&mut self) -> ::std::string::String {
        self.local_base_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string common_path_suffix = 15;

    pub fn common_path_suffix(&self) -> &str {
        match self.common_path_suffix.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_common_path_suffix(&mut self) {
        self.common_path_suffix = ::std::option::Option::None;
    }

    pub fn has_common_path_suffix(&self) -> bool {
        self.common_path_suffix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common_path_suffix(&mut self, v: ::std::string::String) {
        self.common_path_suffix = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common_path_suffix(&mut self) -> &mut ::std::string::String {
        if self.common_path_suffix.is_none() {
            self.common_path_suffix = ::std::option::Option::Some(::std::string::String::new());
        }
        self.common_path_suffix.as_mut().unwrap()
    }

    // Take field
    pub fn take_common_path_suffix(&mut self) -> ::std::string::String {
        self.common_path_suffix.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string relative_path = 16;

    pub fn relative_path(&self) -> &str {
        match self.relative_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_relative_path(&mut self) {
        self.relative_path = ::std::option::Option::None;
    }

    pub fn has_relative_path(&self) -> bool {
        self.relative_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relative_path(&mut self, v: ::std::string::String) {
        self.relative_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_relative_path(&mut self) -> &mut ::std::string::String {
        if self.relative_path.is_none() {
            self.relative_path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.relative_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_relative_path(&mut self) -> ::std::string::String {
        self.relative_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string working_dir = 17;

    pub fn working_dir(&self) -> &str {
        match self.working_dir.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_working_dir(&mut self) {
        self.working_dir = ::std::option::Option::None;
    }

    pub fn has_working_dir(&self) -> bool {
        self.working_dir.is_some()
    }

    // Param is passed by value, moved
    pub fn set_working_dir(&mut self, v: ::std::string::String) {
        self.working_dir = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_working_dir(&mut self) -> &mut ::std::string::String {
        if self.working_dir.is_none() {
            self.working_dir = ::std::option::Option::Some(::std::string::String::new());
        }
        self.working_dir.as_mut().unwrap()
    }

    // Take field
    pub fn take_working_dir(&mut self) -> ::std::string::String {
        self.working_dir.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string cmd_line_args = 18;

    pub fn cmd_line_args(&self) -> &str {
        match self.cmd_line_args.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_cmd_line_args(&mut self) {
        self.cmd_line_args = ::std::option::Option::None;
    }

    pub fn has_cmd_line_args(&self) -> bool {
        self.cmd_line_args.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cmd_line_args(&mut self, v: ::std::string::String) {
        self.cmd_line_args = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cmd_line_args(&mut self) -> &mut ::std::string::String {
        if self.cmd_line_args.is_none() {
            self.cmd_line_args = ::std::option::Option::Some(::std::string::String::new());
        }
        self.cmd_line_args.as_mut().unwrap()
    }

    // Take field
    pub fn take_cmd_line_args(&mut self) -> ::std::string::String {
        self.cmd_line_args.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 overlay_size = 19;

    pub fn overlay_size(&self) -> u64 {
        self.overlay_size.unwrap_or(0)
    }

    pub fn clear_overlay_size(&mut self) {
        self.overlay_size = ::std::option::Option::None;
    }

    pub fn has_overlay_size(&self) -> bool {
        self.overlay_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overlay_size(&mut self, v: u64) {
        self.overlay_size = ::std::option::Option::Some(v);
    }

    // optional uint64 overlay_offset = 20;

    pub fn overlay_offset(&self) -> u64 {
        self.overlay_offset.unwrap_or(0)
    }

    pub fn clear_overlay_offset(&mut self) {
        self.overlay_offset = ::std::option::Option::None;
    }

    pub fn has_overlay_offset(&self) -> bool {
        self.overlay_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overlay_offset(&mut self, v: u64) {
        self.overlay_offset = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(21);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_lnk",
            |m: &Lnk| { &m.is_lnk },
            |m: &mut Lnk| { &mut m.is_lnk },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &Lnk| { &m.name },
            |m: &mut Lnk| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "creation_time",
            |m: &Lnk| { &m.creation_time },
            |m: &mut Lnk| { &mut m.creation_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "access_time",
            |m: &Lnk| { &m.access_time },
            |m: &mut Lnk| { &mut m.access_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "write_time",
            |m: &Lnk| { &m.write_time },
            |m: &mut Lnk| { &mut m.write_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_size",
            |m: &Lnk| { &m.file_size },
            |m: &mut Lnk| { &mut m.file_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_attributes",
            |m: &Lnk| { &m.file_attributes },
            |m: &mut Lnk| { &mut m.file_attributes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "icon_location",
            |m: &Lnk| { &m.icon_location },
            |m: &mut Lnk| { &mut m.icon_location },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "icon_index",
            |m: &Lnk| { &m.icon_index },
            |m: &mut Lnk| { &mut m.icon_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "show_command",
            |m: &Lnk| { &m.show_command },
            |m: &mut Lnk| { &mut m.show_command },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "drive_type",
            |m: &Lnk| { &m.drive_type },
            |m: &mut Lnk| { &mut m.drive_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "drive_serial_number",
            |m: &Lnk| { &m.drive_serial_number },
            |m: &mut Lnk| { &mut m.drive_serial_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "volume_label",
            |m: &Lnk| { &m.volume_label },
            |m: &mut Lnk| { &mut m.volume_label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "local_base_path",
            |m: &Lnk| { &m.local_base_path },
            |m: &mut Lnk| { &mut m.local_base_path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "common_path_suffix",
            |m: &Lnk| { &m.common_path_suffix },
            |m: &mut Lnk| { &mut m.common_path_suffix },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "relative_path",
            |m: &Lnk| { &m.relative_path },
            |m: &mut Lnk| { &mut m.relative_path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "working_dir",
            |m: &Lnk| { &m.working_dir },
            |m: &mut Lnk| { &mut m.working_dir },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cmd_line_args",
            |m: &Lnk| { &m.cmd_line_args },
            |m: &mut Lnk| { &mut m.cmd_line_args },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "overlay_size",
            |m: &Lnk| { &m.overlay_size },
            |m: &mut Lnk| { &mut m.overlay_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "overlay_offset",
            |m: &Lnk| { &m.overlay_offset },
            |m: &mut Lnk| { &mut m.overlay_offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TrackerData>(
            "tracker_data",
            |m: &Lnk| { &m.tracker_data },
            |m: &mut Lnk| { &mut m.tracker_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Lnk>(
            "Lnk",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Lnk {
    const NAME: &'static str = "Lnk";

    fn is_initialized(&self) -> bool {
        if self.is_lnk.is_none() {
            return false;
        }
        for v in &self.tracker_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_lnk = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.creation_time = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.access_time = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.write_time = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.file_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.file_attributes = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.icon_location = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.icon_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.show_command = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                88 => {
                    self.drive_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                96 => {
                    self.drive_serial_number = ::std::option::Option::Some(is.read_uint32()?);
                },
                106 => {
                    self.volume_label = ::std::option::Option::Some(is.read_string()?);
                },
                114 => {
                    self.local_base_path = ::std::option::Option::Some(is.read_string()?);
                },
                122 => {
                    self.common_path_suffix = ::std::option::Option::Some(is.read_string()?);
                },
                130 => {
                    self.relative_path = ::std::option::Option::Some(is.read_string()?);
                },
                138 => {
                    self.working_dir = ::std::option::Option::Some(is.read_string()?);
                },
                146 => {
                    self.cmd_line_args = ::std::option::Option::Some(is.read_string()?);
                },
                152 => {
                    self.overlay_size = ::std::option::Option::Some(is.read_uint64()?);
                },
                160 => {
                    self.overlay_offset = ::std::option::Option::Some(is.read_uint64()?);
                },
                170 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tracker_data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.is_lnk {
            my_size += 1 + 1;
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.creation_time {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.access_time {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.write_time {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.file_size {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.file_attributes {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.icon_location.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.icon_index {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.show_command {
            my_size += ::protobuf::rt::int32_size(10, v.value());
        }
        if let Some(v) = self.drive_type {
            my_size += ::protobuf::rt::int32_size(11, v.value());
        }
        if let Some(v) = self.drive_serial_number {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.volume_label.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.local_base_path.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.common_path_suffix.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.relative_path.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        if let Some(v) = self.working_dir.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(v) = self.cmd_line_args.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        if let Some(v) = self.overlay_size {
            my_size += ::protobuf::rt::uint64_size(19, v);
        }
        if let Some(v) = self.overlay_offset {
            my_size += ::protobuf::rt::uint64_size(20, v);
        }
        if let Some(v) = self.tracker_data.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.is_lnk {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.creation_time {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.access_time {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.write_time {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.file_size {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.file_attributes {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.icon_location.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.icon_index {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.show_command {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.drive_type {
            os.write_enum(11, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.drive_serial_number {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.volume_label.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.local_base_path.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.common_path_suffix.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.relative_path.as_ref() {
            os.write_string(16, v)?;
        }
        if let Some(v) = self.working_dir.as_ref() {
            os.write_string(17, v)?;
        }
        if let Some(v) = self.cmd_line_args.as_ref() {
            os.write_string(18, v)?;
        }
        if let Some(v) = self.overlay_size {
            os.write_uint64(19, v)?;
        }
        if let Some(v) = self.overlay_offset {
            os.write_uint64(20, v)?;
        }
        if let Some(v) = self.tracker_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Lnk {
        Lnk::new()
    }

    fn clear(&mut self) {
        self.is_lnk = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.creation_time = ::std::option::Option::None;
        self.access_time = ::std::option::Option::None;
        self.write_time = ::std::option::Option::None;
        self.file_size = ::std::option::Option::None;
        self.file_attributes = ::std::option::Option::None;
        self.icon_location = ::std::option::Option::None;
        self.icon_index = ::std::option::Option::None;
        self.show_command = ::std::option::Option::None;
        self.drive_type = ::std::option::Option::None;
        self.drive_serial_number = ::std::option::Option::None;
        self.volume_label = ::std::option::Option::None;
        self.local_base_path = ::std::option::Option::None;
        self.common_path_suffix = ::std::option::Option::None;
        self.relative_path = ::std::option::Option::None;
        self.working_dir = ::std::option::Option::None;
        self.cmd_line_args = ::std::option::Option::None;
        self.overlay_size = ::std::option::Option::None;
        self.overlay_offset = ::std::option::Option::None;
        self.tracker_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Lnk {
        static instance: Lnk = Lnk {
            is_lnk: ::std::option::Option::None,
            name: ::std::option::Option::None,
            creation_time: ::std::option::Option::None,
            access_time: ::std::option::Option::None,
            write_time: ::std::option::Option::None,
            file_size: ::std::option::Option::None,
            file_attributes: ::std::option::Option::None,
            icon_location: ::std::option::Option::None,
            icon_index: ::std::option::Option::None,
            show_command: ::std::option::Option::None,
            drive_type: ::std::option::Option::None,
            drive_serial_number: ::std::option::Option::None,
            volume_label: ::std::option::Option::None,
            local_base_path: ::std::option::Option::None,
            common_path_suffix: ::std::option::Option::None,
            relative_path: ::std::option::Option::None,
            working_dir: ::std::option::Option::None,
            cmd_line_args: ::std::option::Option::None,
            overlay_size: ::std::option::Option::None,
            overlay_offset: ::std::option::Option::None,
            tracker_data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Lnk {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Lnk").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Lnk {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Lnk {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:lnk.TrackerData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrackerData {
    // message fields
    // @@protoc_insertion_point(field:lnk.TrackerData.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:lnk.TrackerData.machine_id)
    pub machine_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:lnk.TrackerData.droid_volume_id)
    pub droid_volume_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:lnk.TrackerData.droid_file_id)
    pub droid_file_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:lnk.TrackerData.droid_birth_volume_id)
    pub droid_birth_volume_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:lnk.TrackerData.droid_birth_file_id)
    pub droid_birth_file_id: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:lnk.TrackerData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrackerData {
    fn default() -> &'a TrackerData {
        <TrackerData as ::protobuf::Message>::default_instance()
    }
}

impl TrackerData {
    pub fn new() -> TrackerData {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional string machine_id = 2;

    pub fn machine_id(&self) -> &str {
        match self.machine_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_machine_id(&mut self) {
        self.machine_id = ::std::option::Option::None;
    }

    pub fn has_machine_id(&self) -> bool {
        self.machine_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine_id(&mut self, v: ::std::string::String) {
        self.machine_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machine_id(&mut self) -> &mut ::std::string::String {
        if self.machine_id.is_none() {
            self.machine_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.machine_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_machine_id(&mut self) -> ::std::string::String {
        self.machine_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string droid_volume_id = 3;

    pub fn droid_volume_id(&self) -> &str {
        match self.droid_volume_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_droid_volume_id(&mut self) {
        self.droid_volume_id = ::std::option::Option::None;
    }

    pub fn has_droid_volume_id(&self) -> bool {
        self.droid_volume_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_droid_volume_id(&mut self, v: ::std::string::String) {
        self.droid_volume_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_droid_volume_id(&mut self) -> &mut ::std::string::String {
        if self.droid_volume_id.is_none() {
            self.droid_volume_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.droid_volume_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_droid_volume_id(&mut self) -> ::std::string::String {
        self.droid_volume_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string droid_file_id = 4;

    pub fn droid_file_id(&self) -> &str {
        match self.droid_file_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_droid_file_id(&mut self) {
        self.droid_file_id = ::std::option::Option::None;
    }

    pub fn has_droid_file_id(&self) -> bool {
        self.droid_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_droid_file_id(&mut self, v: ::std::string::String) {
        self.droid_file_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_droid_file_id(&mut self) -> &mut ::std::string::String {
        if self.droid_file_id.is_none() {
            self.droid_file_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.droid_file_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_droid_file_id(&mut self) -> ::std::string::String {
        self.droid_file_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string droid_birth_volume_id = 5;

    pub fn droid_birth_volume_id(&self) -> &str {
        match self.droid_birth_volume_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_droid_birth_volume_id(&mut self) {
        self.droid_birth_volume_id = ::std::option::Option::None;
    }

    pub fn has_droid_birth_volume_id(&self) -> bool {
        self.droid_birth_volume_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_droid_birth_volume_id(&mut self, v: ::std::string::String) {
        self.droid_birth_volume_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_droid_birth_volume_id(&mut self) -> &mut ::std::string::String {
        if self.droid_birth_volume_id.is_none() {
            self.droid_birth_volume_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.droid_birth_volume_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_droid_birth_volume_id(&mut self) -> ::std::string::String {
        self.droid_birth_volume_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string droid_birth_file_id = 6;

    pub fn droid_birth_file_id(&self) -> &str {
        match self.droid_birth_file_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_droid_birth_file_id(&mut self) {
        self.droid_birth_file_id = ::std::option::Option::None;
    }

    pub fn has_droid_birth_file_id(&self) -> bool {
        self.droid_birth_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_droid_birth_file_id(&mut self, v: ::std::string::String) {
        self.droid_birth_file_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_droid_birth_file_id(&mut self) -> &mut ::std::string::String {
        if self.droid_birth_file_id.is_none() {
            self.droid_birth_file_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.droid_birth_file_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_droid_birth_file_id(&mut self) -> ::std::string::String {
        self.droid_birth_file_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &TrackerData| { &m.version },
            |m: &mut TrackerData| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "machine_id",
            |m: &TrackerData| { &m.machine_id },
            |m: &mut TrackerData| { &mut m.machine_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "droid_volume_id",
            |m: &TrackerData| { &m.droid_volume_id },
            |m: &mut TrackerData| { &mut m.droid_volume_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "droid_file_id",
            |m: &TrackerData| { &m.droid_file_id },
            |m: &mut TrackerData| { &mut m.droid_file_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "droid_birth_volume_id",
            |m: &TrackerData| { &m.droid_birth_volume_id },
            |m: &mut TrackerData| { &mut m.droid_birth_volume_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "droid_birth_file_id",
            |m: &TrackerData| { &m.droid_birth_file_id },
            |m: &mut TrackerData| { &mut m.droid_birth_file_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrackerData>(
            "TrackerData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrackerData {
    const NAME: &'static str = "TrackerData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.machine_id = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.droid_volume_id = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.droid_file_id = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.droid_birth_volume_id = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.droid_birth_file_id = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.machine_id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.droid_volume_id.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.droid_file_id.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.droid_birth_volume_id.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.droid_birth_file_id.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.machine_id.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.droid_volume_id.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.droid_file_id.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.droid_birth_volume_id.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.droid_birth_file_id.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrackerData {
        TrackerData::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.machine_id = ::std::option::Option::None;
        self.droid_volume_id = ::std::option::Option::None;
        self.droid_file_id = ::std::option::Option::None;
        self.droid_birth_volume_id = ::std::option::Option::None;
        self.droid_birth_file_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrackerData {
        static instance: TrackerData = TrackerData {
            version: ::std::option::Option::None,
            machine_id: ::std::option::Option::None,
            droid_volume_id: ::std::option::Option::None,
            droid_file_id: ::std::option::Option::None,
            droid_birth_volume_id: ::std::option::Option::None,
            droid_birth_file_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrackerData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrackerData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrackerData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrackerData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:lnk.FileAttributes)
pub enum FileAttributes {
    // @@protoc_insertion_point(enum_value:lnk.FileAttributes.FILE_ATTRIBUTE_READONLY)
    FILE_ATTRIBUTE_READONLY = 1,
    // @@protoc_insertion_point(enum_value:lnk.FileAttributes.FILE_ATTRIBUTE_HIDDEN)
    FILE_ATTRIBUTE_HIDDEN = 2,
    // @@protoc_insertion_point(enum_value:lnk.FileAttributes.FILE_ATTRIBUTE_SYSTEM)
    FILE_ATTRIBUTE_SYSTEM = 4,
    // @@protoc_insertion_point(enum_value:lnk.FileAttributes.RESERVED_1)
    RESERVED_1 = 8,
    // @@protoc_insertion_point(enum_value:lnk.FileAttributes.FILE_ATTRIBUTE_DIRECTORY)
    FILE_ATTRIBUTE_DIRECTORY = 16,
    // @@protoc_insertion_point(enum_value:lnk.FileAttributes.FILE_ATTRIBUTE_ARCHIVE)
    FILE_ATTRIBUTE_ARCHIVE = 32,
    // @@protoc_insertion_point(enum_value:lnk.FileAttributes.RESERVED_2)
    RESERVED_2 = 64,
    // @@protoc_insertion_point(enum_value:lnk.FileAttributes.FILE_ATTRIBUTE_NORMAL)
    FILE_ATTRIBUTE_NORMAL = 128,
    // @@protoc_insertion_point(enum_value:lnk.FileAttributes.FILE_ATTRIBUTE_TEMPORARY)
    FILE_ATTRIBUTE_TEMPORARY = 256,
    // @@protoc_insertion_point(enum_value:lnk.FileAttributes.FILE_ATTRIBUTE_SPARSE_FILE)
    FILE_ATTRIBUTE_SPARSE_FILE = 512,
    // @@protoc_insertion_point(enum_value:lnk.FileAttributes.FILE_ATTRIBUTE_REPARSE_POINT)
    FILE_ATTRIBUTE_REPARSE_POINT = 1024,
    // @@protoc_insertion_point(enum_value:lnk.FileAttributes.FILE_ATTRIBUTE_COMPRESSED)
    FILE_ATTRIBUTE_COMPRESSED = 2048,
    // @@protoc_insertion_point(enum_value:lnk.FileAttributes.FILE_ATTRIBUTE_OFFLINE)
    FILE_ATTRIBUTE_OFFLINE = 4096,
    // @@protoc_insertion_point(enum_value:lnk.FileAttributes.FILE_ATTRIBUTE_NOT_CONTENT_INDEXED)
    FILE_ATTRIBUTE_NOT_CONTENT_INDEXED = 8192,
    // @@protoc_insertion_point(enum_value:lnk.FileAttributes.FILE_ATTRIBUTE_ENCRYPTED)
    FILE_ATTRIBUTE_ENCRYPTED = 16384,
}

impl ::protobuf::Enum for FileAttributes {
    const NAME: &'static str = "FileAttributes";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FileAttributes> {
        match value {
            1 => ::std::option::Option::Some(FileAttributes::FILE_ATTRIBUTE_READONLY),
            2 => ::std::option::Option::Some(FileAttributes::FILE_ATTRIBUTE_HIDDEN),
            4 => ::std::option::Option::Some(FileAttributes::FILE_ATTRIBUTE_SYSTEM),
            8 => ::std::option::Option::Some(FileAttributes::RESERVED_1),
            16 => ::std::option::Option::Some(FileAttributes::FILE_ATTRIBUTE_DIRECTORY),
            32 => ::std::option::Option::Some(FileAttributes::FILE_ATTRIBUTE_ARCHIVE),
            64 => ::std::option::Option::Some(FileAttributes::RESERVED_2),
            128 => ::std::option::Option::Some(FileAttributes::FILE_ATTRIBUTE_NORMAL),
            256 => ::std::option::Option::Some(FileAttributes::FILE_ATTRIBUTE_TEMPORARY),
            512 => ::std::option::Option::Some(FileAttributes::FILE_ATTRIBUTE_SPARSE_FILE),
            1024 => ::std::option::Option::Some(FileAttributes::FILE_ATTRIBUTE_REPARSE_POINT),
            2048 => ::std::option::Option::Some(FileAttributes::FILE_ATTRIBUTE_COMPRESSED),
            4096 => ::std::option::Option::Some(FileAttributes::FILE_ATTRIBUTE_OFFLINE),
            8192 => ::std::option::Option::Some(FileAttributes::FILE_ATTRIBUTE_NOT_CONTENT_INDEXED),
            16384 => ::std::option::Option::Some(FileAttributes::FILE_ATTRIBUTE_ENCRYPTED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<FileAttributes> {
        match str {
            "FILE_ATTRIBUTE_READONLY" => ::std::option::Option::Some(FileAttributes::FILE_ATTRIBUTE_READONLY),
            "FILE_ATTRIBUTE_HIDDEN" => ::std::option::Option::Some(FileAttributes::FILE_ATTRIBUTE_HIDDEN),
            "FILE_ATTRIBUTE_SYSTEM" => ::std::option::Option::Some(FileAttributes::FILE_ATTRIBUTE_SYSTEM),
            "RESERVED_1" => ::std::option::Option::Some(FileAttributes::RESERVED_1),
            "FILE_ATTRIBUTE_DIRECTORY" => ::std::option::Option::Some(FileAttributes::FILE_ATTRIBUTE_DIRECTORY),
            "FILE_ATTRIBUTE_ARCHIVE" => ::std::option::Option::Some(FileAttributes::FILE_ATTRIBUTE_ARCHIVE),
            "RESERVED_2" => ::std::option::Option::Some(FileAttributes::RESERVED_2),
            "FILE_ATTRIBUTE_NORMAL" => ::std::option::Option::Some(FileAttributes::FILE_ATTRIBUTE_NORMAL),
            "FILE_ATTRIBUTE_TEMPORARY" => ::std::option::Option::Some(FileAttributes::FILE_ATTRIBUTE_TEMPORARY),
            "FILE_ATTRIBUTE_SPARSE_FILE" => ::std::option::Option::Some(FileAttributes::FILE_ATTRIBUTE_SPARSE_FILE),
            "FILE_ATTRIBUTE_REPARSE_POINT" => ::std::option::Option::Some(FileAttributes::FILE_ATTRIBUTE_REPARSE_POINT),
            "FILE_ATTRIBUTE_COMPRESSED" => ::std::option::Option::Some(FileAttributes::FILE_ATTRIBUTE_COMPRESSED),
            "FILE_ATTRIBUTE_OFFLINE" => ::std::option::Option::Some(FileAttributes::FILE_ATTRIBUTE_OFFLINE),
            "FILE_ATTRIBUTE_NOT_CONTENT_INDEXED" => ::std::option::Option::Some(FileAttributes::FILE_ATTRIBUTE_NOT_CONTENT_INDEXED),
            "FILE_ATTRIBUTE_ENCRYPTED" => ::std::option::Option::Some(FileAttributes::FILE_ATTRIBUTE_ENCRYPTED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [FileAttributes] = &[
        FileAttributes::FILE_ATTRIBUTE_READONLY,
        FileAttributes::FILE_ATTRIBUTE_HIDDEN,
        FileAttributes::FILE_ATTRIBUTE_SYSTEM,
        FileAttributes::RESERVED_1,
        FileAttributes::FILE_ATTRIBUTE_DIRECTORY,
        FileAttributes::FILE_ATTRIBUTE_ARCHIVE,
        FileAttributes::RESERVED_2,
        FileAttributes::FILE_ATTRIBUTE_NORMAL,
        FileAttributes::FILE_ATTRIBUTE_TEMPORARY,
        FileAttributes::FILE_ATTRIBUTE_SPARSE_FILE,
        FileAttributes::FILE_ATTRIBUTE_REPARSE_POINT,
        FileAttributes::FILE_ATTRIBUTE_COMPRESSED,
        FileAttributes::FILE_ATTRIBUTE_OFFLINE,
        FileAttributes::FILE_ATTRIBUTE_NOT_CONTENT_INDEXED,
        FileAttributes::FILE_ATTRIBUTE_ENCRYPTED,
    ];
}

impl ::protobuf::EnumFull for FileAttributes {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("FileAttributes").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            FileAttributes::FILE_ATTRIBUTE_READONLY => 0,
            FileAttributes::FILE_ATTRIBUTE_HIDDEN => 1,
            FileAttributes::FILE_ATTRIBUTE_SYSTEM => 2,
            FileAttributes::RESERVED_1 => 3,
            FileAttributes::FILE_ATTRIBUTE_DIRECTORY => 4,
            FileAttributes::FILE_ATTRIBUTE_ARCHIVE => 5,
            FileAttributes::RESERVED_2 => 6,
            FileAttributes::FILE_ATTRIBUTE_NORMAL => 7,
            FileAttributes::FILE_ATTRIBUTE_TEMPORARY => 8,
            FileAttributes::FILE_ATTRIBUTE_SPARSE_FILE => 9,
            FileAttributes::FILE_ATTRIBUTE_REPARSE_POINT => 10,
            FileAttributes::FILE_ATTRIBUTE_COMPRESSED => 11,
            FileAttributes::FILE_ATTRIBUTE_OFFLINE => 12,
            FileAttributes::FILE_ATTRIBUTE_NOT_CONTENT_INDEXED => 13,
            FileAttributes::FILE_ATTRIBUTE_ENCRYPTED => 14,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for FileAttributes {
    fn default() -> Self {
        FileAttributes::FILE_ATTRIBUTE_READONLY
    }
}

impl FileAttributes {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<FileAttributes>("FileAttributes")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:lnk.ShowCommand)
pub enum ShowCommand {
    // @@protoc_insertion_point(enum_value:lnk.ShowCommand.NORMAL)
    NORMAL = 1,
    // @@protoc_insertion_point(enum_value:lnk.ShowCommand.MAXIMIZED)
    MAXIMIZED = 3,
    // @@protoc_insertion_point(enum_value:lnk.ShowCommand.MIN_NO_ACTIVE)
    MIN_NO_ACTIVE = 7,
}

impl ::protobuf::Enum for ShowCommand {
    const NAME: &'static str = "ShowCommand";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ShowCommand> {
        match value {
            1 => ::std::option::Option::Some(ShowCommand::NORMAL),
            3 => ::std::option::Option::Some(ShowCommand::MAXIMIZED),
            7 => ::std::option::Option::Some(ShowCommand::MIN_NO_ACTIVE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ShowCommand> {
        match str {
            "NORMAL" => ::std::option::Option::Some(ShowCommand::NORMAL),
            "MAXIMIZED" => ::std::option::Option::Some(ShowCommand::MAXIMIZED),
            "MIN_NO_ACTIVE" => ::std::option::Option::Some(ShowCommand::MIN_NO_ACTIVE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ShowCommand] = &[
        ShowCommand::NORMAL,
        ShowCommand::MAXIMIZED,
        ShowCommand::MIN_NO_ACTIVE,
    ];
}

impl ::protobuf::EnumFull for ShowCommand {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ShowCommand").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ShowCommand::NORMAL => 0,
            ShowCommand::MAXIMIZED => 1,
            ShowCommand::MIN_NO_ACTIVE => 2,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ShowCommand {
    fn default() -> Self {
        ShowCommand::NORMAL
    }
}

impl ShowCommand {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ShowCommand>("ShowCommand")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:lnk.DriveType)
pub enum DriveType {
    // @@protoc_insertion_point(enum_value:lnk.DriveType.UNKNOWN)
    UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:lnk.DriveType.NO_ROOT_DIR)
    NO_ROOT_DIR = 1,
    // @@protoc_insertion_point(enum_value:lnk.DriveType.REMOVABLE)
    REMOVABLE = 2,
    // @@protoc_insertion_point(enum_value:lnk.DriveType.FIXED)
    FIXED = 3,
    // @@protoc_insertion_point(enum_value:lnk.DriveType.REMOTE)
    REMOTE = 4,
    // @@protoc_insertion_point(enum_value:lnk.DriveType.CDROM)
    CDROM = 5,
    // @@protoc_insertion_point(enum_value:lnk.DriveType.RAMDISK)
    RAMDISK = 6,
}

impl ::protobuf::Enum for DriveType {
    const NAME: &'static str = "DriveType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DriveType> {
        match value {
            0 => ::std::option::Option::Some(DriveType::UNKNOWN),
            1 => ::std::option::Option::Some(DriveType::NO_ROOT_DIR),
            2 => ::std::option::Option::Some(DriveType::REMOVABLE),
            3 => ::std::option::Option::Some(DriveType::FIXED),
            4 => ::std::option::Option::Some(DriveType::REMOTE),
            5 => ::std::option::Option::Some(DriveType::CDROM),
            6 => ::std::option::Option::Some(DriveType::RAMDISK),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DriveType> {
        match str {
            "UNKNOWN" => ::std::option::Option::Some(DriveType::UNKNOWN),
            "NO_ROOT_DIR" => ::std::option::Option::Some(DriveType::NO_ROOT_DIR),
            "REMOVABLE" => ::std::option::Option::Some(DriveType::REMOVABLE),
            "FIXED" => ::std::option::Option::Some(DriveType::FIXED),
            "REMOTE" => ::std::option::Option::Some(DriveType::REMOTE),
            "CDROM" => ::std::option::Option::Some(DriveType::CDROM),
            "RAMDISK" => ::std::option::Option::Some(DriveType::RAMDISK),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DriveType] = &[
        DriveType::UNKNOWN,
        DriveType::NO_ROOT_DIR,
        DriveType::REMOVABLE,
        DriveType::FIXED,
        DriveType::REMOTE,
        DriveType::CDROM,
        DriveType::RAMDISK,
    ];
}

impl ::protobuf::EnumFull for DriveType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DriveType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DriveType {
    fn default() -> Self {
        DriveType::UNKNOWN
    }
}

impl DriveType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DriveType>("DriveType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\tlnk.proto\x12\x03lnk\x1a\nyara.proto\"\x95\x06\n\x03Lnk\x12\x15\n\
    \x06is_lnk\x18\x01\x20\x02(\x08R\x05isLnk\x12\x12\n\x04name\x18\x02\x20\
    \x01(\tR\x04name\x12#\n\rcreation_time\x18\x03\x20\x01(\x04R\x0ccreation\
    Time\x12\x1f\n\x0baccess_time\x18\x04\x20\x01(\x04R\naccessTime\x12\x1d\
    \n\nwrite_time\x18\x05\x20\x01(\x04R\twriteTime\x12\x1b\n\tfile_size\x18\
    \x06\x20\x01(\rR\x08fileSize\x12'\n\x0ffile_attributes\x18\x07\x20\x01(\
    \rR\x0efileAttributes\x12#\n\ricon_location\x18\x08\x20\x01(\tR\x0ciconL\
    ocation\x12\x1d\n\nicon_index\x18\t\x20\x01(\rR\ticonIndex\x123\n\x0csho\
    w_command\x18\n\x20\x01(\x0e2\x10.lnk.ShowCommandR\x0bshowCommand\x12-\n\
    \ndrive_type\x18\x0b\x20\x01(\x0e2\x0e.lnk.DriveTypeR\tdriveType\x12.\n\
    \x13drive_serial_number\x18\x0c\x20\x01(\rR\x11driveSerialNumber\x12!\n\
    \x0cvolume_label\x18\r\x20\x01(\tR\x0bvolumeLabel\x12&\n\x0flocal_base_p\
    ath\x18\x0e\x20\x01(\tR\rlocalBasePath\x12,\n\x12common_path_suffix\x18\
    \x0f\x20\x01(\tR\x10commonPathSuffix\x12#\n\rrelative_path\x18\x10\x20\
    \x01(\tR\x0crelativePath\x12\x1f\n\x0bworking_dir\x18\x11\x20\x01(\tR\nw\
    orkingDir\x12\"\n\rcmd_line_args\x18\x12\x20\x01(\tR\x0bcmdLineArgs\x12!\
    \n\x0coverlay_size\x18\x13\x20\x01(\x04R\x0boverlaySize\x12%\n\x0eoverla\
    y_offset\x18\x14\x20\x01(\x04R\roverlayOffset\x123\n\x0ctracker_data\x18\
    \x15\x20\x01(\x0b2\x10.lnk.TrackerDataR\x0btrackerData\"\xf4\x01\n\x0bTr\
    ackerData\x12\x18\n\x07version\x18\x01\x20\x01(\rR\x07version\x12\x1d\n\
    \nmachine_id\x18\x02\x20\x01(\tR\tmachineId\x12&\n\x0fdroid_volume_id\
    \x18\x03\x20\x01(\tR\rdroidVolumeId\x12\"\n\rdroid_file_id\x18\x04\x20\
    \x01(\tR\x0bdroidFileId\x121\n\x15droid_birth_volume_id\x18\x05\x20\x01(\
    \tR\x12droidBirthVolumeId\x12-\n\x13droid_birth_file_id\x18\x06\x20\x01(\
    \tR\x10droidBirthFileId*\xca\x03\n\x0eFileAttributes\x12\x1b\n\x17FILE_A\
    TTRIBUTE_READONLY\x10\x01\x12\x19\n\x15FILE_ATTRIBUTE_HIDDEN\x10\x02\x12\
    \x19\n\x15FILE_ATTRIBUTE_SYSTEM\x10\x04\x12\x0e\n\nRESERVED_1\x10\x08\
    \x12\x1c\n\x18FILE_ATTRIBUTE_DIRECTORY\x10\x10\x12\x1a\n\x16FILE_ATTRIBU\
    TE_ARCHIVE\x10\x20\x12\x0e\n\nRESERVED_2\x10@\x12\x1a\n\x15FILE_ATTRIBUT\
    E_NORMAL\x10\x80\x01\x12\x1d\n\x18FILE_ATTRIBUTE_TEMPORARY\x10\x80\x02\
    \x12\x1f\n\x1aFILE_ATTRIBUTE_SPARSE_FILE\x10\x80\x04\x12!\n\x1cFILE_ATTR\
    IBUTE_REPARSE_POINT\x10\x80\x08\x12\x1e\n\x19FILE_ATTRIBUTE_COMPRESSED\
    \x10\x80\x10\x12\x1b\n\x16FILE_ATTRIBUTE_OFFLINE\x10\x80\x20\x12'\n\"FIL\
    E_ATTRIBUTE_NOT_CONTENT_INDEXED\x10\x80@\x12\x1e\n\x18FILE_ATTRIBUTE_ENC\
    RYPTED\x10\x80\x80\x01\x1a\x06\x92\x93\x19\x02\x10\x01*;\n\x0bShowComman\
    d\x12\n\n\x06NORMAL\x10\x01\x12\r\n\tMAXIMIZED\x10\x03\x12\x11\n\rMIN_NO\
    _ACTIVE\x10\x07*g\n\tDriveType\x12\x0b\n\x07UNKNOWN\x10\0\x12\x0f\n\x0bN\
    O_ROOT_DIR\x10\x01\x12\r\n\tREMOVABLE\x10\x02\x12\t\n\x05FIXED\x10\x03\
    \x12\n\n\x06REMOTE\x10\x04\x12\t\n\x05CDROM\x10\x05\x12\x0b\n\x07RAMDISK\
    \x10\x06B#\xfa\x92\x19\x1f\n\x03lnk\x12\x07lnk.Lnk\x1a\x03lnk\"\nlnk-mod\
    uleb\x06proto2\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::yara::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(2);
            messages.push(Lnk::generated_message_descriptor_data());
            messages.push(TrackerData::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(3);
            enums.push(FileAttributes::generated_enum_descriptor_data());
            enums.push(ShowCommand::generated_enum_descriptor_data());
            enums.push(DriveType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
