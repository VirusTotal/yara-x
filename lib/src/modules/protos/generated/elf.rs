// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `elf.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

// @@protoc_insertion_point(message:elf.ELF)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ELF {
    // message fields
    // @@protoc_insertion_point(field:elf.ELF.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<Type>>,
    // @@protoc_insertion_point(field:elf.ELF.machine)
    pub machine: ::std::option::Option<::protobuf::EnumOrUnknown<Machine>>,
    // @@protoc_insertion_point(field:elf.ELF.osabi)
    pub osabi: ::std::option::Option<::protobuf::EnumOrUnknown<OsAbi>>,
    // @@protoc_insertion_point(field:elf.ELF.entry_point)
    pub entry_point: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:elf.ELF.sh_offset)
    pub sh_offset: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:elf.ELF.sh_entry_size)
    pub sh_entry_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:elf.ELF.ph_offset)
    pub ph_offset: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:elf.ELF.ph_entry_size)
    pub ph_entry_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:elf.ELF.number_of_sections)
    pub number_of_sections: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:elf.ELF.number_of_segments)
    pub number_of_segments: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:elf.ELF.symtab_entries)
    pub symtab_entries: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:elf.ELF.dynsym_entries)
    pub dynsym_entries: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:elf.ELF.dynamic_section_entries)
    pub dynamic_section_entries: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:elf.ELF.sections)
    pub sections: ::std::vec::Vec<Section>,
    // @@protoc_insertion_point(field:elf.ELF.segments)
    pub segments: ::std::vec::Vec<Segment>,
    // @@protoc_insertion_point(field:elf.ELF.symtab)
    pub symtab: ::std::vec::Vec<Sym>,
    // @@protoc_insertion_point(field:elf.ELF.dynsym)
    pub dynsym: ::std::vec::Vec<Sym>,
    // @@protoc_insertion_point(field:elf.ELF.dynamic)
    pub dynamic: ::std::vec::Vec<Dyn>,
    // special fields
    // @@protoc_insertion_point(special_field:elf.ELF.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ELF {
    fn default() -> &'a ELF {
        <ELF as ::protobuf::Message>::default_instance()
    }
}

impl ELF {
    pub fn new() -> ELF {
        ::std::default::Default::default()
    }

    // optional .elf.Type type = 1;

    pub fn type_(&self) -> Type {
        match self.type_ {
            Some(e) => e.enum_value_or(Type::ET_NONE),
            None => Type::ET_NONE,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: Type) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .elf.Machine machine = 2;

    pub fn machine(&self) -> Machine {
        match self.machine {
            Some(e) => e.enum_value_or(Machine::EM_NONE),
            None => Machine::EM_NONE,
        }
    }

    pub fn clear_machine(&mut self) {
        self.machine = ::std::option::Option::None;
    }

    pub fn has_machine(&self) -> bool {
        self.machine.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine(&mut self, v: Machine) {
        self.machine = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .elf.OsAbi osabi = 18;

    pub fn osabi(&self) -> OsAbi {
        match self.osabi {
            Some(e) => e.enum_value_or(OsAbi::OSABI_NONE),
            None => OsAbi::OSABI_NONE,
        }
    }

    pub fn clear_osabi(&mut self) {
        self.osabi = ::std::option::Option::None;
    }

    pub fn has_osabi(&self) -> bool {
        self.osabi.is_some()
    }

    // Param is passed by value, moved
    pub fn set_osabi(&mut self, v: OsAbi) {
        self.osabi = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 entry_point = 3;

    pub fn entry_point(&self) -> u64 {
        self.entry_point.unwrap_or(0)
    }

    pub fn clear_entry_point(&mut self) {
        self.entry_point = ::std::option::Option::None;
    }

    pub fn has_entry_point(&self) -> bool {
        self.entry_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entry_point(&mut self, v: u64) {
        self.entry_point = ::std::option::Option::Some(v);
    }

    // optional uint64 sh_offset = 4;

    pub fn sh_offset(&self) -> u64 {
        self.sh_offset.unwrap_or(0)
    }

    pub fn clear_sh_offset(&mut self) {
        self.sh_offset = ::std::option::Option::None;
    }

    pub fn has_sh_offset(&self) -> bool {
        self.sh_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sh_offset(&mut self, v: u64) {
        self.sh_offset = ::std::option::Option::Some(v);
    }

    // optional uint32 sh_entry_size = 5;

    pub fn sh_entry_size(&self) -> u32 {
        self.sh_entry_size.unwrap_or(0)
    }

    pub fn clear_sh_entry_size(&mut self) {
        self.sh_entry_size = ::std::option::Option::None;
    }

    pub fn has_sh_entry_size(&self) -> bool {
        self.sh_entry_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sh_entry_size(&mut self, v: u32) {
        self.sh_entry_size = ::std::option::Option::Some(v);
    }

    // optional uint64 ph_offset = 6;

    pub fn ph_offset(&self) -> u64 {
        self.ph_offset.unwrap_or(0)
    }

    pub fn clear_ph_offset(&mut self) {
        self.ph_offset = ::std::option::Option::None;
    }

    pub fn has_ph_offset(&self) -> bool {
        self.ph_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ph_offset(&mut self, v: u64) {
        self.ph_offset = ::std::option::Option::Some(v);
    }

    // optional uint32 ph_entry_size = 7;

    pub fn ph_entry_size(&self) -> u32 {
        self.ph_entry_size.unwrap_or(0)
    }

    pub fn clear_ph_entry_size(&mut self) {
        self.ph_entry_size = ::std::option::Option::None;
    }

    pub fn has_ph_entry_size(&self) -> bool {
        self.ph_entry_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ph_entry_size(&mut self, v: u32) {
        self.ph_entry_size = ::std::option::Option::Some(v);
    }

    // optional uint64 number_of_sections = 8;

    pub fn number_of_sections(&self) -> u64 {
        self.number_of_sections.unwrap_or(0)
    }

    pub fn clear_number_of_sections(&mut self) {
        self.number_of_sections = ::std::option::Option::None;
    }

    pub fn has_number_of_sections(&self) -> bool {
        self.number_of_sections.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number_of_sections(&mut self, v: u64) {
        self.number_of_sections = ::std::option::Option::Some(v);
    }

    // optional uint64 number_of_segments = 9;

    pub fn number_of_segments(&self) -> u64 {
        self.number_of_segments.unwrap_or(0)
    }

    pub fn clear_number_of_segments(&mut self) {
        self.number_of_segments = ::std::option::Option::None;
    }

    pub fn has_number_of_segments(&self) -> bool {
        self.number_of_segments.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number_of_segments(&mut self, v: u64) {
        self.number_of_segments = ::std::option::Option::Some(v);
    }

    // optional uint64 symtab_entries = 10;

    pub fn symtab_entries(&self) -> u64 {
        self.symtab_entries.unwrap_or(0)
    }

    pub fn clear_symtab_entries(&mut self) {
        self.symtab_entries = ::std::option::Option::None;
    }

    pub fn has_symtab_entries(&self) -> bool {
        self.symtab_entries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_symtab_entries(&mut self, v: u64) {
        self.symtab_entries = ::std::option::Option::Some(v);
    }

    // optional uint64 dynsym_entries = 11;

    pub fn dynsym_entries(&self) -> u64 {
        self.dynsym_entries.unwrap_or(0)
    }

    pub fn clear_dynsym_entries(&mut self) {
        self.dynsym_entries = ::std::option::Option::None;
    }

    pub fn has_dynsym_entries(&self) -> bool {
        self.dynsym_entries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dynsym_entries(&mut self, v: u64) {
        self.dynsym_entries = ::std::option::Option::Some(v);
    }

    // optional uint64 dynamic_section_entries = 12;

    pub fn dynamic_section_entries(&self) -> u64 {
        self.dynamic_section_entries.unwrap_or(0)
    }

    pub fn clear_dynamic_section_entries(&mut self) {
        self.dynamic_section_entries = ::std::option::Option::None;
    }

    pub fn has_dynamic_section_entries(&self) -> bool {
        self.dynamic_section_entries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dynamic_section_entries(&mut self, v: u64) {
        self.dynamic_section_entries = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(18);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &ELF| { &m.type_ },
            |m: &mut ELF| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "machine",
            |m: &ELF| { &m.machine },
            |m: &mut ELF| { &mut m.machine },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "osabi",
            |m: &ELF| { &m.osabi },
            |m: &mut ELF| { &mut m.osabi },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entry_point",
            |m: &ELF| { &m.entry_point },
            |m: &mut ELF| { &mut m.entry_point },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sh_offset",
            |m: &ELF| { &m.sh_offset },
            |m: &mut ELF| { &mut m.sh_offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sh_entry_size",
            |m: &ELF| { &m.sh_entry_size },
            |m: &mut ELF| { &mut m.sh_entry_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ph_offset",
            |m: &ELF| { &m.ph_offset },
            |m: &mut ELF| { &mut m.ph_offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ph_entry_size",
            |m: &ELF| { &m.ph_entry_size },
            |m: &mut ELF| { &mut m.ph_entry_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "number_of_sections",
            |m: &ELF| { &m.number_of_sections },
            |m: &mut ELF| { &mut m.number_of_sections },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "number_of_segments",
            |m: &ELF| { &m.number_of_segments },
            |m: &mut ELF| { &mut m.number_of_segments },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "symtab_entries",
            |m: &ELF| { &m.symtab_entries },
            |m: &mut ELF| { &mut m.symtab_entries },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dynsym_entries",
            |m: &ELF| { &m.dynsym_entries },
            |m: &mut ELF| { &mut m.dynsym_entries },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dynamic_section_entries",
            |m: &ELF| { &m.dynamic_section_entries },
            |m: &mut ELF| { &mut m.dynamic_section_entries },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sections",
            |m: &ELF| { &m.sections },
            |m: &mut ELF| { &mut m.sections },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "segments",
            |m: &ELF| { &m.segments },
            |m: &mut ELF| { &mut m.segments },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "symtab",
            |m: &ELF| { &m.symtab },
            |m: &mut ELF| { &mut m.symtab },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dynsym",
            |m: &ELF| { &m.dynsym },
            |m: &mut ELF| { &mut m.dynsym },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dynamic",
            |m: &ELF| { &m.dynamic },
            |m: &mut ELF| { &mut m.dynamic },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ELF>(
            "ELF",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ELF {
    const NAME: &'static str = "ELF";

    fn is_initialized(&self) -> bool {
        for v in &self.sections {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.segments {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.symtab {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dynsym {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dynamic {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.machine = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                144 => {
                    self.osabi = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.entry_point = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.sh_offset = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.sh_entry_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.ph_offset = ::std::option::Option::Some(is.read_uint64()?);
                },
                56 => {
                    self.ph_entry_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.number_of_sections = ::std::option::Option::Some(is.read_uint64()?);
                },
                72 => {
                    self.number_of_segments = ::std::option::Option::Some(is.read_uint64()?);
                },
                80 => {
                    self.symtab_entries = ::std::option::Option::Some(is.read_uint64()?);
                },
                88 => {
                    self.dynsym_entries = ::std::option::Option::Some(is.read_uint64()?);
                },
                96 => {
                    self.dynamic_section_entries = ::std::option::Option::Some(is.read_uint64()?);
                },
                106 => {
                    self.sections.push(is.read_message()?);
                },
                114 => {
                    self.segments.push(is.read_message()?);
                },
                122 => {
                    self.symtab.push(is.read_message()?);
                },
                130 => {
                    self.dynsym.push(is.read_message()?);
                },
                138 => {
                    self.dynamic.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.machine {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.osabi {
            my_size += ::protobuf::rt::int32_size(18, v.value());
        }
        if let Some(v) = self.entry_point {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.sh_offset {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.sh_entry_size {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.ph_offset {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.ph_entry_size {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.number_of_sections {
            my_size += ::protobuf::rt::uint64_size(8, v);
        }
        if let Some(v) = self.number_of_segments {
            my_size += ::protobuf::rt::uint64_size(9, v);
        }
        if let Some(v) = self.symtab_entries {
            my_size += ::protobuf::rt::uint64_size(10, v);
        }
        if let Some(v) = self.dynsym_entries {
            my_size += ::protobuf::rt::uint64_size(11, v);
        }
        if let Some(v) = self.dynamic_section_entries {
            my_size += ::protobuf::rt::uint64_size(12, v);
        }
        for value in &self.sections {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.segments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.symtab {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.dynsym {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.dynamic {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.machine {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.osabi {
            os.write_enum(18, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.entry_point {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.sh_offset {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.sh_entry_size {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.ph_offset {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.ph_entry_size {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.number_of_sections {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.number_of_segments {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.symtab_entries {
            os.write_uint64(10, v)?;
        }
        if let Some(v) = self.dynsym_entries {
            os.write_uint64(11, v)?;
        }
        if let Some(v) = self.dynamic_section_entries {
            os.write_uint64(12, v)?;
        }
        for v in &self.sections {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        for v in &self.segments {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        };
        for v in &self.symtab {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        };
        for v in &self.dynsym {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        };
        for v in &self.dynamic {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ELF {
        ELF::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.machine = ::std::option::Option::None;
        self.osabi = ::std::option::Option::None;
        self.entry_point = ::std::option::Option::None;
        self.sh_offset = ::std::option::Option::None;
        self.sh_entry_size = ::std::option::Option::None;
        self.ph_offset = ::std::option::Option::None;
        self.ph_entry_size = ::std::option::Option::None;
        self.number_of_sections = ::std::option::Option::None;
        self.number_of_segments = ::std::option::Option::None;
        self.symtab_entries = ::std::option::Option::None;
        self.dynsym_entries = ::std::option::Option::None;
        self.dynamic_section_entries = ::std::option::Option::None;
        self.sections.clear();
        self.segments.clear();
        self.symtab.clear();
        self.dynsym.clear();
        self.dynamic.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ELF {
        static instance: ELF = ELF {
            type_: ::std::option::Option::None,
            machine: ::std::option::Option::None,
            osabi: ::std::option::Option::None,
            entry_point: ::std::option::Option::None,
            sh_offset: ::std::option::Option::None,
            sh_entry_size: ::std::option::Option::None,
            ph_offset: ::std::option::Option::None,
            ph_entry_size: ::std::option::Option::None,
            number_of_sections: ::std::option::Option::None,
            number_of_segments: ::std::option::Option::None,
            symtab_entries: ::std::option::Option::None,
            dynsym_entries: ::std::option::Option::None,
            dynamic_section_entries: ::std::option::Option::None,
            sections: ::std::vec::Vec::new(),
            segments: ::std::vec::Vec::new(),
            symtab: ::std::vec::Vec::new(),
            dynsym: ::std::vec::Vec::new(),
            dynamic: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ELF {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ELF").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ELF {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ELF {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:elf.Section)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Section {
    // message fields
    // @@protoc_insertion_point(field:elf.Section.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<SectionType>>,
    // @@protoc_insertion_point(field:elf.Section.flags)
    pub flags: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:elf.Section.address)
    pub address: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:elf.Section.size)
    pub size: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:elf.Section.offset)
    pub offset: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:elf.Section.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:elf.Section.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Section {
    fn default() -> &'a Section {
        <Section as ::protobuf::Message>::default_instance()
    }
}

impl Section {
    pub fn new() -> Section {
        ::std::default::Default::default()
    }

    // required .elf.SectionType type = 1;

    pub fn type_(&self) -> SectionType {
        match self.type_ {
            Some(e) => e.enum_value_or(SectionType::SHT_NULL),
            None => SectionType::SHT_NULL,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: SectionType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required uint64 flags = 2;

    pub fn flags(&self) -> u64 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u64) {
        self.flags = ::std::option::Option::Some(v);
    }

    // required uint64 address = 3;

    pub fn address(&self) -> u64 {
        self.address.unwrap_or(0)
    }

    pub fn clear_address(&mut self) {
        self.address = ::std::option::Option::None;
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: u64) {
        self.address = ::std::option::Option::Some(v);
    }

    // required uint64 size = 4;

    pub fn size(&self) -> u64 {
        self.size.unwrap_or(0)
    }

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u64) {
        self.size = ::std::option::Option::Some(v);
    }

    // required uint64 offset = 5;

    pub fn offset(&self) -> u64 {
        self.offset.unwrap_or(0)
    }

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u64) {
        self.offset = ::std::option::Option::Some(v);
    }

    // optional string name = 6;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &Section| { &m.type_ },
            |m: &mut Section| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &Section| { &m.flags },
            |m: &mut Section| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "address",
            |m: &Section| { &m.address },
            |m: &mut Section| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "size",
            |m: &Section| { &m.size },
            |m: &mut Section| { &mut m.size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "offset",
            |m: &Section| { &m.offset },
            |m: &mut Section| { &mut m.offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &Section| { &m.name },
            |m: &mut Section| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Section>(
            "Section",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Section {
    const NAME: &'static str = "Section";

    fn is_initialized(&self) -> bool {
        if self.type_.is_none() {
            return false;
        }
        if self.flags.is_none() {
            return false;
        }
        if self.address.is_none() {
            return false;
        }
        if self.size.is_none() {
            return false;
        }
        if self.offset.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.flags = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.address = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.size = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.offset = ::std::option::Option::Some(is.read_uint64()?);
                },
                50 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.address {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.flags {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.address {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.size {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Section {
        Section::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.address = ::std::option::Option::None;
        self.size = ::std::option::Option::None;
        self.offset = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Section {
        static instance: Section = Section {
            type_: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            address: ::std::option::Option::None,
            size: ::std::option::Option::None,
            offset: ::std::option::Option::None,
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Section {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Section").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Section {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Section {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:elf.Segment)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Segment {
    // message fields
    // @@protoc_insertion_point(field:elf.Segment.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<SegmentType>>,
    // @@protoc_insertion_point(field:elf.Segment.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:elf.Segment.offset)
    pub offset: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:elf.Segment.virtual_address)
    pub virtual_address: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:elf.Segment.physical_address)
    pub physical_address: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:elf.Segment.file_size)
    pub file_size: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:elf.Segment.memory_size)
    pub memory_size: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:elf.Segment.alignment)
    pub alignment: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:elf.Segment.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Segment {
    fn default() -> &'a Segment {
        <Segment as ::protobuf::Message>::default_instance()
    }
}

impl Segment {
    pub fn new() -> Segment {
        ::std::default::Default::default()
    }

    // required .elf.SegmentType type = 1;

    pub fn type_(&self) -> SegmentType {
        match self.type_ {
            Some(e) => e.enum_value_or(SegmentType::PT_NULL),
            None => SegmentType::PT_NULL,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: SegmentType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required uint32 flags = 2;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // required uint64 offset = 3;

    pub fn offset(&self) -> u64 {
        self.offset.unwrap_or(0)
    }

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u64) {
        self.offset = ::std::option::Option::Some(v);
    }

    // required uint64 virtual_address = 4;

    pub fn virtual_address(&self) -> u64 {
        self.virtual_address.unwrap_or(0)
    }

    pub fn clear_virtual_address(&mut self) {
        self.virtual_address = ::std::option::Option::None;
    }

    pub fn has_virtual_address(&self) -> bool {
        self.virtual_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_virtual_address(&mut self, v: u64) {
        self.virtual_address = ::std::option::Option::Some(v);
    }

    // required uint64 physical_address = 5;

    pub fn physical_address(&self) -> u64 {
        self.physical_address.unwrap_or(0)
    }

    pub fn clear_physical_address(&mut self) {
        self.physical_address = ::std::option::Option::None;
    }

    pub fn has_physical_address(&self) -> bool {
        self.physical_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_physical_address(&mut self, v: u64) {
        self.physical_address = ::std::option::Option::Some(v);
    }

    // required uint64 file_size = 6;

    pub fn file_size(&self) -> u64 {
        self.file_size.unwrap_or(0)
    }

    pub fn clear_file_size(&mut self) {
        self.file_size = ::std::option::Option::None;
    }

    pub fn has_file_size(&self) -> bool {
        self.file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: u64) {
        self.file_size = ::std::option::Option::Some(v);
    }

    // required uint64 memory_size = 7;

    pub fn memory_size(&self) -> u64 {
        self.memory_size.unwrap_or(0)
    }

    pub fn clear_memory_size(&mut self) {
        self.memory_size = ::std::option::Option::None;
    }

    pub fn has_memory_size(&self) -> bool {
        self.memory_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_memory_size(&mut self, v: u64) {
        self.memory_size = ::std::option::Option::Some(v);
    }

    // required uint64 alignment = 8;

    pub fn alignment(&self) -> u64 {
        self.alignment.unwrap_or(0)
    }

    pub fn clear_alignment(&mut self) {
        self.alignment = ::std::option::Option::None;
    }

    pub fn has_alignment(&self) -> bool {
        self.alignment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_alignment(&mut self, v: u64) {
        self.alignment = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &Segment| { &m.type_ },
            |m: &mut Segment| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &Segment| { &m.flags },
            |m: &mut Segment| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "offset",
            |m: &Segment| { &m.offset },
            |m: &mut Segment| { &mut m.offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "virtual_address",
            |m: &Segment| { &m.virtual_address },
            |m: &mut Segment| { &mut m.virtual_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "physical_address",
            |m: &Segment| { &m.physical_address },
            |m: &mut Segment| { &mut m.physical_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_size",
            |m: &Segment| { &m.file_size },
            |m: &mut Segment| { &mut m.file_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "memory_size",
            |m: &Segment| { &m.memory_size },
            |m: &mut Segment| { &mut m.memory_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "alignment",
            |m: &Segment| { &m.alignment },
            |m: &mut Segment| { &mut m.alignment },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Segment>(
            "Segment",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Segment {
    const NAME: &'static str = "Segment";

    fn is_initialized(&self) -> bool {
        if self.type_.is_none() {
            return false;
        }
        if self.flags.is_none() {
            return false;
        }
        if self.offset.is_none() {
            return false;
        }
        if self.virtual_address.is_none() {
            return false;
        }
        if self.physical_address.is_none() {
            return false;
        }
        if self.file_size.is_none() {
            return false;
        }
        if self.memory_size.is_none() {
            return false;
        }
        if self.alignment.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.offset = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.virtual_address = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.physical_address = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.file_size = ::std::option::Option::Some(is.read_uint64()?);
                },
                56 => {
                    self.memory_size = ::std::option::Option::Some(is.read_uint64()?);
                },
                64 => {
                    self.alignment = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.virtual_address {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.physical_address {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.file_size {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.memory_size {
            my_size += ::protobuf::rt::uint64_size(7, v);
        }
        if let Some(v) = self.alignment {
            my_size += ::protobuf::rt::uint64_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.virtual_address {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.physical_address {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.file_size {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.memory_size {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.alignment {
            os.write_uint64(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Segment {
        Segment::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.offset = ::std::option::Option::None;
        self.virtual_address = ::std::option::Option::None;
        self.physical_address = ::std::option::Option::None;
        self.file_size = ::std::option::Option::None;
        self.memory_size = ::std::option::Option::None;
        self.alignment = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Segment {
        static instance: Segment = Segment {
            type_: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            offset: ::std::option::Option::None,
            virtual_address: ::std::option::Option::None,
            physical_address: ::std::option::Option::None,
            file_size: ::std::option::Option::None,
            memory_size: ::std::option::Option::None,
            alignment: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Segment {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Segment").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Segment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Segment {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:elf.Sym)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Sym {
    // message fields
    // @@protoc_insertion_point(field:elf.Sym.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:elf.Sym.value)
    pub value: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:elf.Sym.size)
    pub size: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:elf.Sym.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<SymType>>,
    // @@protoc_insertion_point(field:elf.Sym.bind)
    pub bind: ::std::option::Option<::protobuf::EnumOrUnknown<SymBind>>,
    // @@protoc_insertion_point(field:elf.Sym.shndx)
    pub shndx: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:elf.Sym.visibility)
    pub visibility: ::std::option::Option<::protobuf::EnumOrUnknown<SymVisibility>>,
    // special fields
    // @@protoc_insertion_point(special_field:elf.Sym.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Sym {
    fn default() -> &'a Sym {
        <Sym as ::protobuf::Message>::default_instance()
    }
}

impl Sym {
    pub fn new() -> Sym {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint64 value = 2;

    pub fn value(&self) -> u64 {
        self.value.unwrap_or(0)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u64) {
        self.value = ::std::option::Option::Some(v);
    }

    // required uint64 size = 3;

    pub fn size(&self) -> u64 {
        self.size.unwrap_or(0)
    }

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u64) {
        self.size = ::std::option::Option::Some(v);
    }

    // required .elf.SymType type = 4;

    pub fn type_(&self) -> SymType {
        match self.type_ {
            Some(e) => e.enum_value_or(SymType::STT_NOTYPE),
            None => SymType::STT_NOTYPE,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: SymType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required .elf.SymBind bind = 5;

    pub fn bind(&self) -> SymBind {
        match self.bind {
            Some(e) => e.enum_value_or(SymBind::STB_LOCAL),
            None => SymBind::STB_LOCAL,
        }
    }

    pub fn clear_bind(&mut self) {
        self.bind = ::std::option::Option::None;
    }

    pub fn has_bind(&self) -> bool {
        self.bind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bind(&mut self, v: SymBind) {
        self.bind = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required uint32 shndx = 6;

    pub fn shndx(&self) -> u32 {
        self.shndx.unwrap_or(0)
    }

    pub fn clear_shndx(&mut self) {
        self.shndx = ::std::option::Option::None;
    }

    pub fn has_shndx(&self) -> bool {
        self.shndx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shndx(&mut self, v: u32) {
        self.shndx = ::std::option::Option::Some(v);
    }

    // required .elf.SymVisibility visibility = 7;

    pub fn visibility(&self) -> SymVisibility {
        match self.visibility {
            Some(e) => e.enum_value_or(SymVisibility::STV_DEFAULT),
            None => SymVisibility::STV_DEFAULT,
        }
    }

    pub fn clear_visibility(&mut self) {
        self.visibility = ::std::option::Option::None;
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: SymVisibility) {
        self.visibility = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &Sym| { &m.name },
            |m: &mut Sym| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &Sym| { &m.value },
            |m: &mut Sym| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "size",
            |m: &Sym| { &m.size },
            |m: &mut Sym| { &mut m.size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &Sym| { &m.type_ },
            |m: &mut Sym| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bind",
            |m: &Sym| { &m.bind },
            |m: &mut Sym| { &mut m.bind },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shndx",
            |m: &Sym| { &m.shndx },
            |m: &mut Sym| { &mut m.shndx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "visibility",
            |m: &Sym| { &m.visibility },
            |m: &mut Sym| { &mut m.visibility },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Sym>(
            "Sym",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Sym {
    const NAME: &'static str = "Sym";

    fn is_initialized(&self) -> bool {
        if self.value.is_none() {
            return false;
        }
        if self.size.is_none() {
            return false;
        }
        if self.type_.is_none() {
            return false;
        }
        if self.bind.is_none() {
            return false;
        }
        if self.shndx.is_none() {
            return false;
        }
        if self.visibility.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.value = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.size = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.bind = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                48 => {
                    self.shndx = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.visibility = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.bind {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.shndx {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.visibility {
            my_size += ::protobuf::rt::int32_size(7, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.size {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.bind {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.shndx {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.visibility {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Sym {
        Sym::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.size = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.bind = ::std::option::Option::None;
        self.shndx = ::std::option::Option::None;
        self.visibility = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Sym {
        static instance: Sym = Sym {
            name: ::std::option::Option::None,
            value: ::std::option::Option::None,
            size: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            bind: ::std::option::Option::None,
            shndx: ::std::option::Option::None,
            visibility: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Sym {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Sym").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Sym {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Sym {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:elf.Dyn)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Dyn {
    // message fields
    // @@protoc_insertion_point(field:elf.Dyn.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<DynType>>,
    // @@protoc_insertion_point(field:elf.Dyn.val)
    pub val: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:elf.Dyn.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Dyn {
    fn default() -> &'a Dyn {
        <Dyn as ::protobuf::Message>::default_instance()
    }
}

impl Dyn {
    pub fn new() -> Dyn {
        ::std::default::Default::default()
    }

    // optional .elf.DynType type = 1;

    pub fn type_(&self) -> DynType {
        match self.type_ {
            Some(e) => e.enum_value_or(DynType::DT_NULL),
            None => DynType::DT_NULL,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: DynType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 val = 2;

    pub fn val(&self) -> u64 {
        self.val.unwrap_or(0)
    }

    pub fn clear_val(&mut self) {
        self.val = ::std::option::Option::None;
    }

    pub fn has_val(&self) -> bool {
        self.val.is_some()
    }

    // Param is passed by value, moved
    pub fn set_val(&mut self, v: u64) {
        self.val = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &Dyn| { &m.type_ },
            |m: &mut Dyn| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "val",
            |m: &Dyn| { &m.val },
            |m: &mut Dyn| { &mut m.val },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Dyn>(
            "Dyn",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Dyn {
    const NAME: &'static str = "Dyn";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.val = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.val {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.val {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Dyn {
        Dyn::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.val = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Dyn {
        static instance: Dyn = Dyn {
            type_: ::std::option::Option::None,
            val: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Dyn {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Dyn").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Dyn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Dyn {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:elf.Type)
pub enum Type {
    // @@protoc_insertion_point(enum_value:elf.Type.ET_NONE)
    ET_NONE = 0,
    // @@protoc_insertion_point(enum_value:elf.Type.ET_REL)
    ET_REL = 1,
    // @@protoc_insertion_point(enum_value:elf.Type.ET_EXEC)
    ET_EXEC = 2,
    // @@protoc_insertion_point(enum_value:elf.Type.ET_DYN)
    ET_DYN = 3,
    // @@protoc_insertion_point(enum_value:elf.Type.ET_CORE)
    ET_CORE = 4,
    // @@protoc_insertion_point(enum_value:elf.Type.ET_LOPROC)
    ET_LOPROC = 65280,
    // @@protoc_insertion_point(enum_value:elf.Type.ET_HIPROC)
    ET_HIPROC = 255,
}

impl ::protobuf::Enum for Type {
    const NAME: &'static str = "Type";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Type> {
        match value {
            0 => ::std::option::Option::Some(Type::ET_NONE),
            1 => ::std::option::Option::Some(Type::ET_REL),
            2 => ::std::option::Option::Some(Type::ET_EXEC),
            3 => ::std::option::Option::Some(Type::ET_DYN),
            4 => ::std::option::Option::Some(Type::ET_CORE),
            65280 => ::std::option::Option::Some(Type::ET_LOPROC),
            255 => ::std::option::Option::Some(Type::ET_HIPROC),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Type> {
        match str {
            "ET_NONE" => ::std::option::Option::Some(Type::ET_NONE),
            "ET_REL" => ::std::option::Option::Some(Type::ET_REL),
            "ET_EXEC" => ::std::option::Option::Some(Type::ET_EXEC),
            "ET_DYN" => ::std::option::Option::Some(Type::ET_DYN),
            "ET_CORE" => ::std::option::Option::Some(Type::ET_CORE),
            "ET_LOPROC" => ::std::option::Option::Some(Type::ET_LOPROC),
            "ET_HIPROC" => ::std::option::Option::Some(Type::ET_HIPROC),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Type] = &[
        Type::ET_NONE,
        Type::ET_REL,
        Type::ET_EXEC,
        Type::ET_DYN,
        Type::ET_CORE,
        Type::ET_LOPROC,
        Type::ET_HIPROC,
    ];
}

impl ::protobuf::EnumFull for Type {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Type").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            Type::ET_NONE => 0,
            Type::ET_REL => 1,
            Type::ET_EXEC => 2,
            Type::ET_DYN => 3,
            Type::ET_CORE => 4,
            Type::ET_LOPROC => 5,
            Type::ET_HIPROC => 6,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Type {
    fn default() -> Self {
        Type::ET_NONE
    }
}

impl Type {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Type>("Type")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:elf.Machine)
pub enum Machine {
    // @@protoc_insertion_point(enum_value:elf.Machine.EM_NONE)
    EM_NONE = 0,
    // @@protoc_insertion_point(enum_value:elf.Machine.EM_M32)
    EM_M32 = 1,
    // @@protoc_insertion_point(enum_value:elf.Machine.EM_SPARC)
    EM_SPARC = 2,
    // @@protoc_insertion_point(enum_value:elf.Machine.EM_386)
    EM_386 = 3,
    // @@protoc_insertion_point(enum_value:elf.Machine.EM_68K)
    EM_68K = 4,
    // @@protoc_insertion_point(enum_value:elf.Machine.EM_88K)
    EM_88K = 5,
    // @@protoc_insertion_point(enum_value:elf.Machine.EM_IAMCU)
    EM_IAMCU = 6,
    // @@protoc_insertion_point(enum_value:elf.Machine.EM_860)
    EM_860 = 7,
    // @@protoc_insertion_point(enum_value:elf.Machine.EM_MIPS)
    EM_MIPS = 8,
    // @@protoc_insertion_point(enum_value:elf.Machine.EM_S370)
    EM_S370 = 9,
    // @@protoc_insertion_point(enum_value:elf.Machine.EM_MIPS_RS3_LE)
    EM_MIPS_RS3_LE = 10,
    // @@protoc_insertion_point(enum_value:elf.Machine.EM_PPC)
    EM_PPC = 20,
    // @@protoc_insertion_point(enum_value:elf.Machine.EM_PPC64)
    EM_PPC64 = 21,
    // @@protoc_insertion_point(enum_value:elf.Machine.EM_ARM)
    EM_ARM = 40,
    // @@protoc_insertion_point(enum_value:elf.Machine.EM_X86_64)
    EM_X86_64 = 62,
    // @@protoc_insertion_point(enum_value:elf.Machine.EM_AARCH64)
    EM_AARCH64 = 183,
}

impl ::protobuf::Enum for Machine {
    const NAME: &'static str = "Machine";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Machine> {
        match value {
            0 => ::std::option::Option::Some(Machine::EM_NONE),
            1 => ::std::option::Option::Some(Machine::EM_M32),
            2 => ::std::option::Option::Some(Machine::EM_SPARC),
            3 => ::std::option::Option::Some(Machine::EM_386),
            4 => ::std::option::Option::Some(Machine::EM_68K),
            5 => ::std::option::Option::Some(Machine::EM_88K),
            6 => ::std::option::Option::Some(Machine::EM_IAMCU),
            7 => ::std::option::Option::Some(Machine::EM_860),
            8 => ::std::option::Option::Some(Machine::EM_MIPS),
            9 => ::std::option::Option::Some(Machine::EM_S370),
            10 => ::std::option::Option::Some(Machine::EM_MIPS_RS3_LE),
            20 => ::std::option::Option::Some(Machine::EM_PPC),
            21 => ::std::option::Option::Some(Machine::EM_PPC64),
            40 => ::std::option::Option::Some(Machine::EM_ARM),
            62 => ::std::option::Option::Some(Machine::EM_X86_64),
            183 => ::std::option::Option::Some(Machine::EM_AARCH64),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Machine> {
        match str {
            "EM_NONE" => ::std::option::Option::Some(Machine::EM_NONE),
            "EM_M32" => ::std::option::Option::Some(Machine::EM_M32),
            "EM_SPARC" => ::std::option::Option::Some(Machine::EM_SPARC),
            "EM_386" => ::std::option::Option::Some(Machine::EM_386),
            "EM_68K" => ::std::option::Option::Some(Machine::EM_68K),
            "EM_88K" => ::std::option::Option::Some(Machine::EM_88K),
            "EM_IAMCU" => ::std::option::Option::Some(Machine::EM_IAMCU),
            "EM_860" => ::std::option::Option::Some(Machine::EM_860),
            "EM_MIPS" => ::std::option::Option::Some(Machine::EM_MIPS),
            "EM_S370" => ::std::option::Option::Some(Machine::EM_S370),
            "EM_MIPS_RS3_LE" => ::std::option::Option::Some(Machine::EM_MIPS_RS3_LE),
            "EM_PPC" => ::std::option::Option::Some(Machine::EM_PPC),
            "EM_PPC64" => ::std::option::Option::Some(Machine::EM_PPC64),
            "EM_ARM" => ::std::option::Option::Some(Machine::EM_ARM),
            "EM_X86_64" => ::std::option::Option::Some(Machine::EM_X86_64),
            "EM_AARCH64" => ::std::option::Option::Some(Machine::EM_AARCH64),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Machine] = &[
        Machine::EM_NONE,
        Machine::EM_M32,
        Machine::EM_SPARC,
        Machine::EM_386,
        Machine::EM_68K,
        Machine::EM_88K,
        Machine::EM_IAMCU,
        Machine::EM_860,
        Machine::EM_MIPS,
        Machine::EM_S370,
        Machine::EM_MIPS_RS3_LE,
        Machine::EM_PPC,
        Machine::EM_PPC64,
        Machine::EM_ARM,
        Machine::EM_X86_64,
        Machine::EM_AARCH64,
    ];
}

impl ::protobuf::EnumFull for Machine {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Machine").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            Machine::EM_NONE => 0,
            Machine::EM_M32 => 1,
            Machine::EM_SPARC => 2,
            Machine::EM_386 => 3,
            Machine::EM_68K => 4,
            Machine::EM_88K => 5,
            Machine::EM_IAMCU => 6,
            Machine::EM_860 => 7,
            Machine::EM_MIPS => 8,
            Machine::EM_S370 => 9,
            Machine::EM_MIPS_RS3_LE => 10,
            Machine::EM_PPC => 11,
            Machine::EM_PPC64 => 12,
            Machine::EM_ARM => 13,
            Machine::EM_X86_64 => 14,
            Machine::EM_AARCH64 => 15,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Machine {
    fn default() -> Self {
        Machine::EM_NONE
    }
}

impl Machine {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Machine>("Machine")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:elf.OsAbi)
pub enum OsAbi {
    // @@protoc_insertion_point(enum_value:elf.OsAbi.OSABI_NONE)
    OSABI_NONE = 0,
    // @@protoc_insertion_point(enum_value:elf.OsAbi.OSABI_HPUX)
    OSABI_HPUX = 1,
    // @@protoc_insertion_point(enum_value:elf.OsAbi.OSABI_NETBSD)
    OSABI_NETBSD = 2,
    // @@protoc_insertion_point(enum_value:elf.OsAbi.OSABI_LINUX)
    OSABI_LINUX = 3,
    // @@protoc_insertion_point(enum_value:elf.OsAbi.OSABI_GNU_HURD)
    OSABI_GNU_HURD = 4,
    // @@protoc_insertion_point(enum_value:elf.OsAbi.OSABI_SOLARIS)
    OSABI_SOLARIS = 6,
    // @@protoc_insertion_point(enum_value:elf.OsAbi.OSABI_AIX)
    OSABI_AIX = 7,
    // @@protoc_insertion_point(enum_value:elf.OsAbi.OSABI_IRIX)
    OSABI_IRIX = 8,
    // @@protoc_insertion_point(enum_value:elf.OsAbi.OSABI_FREE_BSD)
    OSABI_FREE_BSD = 9,
    // @@protoc_insertion_point(enum_value:elf.OsAbi.OSABI_TRU64)
    OSABI_TRU64 = 10,
    // @@protoc_insertion_point(enum_value:elf.OsAbi.OSABI_MODESTO)
    OSABI_MODESTO = 11,
    // @@protoc_insertion_point(enum_value:elf.OsAbi.OSABI_OPENBSD)
    OSABI_OPENBSD = 12,
    // @@protoc_insertion_point(enum_value:elf.OsAbi.OSABI_OPENVMS)
    OSABI_OPENVMS = 13,
    // @@protoc_insertion_point(enum_value:elf.OsAbi.OSABI_NSK)
    OSABI_NSK = 14,
    // @@protoc_insertion_point(enum_value:elf.OsAbi.OSABI_AROS)
    OSABI_AROS = 15,
    // @@protoc_insertion_point(enum_value:elf.OsAbi.OSABI_FENIXOS)
    OSABI_FENIXOS = 16,
    // @@protoc_insertion_point(enum_value:elf.OsAbi.OSABI_CLOUDABI)
    OSABI_CLOUDABI = 17,
    // @@protoc_insertion_point(enum_value:elf.OsAbi.OSABI_OPENVOS)
    OSABI_OPENVOS = 18,
    // @@protoc_insertion_point(enum_value:elf.OsAbi.OSABI_ARM_AEABI)
    OSABI_ARM_AEABI = 64,
    // @@protoc_insertion_point(enum_value:elf.OsAbi.OSABI_ARM)
    OSABI_ARM = 97,
    // @@protoc_insertion_point(enum_value:elf.OsAbi.OSABI_STANDALONE)
    OSABI_STANDALONE = 255,
}

impl ::protobuf::Enum for OsAbi {
    const NAME: &'static str = "OsAbi";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OsAbi> {
        match value {
            0 => ::std::option::Option::Some(OsAbi::OSABI_NONE),
            1 => ::std::option::Option::Some(OsAbi::OSABI_HPUX),
            2 => ::std::option::Option::Some(OsAbi::OSABI_NETBSD),
            3 => ::std::option::Option::Some(OsAbi::OSABI_LINUX),
            4 => ::std::option::Option::Some(OsAbi::OSABI_GNU_HURD),
            6 => ::std::option::Option::Some(OsAbi::OSABI_SOLARIS),
            7 => ::std::option::Option::Some(OsAbi::OSABI_AIX),
            8 => ::std::option::Option::Some(OsAbi::OSABI_IRIX),
            9 => ::std::option::Option::Some(OsAbi::OSABI_FREE_BSD),
            10 => ::std::option::Option::Some(OsAbi::OSABI_TRU64),
            11 => ::std::option::Option::Some(OsAbi::OSABI_MODESTO),
            12 => ::std::option::Option::Some(OsAbi::OSABI_OPENBSD),
            13 => ::std::option::Option::Some(OsAbi::OSABI_OPENVMS),
            14 => ::std::option::Option::Some(OsAbi::OSABI_NSK),
            15 => ::std::option::Option::Some(OsAbi::OSABI_AROS),
            16 => ::std::option::Option::Some(OsAbi::OSABI_FENIXOS),
            17 => ::std::option::Option::Some(OsAbi::OSABI_CLOUDABI),
            18 => ::std::option::Option::Some(OsAbi::OSABI_OPENVOS),
            64 => ::std::option::Option::Some(OsAbi::OSABI_ARM_AEABI),
            97 => ::std::option::Option::Some(OsAbi::OSABI_ARM),
            255 => ::std::option::Option::Some(OsAbi::OSABI_STANDALONE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<OsAbi> {
        match str {
            "OSABI_NONE" => ::std::option::Option::Some(OsAbi::OSABI_NONE),
            "OSABI_HPUX" => ::std::option::Option::Some(OsAbi::OSABI_HPUX),
            "OSABI_NETBSD" => ::std::option::Option::Some(OsAbi::OSABI_NETBSD),
            "OSABI_LINUX" => ::std::option::Option::Some(OsAbi::OSABI_LINUX),
            "OSABI_GNU_HURD" => ::std::option::Option::Some(OsAbi::OSABI_GNU_HURD),
            "OSABI_SOLARIS" => ::std::option::Option::Some(OsAbi::OSABI_SOLARIS),
            "OSABI_AIX" => ::std::option::Option::Some(OsAbi::OSABI_AIX),
            "OSABI_IRIX" => ::std::option::Option::Some(OsAbi::OSABI_IRIX),
            "OSABI_FREE_BSD" => ::std::option::Option::Some(OsAbi::OSABI_FREE_BSD),
            "OSABI_TRU64" => ::std::option::Option::Some(OsAbi::OSABI_TRU64),
            "OSABI_MODESTO" => ::std::option::Option::Some(OsAbi::OSABI_MODESTO),
            "OSABI_OPENBSD" => ::std::option::Option::Some(OsAbi::OSABI_OPENBSD),
            "OSABI_OPENVMS" => ::std::option::Option::Some(OsAbi::OSABI_OPENVMS),
            "OSABI_NSK" => ::std::option::Option::Some(OsAbi::OSABI_NSK),
            "OSABI_AROS" => ::std::option::Option::Some(OsAbi::OSABI_AROS),
            "OSABI_FENIXOS" => ::std::option::Option::Some(OsAbi::OSABI_FENIXOS),
            "OSABI_CLOUDABI" => ::std::option::Option::Some(OsAbi::OSABI_CLOUDABI),
            "OSABI_OPENVOS" => ::std::option::Option::Some(OsAbi::OSABI_OPENVOS),
            "OSABI_ARM_AEABI" => ::std::option::Option::Some(OsAbi::OSABI_ARM_AEABI),
            "OSABI_ARM" => ::std::option::Option::Some(OsAbi::OSABI_ARM),
            "OSABI_STANDALONE" => ::std::option::Option::Some(OsAbi::OSABI_STANDALONE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [OsAbi] = &[
        OsAbi::OSABI_NONE,
        OsAbi::OSABI_HPUX,
        OsAbi::OSABI_NETBSD,
        OsAbi::OSABI_LINUX,
        OsAbi::OSABI_GNU_HURD,
        OsAbi::OSABI_SOLARIS,
        OsAbi::OSABI_AIX,
        OsAbi::OSABI_IRIX,
        OsAbi::OSABI_FREE_BSD,
        OsAbi::OSABI_TRU64,
        OsAbi::OSABI_MODESTO,
        OsAbi::OSABI_OPENBSD,
        OsAbi::OSABI_OPENVMS,
        OsAbi::OSABI_NSK,
        OsAbi::OSABI_AROS,
        OsAbi::OSABI_FENIXOS,
        OsAbi::OSABI_CLOUDABI,
        OsAbi::OSABI_OPENVOS,
        OsAbi::OSABI_ARM_AEABI,
        OsAbi::OSABI_ARM,
        OsAbi::OSABI_STANDALONE,
    ];
}

impl ::protobuf::EnumFull for OsAbi {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("OsAbi").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            OsAbi::OSABI_NONE => 0,
            OsAbi::OSABI_HPUX => 1,
            OsAbi::OSABI_NETBSD => 2,
            OsAbi::OSABI_LINUX => 3,
            OsAbi::OSABI_GNU_HURD => 4,
            OsAbi::OSABI_SOLARIS => 5,
            OsAbi::OSABI_AIX => 6,
            OsAbi::OSABI_IRIX => 7,
            OsAbi::OSABI_FREE_BSD => 8,
            OsAbi::OSABI_TRU64 => 9,
            OsAbi::OSABI_MODESTO => 10,
            OsAbi::OSABI_OPENBSD => 11,
            OsAbi::OSABI_OPENVMS => 12,
            OsAbi::OSABI_NSK => 13,
            OsAbi::OSABI_AROS => 14,
            OsAbi::OSABI_FENIXOS => 15,
            OsAbi::OSABI_CLOUDABI => 16,
            OsAbi::OSABI_OPENVOS => 17,
            OsAbi::OSABI_ARM_AEABI => 18,
            OsAbi::OSABI_ARM => 19,
            OsAbi::OSABI_STANDALONE => 20,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for OsAbi {
    fn default() -> Self {
        OsAbi::OSABI_NONE
    }
}

impl OsAbi {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<OsAbi>("OsAbi")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:elf.SectionType)
pub enum SectionType {
    // @@protoc_insertion_point(enum_value:elf.SectionType.SHT_NULL)
    SHT_NULL = 0,
    // @@protoc_insertion_point(enum_value:elf.SectionType.SHT_PROGBITS)
    SHT_PROGBITS = 1,
    // @@protoc_insertion_point(enum_value:elf.SectionType.SHT_SYMTAB)
    SHT_SYMTAB = 2,
    // @@protoc_insertion_point(enum_value:elf.SectionType.SHT_STRTAB)
    SHT_STRTAB = 3,
    // @@protoc_insertion_point(enum_value:elf.SectionType.SHT_RELA)
    SHT_RELA = 4,
    // @@protoc_insertion_point(enum_value:elf.SectionType.SHT_HASH)
    SHT_HASH = 5,
    // @@protoc_insertion_point(enum_value:elf.SectionType.SHT_DYNAMIC)
    SHT_DYNAMIC = 6,
    // @@protoc_insertion_point(enum_value:elf.SectionType.SHT_NOTE)
    SHT_NOTE = 7,
    // @@protoc_insertion_point(enum_value:elf.SectionType.SHT_NOBITS)
    SHT_NOBITS = 8,
    // @@protoc_insertion_point(enum_value:elf.SectionType.SHT_REL)
    SHT_REL = 9,
    // @@protoc_insertion_point(enum_value:elf.SectionType.SHT_SHLIB)
    SHT_SHLIB = 10,
    // @@protoc_insertion_point(enum_value:elf.SectionType.SHT_DYNSYM)
    SHT_DYNSYM = 11,
    // @@protoc_insertion_point(enum_value:elf.SectionType.SHT_INIT_ARRAY)
    SHT_INIT_ARRAY = 14,
    // @@protoc_insertion_point(enum_value:elf.SectionType.SHT_FINI_ARRAY)
    SHT_FINI_ARRAY = 15,
}

impl ::protobuf::Enum for SectionType {
    const NAME: &'static str = "SectionType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SectionType> {
        match value {
            0 => ::std::option::Option::Some(SectionType::SHT_NULL),
            1 => ::std::option::Option::Some(SectionType::SHT_PROGBITS),
            2 => ::std::option::Option::Some(SectionType::SHT_SYMTAB),
            3 => ::std::option::Option::Some(SectionType::SHT_STRTAB),
            4 => ::std::option::Option::Some(SectionType::SHT_RELA),
            5 => ::std::option::Option::Some(SectionType::SHT_HASH),
            6 => ::std::option::Option::Some(SectionType::SHT_DYNAMIC),
            7 => ::std::option::Option::Some(SectionType::SHT_NOTE),
            8 => ::std::option::Option::Some(SectionType::SHT_NOBITS),
            9 => ::std::option::Option::Some(SectionType::SHT_REL),
            10 => ::std::option::Option::Some(SectionType::SHT_SHLIB),
            11 => ::std::option::Option::Some(SectionType::SHT_DYNSYM),
            14 => ::std::option::Option::Some(SectionType::SHT_INIT_ARRAY),
            15 => ::std::option::Option::Some(SectionType::SHT_FINI_ARRAY),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SectionType> {
        match str {
            "SHT_NULL" => ::std::option::Option::Some(SectionType::SHT_NULL),
            "SHT_PROGBITS" => ::std::option::Option::Some(SectionType::SHT_PROGBITS),
            "SHT_SYMTAB" => ::std::option::Option::Some(SectionType::SHT_SYMTAB),
            "SHT_STRTAB" => ::std::option::Option::Some(SectionType::SHT_STRTAB),
            "SHT_RELA" => ::std::option::Option::Some(SectionType::SHT_RELA),
            "SHT_HASH" => ::std::option::Option::Some(SectionType::SHT_HASH),
            "SHT_DYNAMIC" => ::std::option::Option::Some(SectionType::SHT_DYNAMIC),
            "SHT_NOTE" => ::std::option::Option::Some(SectionType::SHT_NOTE),
            "SHT_NOBITS" => ::std::option::Option::Some(SectionType::SHT_NOBITS),
            "SHT_REL" => ::std::option::Option::Some(SectionType::SHT_REL),
            "SHT_SHLIB" => ::std::option::Option::Some(SectionType::SHT_SHLIB),
            "SHT_DYNSYM" => ::std::option::Option::Some(SectionType::SHT_DYNSYM),
            "SHT_INIT_ARRAY" => ::std::option::Option::Some(SectionType::SHT_INIT_ARRAY),
            "SHT_FINI_ARRAY" => ::std::option::Option::Some(SectionType::SHT_FINI_ARRAY),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SectionType] = &[
        SectionType::SHT_NULL,
        SectionType::SHT_PROGBITS,
        SectionType::SHT_SYMTAB,
        SectionType::SHT_STRTAB,
        SectionType::SHT_RELA,
        SectionType::SHT_HASH,
        SectionType::SHT_DYNAMIC,
        SectionType::SHT_NOTE,
        SectionType::SHT_NOBITS,
        SectionType::SHT_REL,
        SectionType::SHT_SHLIB,
        SectionType::SHT_DYNSYM,
        SectionType::SHT_INIT_ARRAY,
        SectionType::SHT_FINI_ARRAY,
    ];
}

impl ::protobuf::EnumFull for SectionType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SectionType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            SectionType::SHT_NULL => 0,
            SectionType::SHT_PROGBITS => 1,
            SectionType::SHT_SYMTAB => 2,
            SectionType::SHT_STRTAB => 3,
            SectionType::SHT_RELA => 4,
            SectionType::SHT_HASH => 5,
            SectionType::SHT_DYNAMIC => 6,
            SectionType::SHT_NOTE => 7,
            SectionType::SHT_NOBITS => 8,
            SectionType::SHT_REL => 9,
            SectionType::SHT_SHLIB => 10,
            SectionType::SHT_DYNSYM => 11,
            SectionType::SHT_INIT_ARRAY => 12,
            SectionType::SHT_FINI_ARRAY => 13,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for SectionType {
    fn default() -> Self {
        SectionType::SHT_NULL
    }
}

impl SectionType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SectionType>("SectionType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:elf.SegmentType)
pub enum SegmentType {
    // @@protoc_insertion_point(enum_value:elf.SegmentType.PT_NULL)
    PT_NULL = 0,
    // @@protoc_insertion_point(enum_value:elf.SegmentType.PT_LOAD)
    PT_LOAD = 1,
    // @@protoc_insertion_point(enum_value:elf.SegmentType.PT_DYNAMIC)
    PT_DYNAMIC = 2,
    // @@protoc_insertion_point(enum_value:elf.SegmentType.PT_INTERP)
    PT_INTERP = 3,
    // @@protoc_insertion_point(enum_value:elf.SegmentType.PT_NOTE)
    PT_NOTE = 4,
    // @@protoc_insertion_point(enum_value:elf.SegmentType.PT_SHLIB)
    PT_SHLIB = 5,
    // @@protoc_insertion_point(enum_value:elf.SegmentType.PT_PHDR)
    PT_PHDR = 6,
    // @@protoc_insertion_point(enum_value:elf.SegmentType.PT_TLS)
    PT_TLS = 7,
    // @@protoc_insertion_point(enum_value:elf.SegmentType.PT_GNU_EH_FRAME)
    PT_GNU_EH_FRAME = 1685382480,
    // @@protoc_insertion_point(enum_value:elf.SegmentType.PT_GNU_STACK)
    PT_GNU_STACK = 1685382481,
    // @@protoc_insertion_point(enum_value:elf.SegmentType.PT_GNU_RELRO)
    PT_GNU_RELRO = 1685382482,
    // @@protoc_insertion_point(enum_value:elf.SegmentType.PT_GNU_PROPERTY)
    PT_GNU_PROPERTY = 1685382483,
}

impl ::protobuf::Enum for SegmentType {
    const NAME: &'static str = "SegmentType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SegmentType> {
        match value {
            0 => ::std::option::Option::Some(SegmentType::PT_NULL),
            1 => ::std::option::Option::Some(SegmentType::PT_LOAD),
            2 => ::std::option::Option::Some(SegmentType::PT_DYNAMIC),
            3 => ::std::option::Option::Some(SegmentType::PT_INTERP),
            4 => ::std::option::Option::Some(SegmentType::PT_NOTE),
            5 => ::std::option::Option::Some(SegmentType::PT_SHLIB),
            6 => ::std::option::Option::Some(SegmentType::PT_PHDR),
            7 => ::std::option::Option::Some(SegmentType::PT_TLS),
            1685382480 => ::std::option::Option::Some(SegmentType::PT_GNU_EH_FRAME),
            1685382481 => ::std::option::Option::Some(SegmentType::PT_GNU_STACK),
            1685382482 => ::std::option::Option::Some(SegmentType::PT_GNU_RELRO),
            1685382483 => ::std::option::Option::Some(SegmentType::PT_GNU_PROPERTY),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SegmentType> {
        match str {
            "PT_NULL" => ::std::option::Option::Some(SegmentType::PT_NULL),
            "PT_LOAD" => ::std::option::Option::Some(SegmentType::PT_LOAD),
            "PT_DYNAMIC" => ::std::option::Option::Some(SegmentType::PT_DYNAMIC),
            "PT_INTERP" => ::std::option::Option::Some(SegmentType::PT_INTERP),
            "PT_NOTE" => ::std::option::Option::Some(SegmentType::PT_NOTE),
            "PT_SHLIB" => ::std::option::Option::Some(SegmentType::PT_SHLIB),
            "PT_PHDR" => ::std::option::Option::Some(SegmentType::PT_PHDR),
            "PT_TLS" => ::std::option::Option::Some(SegmentType::PT_TLS),
            "PT_GNU_EH_FRAME" => ::std::option::Option::Some(SegmentType::PT_GNU_EH_FRAME),
            "PT_GNU_STACK" => ::std::option::Option::Some(SegmentType::PT_GNU_STACK),
            "PT_GNU_RELRO" => ::std::option::Option::Some(SegmentType::PT_GNU_RELRO),
            "PT_GNU_PROPERTY" => ::std::option::Option::Some(SegmentType::PT_GNU_PROPERTY),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SegmentType] = &[
        SegmentType::PT_NULL,
        SegmentType::PT_LOAD,
        SegmentType::PT_DYNAMIC,
        SegmentType::PT_INTERP,
        SegmentType::PT_NOTE,
        SegmentType::PT_SHLIB,
        SegmentType::PT_PHDR,
        SegmentType::PT_TLS,
        SegmentType::PT_GNU_EH_FRAME,
        SegmentType::PT_GNU_STACK,
        SegmentType::PT_GNU_RELRO,
        SegmentType::PT_GNU_PROPERTY,
    ];
}

impl ::protobuf::EnumFull for SegmentType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SegmentType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            SegmentType::PT_NULL => 0,
            SegmentType::PT_LOAD => 1,
            SegmentType::PT_DYNAMIC => 2,
            SegmentType::PT_INTERP => 3,
            SegmentType::PT_NOTE => 4,
            SegmentType::PT_SHLIB => 5,
            SegmentType::PT_PHDR => 6,
            SegmentType::PT_TLS => 7,
            SegmentType::PT_GNU_EH_FRAME => 8,
            SegmentType::PT_GNU_STACK => 9,
            SegmentType::PT_GNU_RELRO => 10,
            SegmentType::PT_GNU_PROPERTY => 11,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for SegmentType {
    fn default() -> Self {
        SegmentType::PT_NULL
    }
}

impl SegmentType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SegmentType>("SegmentType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:elf.SegmentFlags)
pub enum SegmentFlags {
    // @@protoc_insertion_point(enum_value:elf.SegmentFlags.PF_X)
    PF_X = 1,
    // @@protoc_insertion_point(enum_value:elf.SegmentFlags.PF_W)
    PF_W = 2,
    // @@protoc_insertion_point(enum_value:elf.SegmentFlags.PF_R)
    PF_R = 4,
}

impl ::protobuf::Enum for SegmentFlags {
    const NAME: &'static str = "SegmentFlags";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SegmentFlags> {
        match value {
            1 => ::std::option::Option::Some(SegmentFlags::PF_X),
            2 => ::std::option::Option::Some(SegmentFlags::PF_W),
            4 => ::std::option::Option::Some(SegmentFlags::PF_R),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SegmentFlags> {
        match str {
            "PF_X" => ::std::option::Option::Some(SegmentFlags::PF_X),
            "PF_W" => ::std::option::Option::Some(SegmentFlags::PF_W),
            "PF_R" => ::std::option::Option::Some(SegmentFlags::PF_R),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SegmentFlags] = &[
        SegmentFlags::PF_X,
        SegmentFlags::PF_W,
        SegmentFlags::PF_R,
    ];
}

impl ::protobuf::EnumFull for SegmentFlags {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SegmentFlags").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            SegmentFlags::PF_X => 0,
            SegmentFlags::PF_W => 1,
            SegmentFlags::PF_R => 2,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for SegmentFlags {
    fn default() -> Self {
        SegmentFlags::PF_X
    }
}

impl SegmentFlags {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SegmentFlags>("SegmentFlags")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:elf.SymType)
pub enum SymType {
    // @@protoc_insertion_point(enum_value:elf.SymType.STT_NOTYPE)
    STT_NOTYPE = 0,
    // @@protoc_insertion_point(enum_value:elf.SymType.STT_OBJECT)
    STT_OBJECT = 1,
    // @@protoc_insertion_point(enum_value:elf.SymType.STT_FUNC)
    STT_FUNC = 2,
    // @@protoc_insertion_point(enum_value:elf.SymType.STT_SECTION)
    STT_SECTION = 3,
    // @@protoc_insertion_point(enum_value:elf.SymType.STT_FILE)
    STT_FILE = 4,
    // @@protoc_insertion_point(enum_value:elf.SymType.STT_COMMON)
    STT_COMMON = 5,
    // @@protoc_insertion_point(enum_value:elf.SymType.STT_TLS)
    STT_TLS = 6,
}

impl ::protobuf::Enum for SymType {
    const NAME: &'static str = "SymType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SymType> {
        match value {
            0 => ::std::option::Option::Some(SymType::STT_NOTYPE),
            1 => ::std::option::Option::Some(SymType::STT_OBJECT),
            2 => ::std::option::Option::Some(SymType::STT_FUNC),
            3 => ::std::option::Option::Some(SymType::STT_SECTION),
            4 => ::std::option::Option::Some(SymType::STT_FILE),
            5 => ::std::option::Option::Some(SymType::STT_COMMON),
            6 => ::std::option::Option::Some(SymType::STT_TLS),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SymType> {
        match str {
            "STT_NOTYPE" => ::std::option::Option::Some(SymType::STT_NOTYPE),
            "STT_OBJECT" => ::std::option::Option::Some(SymType::STT_OBJECT),
            "STT_FUNC" => ::std::option::Option::Some(SymType::STT_FUNC),
            "STT_SECTION" => ::std::option::Option::Some(SymType::STT_SECTION),
            "STT_FILE" => ::std::option::Option::Some(SymType::STT_FILE),
            "STT_COMMON" => ::std::option::Option::Some(SymType::STT_COMMON),
            "STT_TLS" => ::std::option::Option::Some(SymType::STT_TLS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SymType] = &[
        SymType::STT_NOTYPE,
        SymType::STT_OBJECT,
        SymType::STT_FUNC,
        SymType::STT_SECTION,
        SymType::STT_FILE,
        SymType::STT_COMMON,
        SymType::STT_TLS,
    ];
}

impl ::protobuf::EnumFull for SymType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SymType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for SymType {
    fn default() -> Self {
        SymType::STT_NOTYPE
    }
}

impl SymType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SymType>("SymType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:elf.SymBind)
pub enum SymBind {
    // @@protoc_insertion_point(enum_value:elf.SymBind.STB_LOCAL)
    STB_LOCAL = 0,
    // @@protoc_insertion_point(enum_value:elf.SymBind.STB_GLOBAL)
    STB_GLOBAL = 1,
    // @@protoc_insertion_point(enum_value:elf.SymBind.STB_WEAK)
    STB_WEAK = 2,
}

impl ::protobuf::Enum for SymBind {
    const NAME: &'static str = "SymBind";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SymBind> {
        match value {
            0 => ::std::option::Option::Some(SymBind::STB_LOCAL),
            1 => ::std::option::Option::Some(SymBind::STB_GLOBAL),
            2 => ::std::option::Option::Some(SymBind::STB_WEAK),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SymBind> {
        match str {
            "STB_LOCAL" => ::std::option::Option::Some(SymBind::STB_LOCAL),
            "STB_GLOBAL" => ::std::option::Option::Some(SymBind::STB_GLOBAL),
            "STB_WEAK" => ::std::option::Option::Some(SymBind::STB_WEAK),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SymBind] = &[
        SymBind::STB_LOCAL,
        SymBind::STB_GLOBAL,
        SymBind::STB_WEAK,
    ];
}

impl ::protobuf::EnumFull for SymBind {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SymBind").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for SymBind {
    fn default() -> Self {
        SymBind::STB_LOCAL
    }
}

impl SymBind {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SymBind>("SymBind")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:elf.SymVisibility)
pub enum SymVisibility {
    // @@protoc_insertion_point(enum_value:elf.SymVisibility.STV_DEFAULT)
    STV_DEFAULT = 0,
    // @@protoc_insertion_point(enum_value:elf.SymVisibility.STV_INTERNAL)
    STV_INTERNAL = 1,
    // @@protoc_insertion_point(enum_value:elf.SymVisibility.STV_HIDDEN)
    STV_HIDDEN = 2,
    // @@protoc_insertion_point(enum_value:elf.SymVisibility.STV_PROTECTED)
    STV_PROTECTED = 3,
}

impl ::protobuf::Enum for SymVisibility {
    const NAME: &'static str = "SymVisibility";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SymVisibility> {
        match value {
            0 => ::std::option::Option::Some(SymVisibility::STV_DEFAULT),
            1 => ::std::option::Option::Some(SymVisibility::STV_INTERNAL),
            2 => ::std::option::Option::Some(SymVisibility::STV_HIDDEN),
            3 => ::std::option::Option::Some(SymVisibility::STV_PROTECTED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SymVisibility> {
        match str {
            "STV_DEFAULT" => ::std::option::Option::Some(SymVisibility::STV_DEFAULT),
            "STV_INTERNAL" => ::std::option::Option::Some(SymVisibility::STV_INTERNAL),
            "STV_HIDDEN" => ::std::option::Option::Some(SymVisibility::STV_HIDDEN),
            "STV_PROTECTED" => ::std::option::Option::Some(SymVisibility::STV_PROTECTED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SymVisibility] = &[
        SymVisibility::STV_DEFAULT,
        SymVisibility::STV_INTERNAL,
        SymVisibility::STV_HIDDEN,
        SymVisibility::STV_PROTECTED,
    ];
}

impl ::protobuf::EnumFull for SymVisibility {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SymVisibility").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for SymVisibility {
    fn default() -> Self {
        SymVisibility::STV_DEFAULT
    }
}

impl SymVisibility {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SymVisibility>("SymVisibility")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:elf.DynType)
pub enum DynType {
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_NULL)
    DT_NULL = 0,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_NEEDED)
    DT_NEEDED = 1,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_PLTRELSZ)
    DT_PLTRELSZ = 2,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_PLTGOT)
    DT_PLTGOT = 3,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_HASH)
    DT_HASH = 4,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_STRTAB)
    DT_STRTAB = 5,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_SYMTAB)
    DT_SYMTAB = 6,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_RELA)
    DT_RELA = 7,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_RELASZ)
    DT_RELASZ = 8,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_RELAENT)
    DT_RELAENT = 9,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_STRSZ)
    DT_STRSZ = 10,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_SYMENT)
    DT_SYMENT = 11,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_INIT)
    DT_INIT = 12,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_FINI)
    DT_FINI = 13,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_SONAME)
    DT_SONAME = 14,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_RPATH)
    DT_RPATH = 15,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_SYMBOLIC)
    DT_SYMBOLIC = 16,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_REL)
    DT_REL = 17,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_RELSZ)
    DT_RELSZ = 18,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_RELENT)
    DT_RELENT = 19,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_PLTREL)
    DT_PLTREL = 20,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_DEBUG)
    DT_DEBUG = 21,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_TEXTREL)
    DT_TEXTREL = 22,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_JMPREL)
    DT_JMPREL = 23,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_BIND_NOW)
    DT_BIND_NOW = 24,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_INIT_ARRAY)
    DT_INIT_ARRAY = 25,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_FINI_ARRAY)
    DT_FINI_ARRAY = 26,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_INIT_ARRAYSZ)
    DT_INIT_ARRAYSZ = 27,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_FINI_ARRAYSZ)
    DT_FINI_ARRAYSZ = 28,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_RUNPATH)
    DT_RUNPATH = 29,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_FLAGS)
    DT_FLAGS = 30,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_ENCODING)
    DT_ENCODING = 32,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_LOOS)
    DT_LOOS = 1610612749,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_HIOS)
    DT_HIOS = 1879044096,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_VALRNGLO)
    DT_VALRNGLO = 1879047424,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_VALRNGHI)
    DT_VALRNGHI = 1879047679,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_ADDRRNGLO)
    DT_ADDRRNGLO = 1879047680,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_ADDRRNGHI)
    DT_ADDRRNGHI = 1879047935,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_VERSYM)
    DT_VERSYM = 1879048176,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_RELACOUNT)
    DT_RELACOUNT = 1879048185,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_RELCOUNT)
    DT_RELCOUNT = 1879048186,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_FLAGS_1)
    DT_FLAGS_1 = 1879048187,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_VERDEF)
    DT_VERDEF = 1879048188,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_VERDEFNUM)
    DT_VERDEFNUM = 1879048189,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_VERNEED)
    DT_VERNEED = 1879048190,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_VERNEEDNUM)
    DT_VERNEEDNUM = 1879048191,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_LOPROC)
    DT_LOPROC = 1879048192,
    // @@protoc_insertion_point(enum_value:elf.DynType.DT_HIPROC)
    DT_HIPROC = 2147483647,
}

impl ::protobuf::Enum for DynType {
    const NAME: &'static str = "DynType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DynType> {
        match value {
            0 => ::std::option::Option::Some(DynType::DT_NULL),
            1 => ::std::option::Option::Some(DynType::DT_NEEDED),
            2 => ::std::option::Option::Some(DynType::DT_PLTRELSZ),
            3 => ::std::option::Option::Some(DynType::DT_PLTGOT),
            4 => ::std::option::Option::Some(DynType::DT_HASH),
            5 => ::std::option::Option::Some(DynType::DT_STRTAB),
            6 => ::std::option::Option::Some(DynType::DT_SYMTAB),
            7 => ::std::option::Option::Some(DynType::DT_RELA),
            8 => ::std::option::Option::Some(DynType::DT_RELASZ),
            9 => ::std::option::Option::Some(DynType::DT_RELAENT),
            10 => ::std::option::Option::Some(DynType::DT_STRSZ),
            11 => ::std::option::Option::Some(DynType::DT_SYMENT),
            12 => ::std::option::Option::Some(DynType::DT_INIT),
            13 => ::std::option::Option::Some(DynType::DT_FINI),
            14 => ::std::option::Option::Some(DynType::DT_SONAME),
            15 => ::std::option::Option::Some(DynType::DT_RPATH),
            16 => ::std::option::Option::Some(DynType::DT_SYMBOLIC),
            17 => ::std::option::Option::Some(DynType::DT_REL),
            18 => ::std::option::Option::Some(DynType::DT_RELSZ),
            19 => ::std::option::Option::Some(DynType::DT_RELENT),
            20 => ::std::option::Option::Some(DynType::DT_PLTREL),
            21 => ::std::option::Option::Some(DynType::DT_DEBUG),
            22 => ::std::option::Option::Some(DynType::DT_TEXTREL),
            23 => ::std::option::Option::Some(DynType::DT_JMPREL),
            24 => ::std::option::Option::Some(DynType::DT_BIND_NOW),
            25 => ::std::option::Option::Some(DynType::DT_INIT_ARRAY),
            26 => ::std::option::Option::Some(DynType::DT_FINI_ARRAY),
            27 => ::std::option::Option::Some(DynType::DT_INIT_ARRAYSZ),
            28 => ::std::option::Option::Some(DynType::DT_FINI_ARRAYSZ),
            29 => ::std::option::Option::Some(DynType::DT_RUNPATH),
            30 => ::std::option::Option::Some(DynType::DT_FLAGS),
            32 => ::std::option::Option::Some(DynType::DT_ENCODING),
            1610612749 => ::std::option::Option::Some(DynType::DT_LOOS),
            1879044096 => ::std::option::Option::Some(DynType::DT_HIOS),
            1879047424 => ::std::option::Option::Some(DynType::DT_VALRNGLO),
            1879047679 => ::std::option::Option::Some(DynType::DT_VALRNGHI),
            1879047680 => ::std::option::Option::Some(DynType::DT_ADDRRNGLO),
            1879047935 => ::std::option::Option::Some(DynType::DT_ADDRRNGHI),
            1879048176 => ::std::option::Option::Some(DynType::DT_VERSYM),
            1879048185 => ::std::option::Option::Some(DynType::DT_RELACOUNT),
            1879048186 => ::std::option::Option::Some(DynType::DT_RELCOUNT),
            1879048187 => ::std::option::Option::Some(DynType::DT_FLAGS_1),
            1879048188 => ::std::option::Option::Some(DynType::DT_VERDEF),
            1879048189 => ::std::option::Option::Some(DynType::DT_VERDEFNUM),
            1879048190 => ::std::option::Option::Some(DynType::DT_VERNEED),
            1879048191 => ::std::option::Option::Some(DynType::DT_VERNEEDNUM),
            1879048192 => ::std::option::Option::Some(DynType::DT_LOPROC),
            2147483647 => ::std::option::Option::Some(DynType::DT_HIPROC),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DynType> {
        match str {
            "DT_NULL" => ::std::option::Option::Some(DynType::DT_NULL),
            "DT_NEEDED" => ::std::option::Option::Some(DynType::DT_NEEDED),
            "DT_PLTRELSZ" => ::std::option::Option::Some(DynType::DT_PLTRELSZ),
            "DT_PLTGOT" => ::std::option::Option::Some(DynType::DT_PLTGOT),
            "DT_HASH" => ::std::option::Option::Some(DynType::DT_HASH),
            "DT_STRTAB" => ::std::option::Option::Some(DynType::DT_STRTAB),
            "DT_SYMTAB" => ::std::option::Option::Some(DynType::DT_SYMTAB),
            "DT_RELA" => ::std::option::Option::Some(DynType::DT_RELA),
            "DT_RELASZ" => ::std::option::Option::Some(DynType::DT_RELASZ),
            "DT_RELAENT" => ::std::option::Option::Some(DynType::DT_RELAENT),
            "DT_STRSZ" => ::std::option::Option::Some(DynType::DT_STRSZ),
            "DT_SYMENT" => ::std::option::Option::Some(DynType::DT_SYMENT),
            "DT_INIT" => ::std::option::Option::Some(DynType::DT_INIT),
            "DT_FINI" => ::std::option::Option::Some(DynType::DT_FINI),
            "DT_SONAME" => ::std::option::Option::Some(DynType::DT_SONAME),
            "DT_RPATH" => ::std::option::Option::Some(DynType::DT_RPATH),
            "DT_SYMBOLIC" => ::std::option::Option::Some(DynType::DT_SYMBOLIC),
            "DT_REL" => ::std::option::Option::Some(DynType::DT_REL),
            "DT_RELSZ" => ::std::option::Option::Some(DynType::DT_RELSZ),
            "DT_RELENT" => ::std::option::Option::Some(DynType::DT_RELENT),
            "DT_PLTREL" => ::std::option::Option::Some(DynType::DT_PLTREL),
            "DT_DEBUG" => ::std::option::Option::Some(DynType::DT_DEBUG),
            "DT_TEXTREL" => ::std::option::Option::Some(DynType::DT_TEXTREL),
            "DT_JMPREL" => ::std::option::Option::Some(DynType::DT_JMPREL),
            "DT_BIND_NOW" => ::std::option::Option::Some(DynType::DT_BIND_NOW),
            "DT_INIT_ARRAY" => ::std::option::Option::Some(DynType::DT_INIT_ARRAY),
            "DT_FINI_ARRAY" => ::std::option::Option::Some(DynType::DT_FINI_ARRAY),
            "DT_INIT_ARRAYSZ" => ::std::option::Option::Some(DynType::DT_INIT_ARRAYSZ),
            "DT_FINI_ARRAYSZ" => ::std::option::Option::Some(DynType::DT_FINI_ARRAYSZ),
            "DT_RUNPATH" => ::std::option::Option::Some(DynType::DT_RUNPATH),
            "DT_FLAGS" => ::std::option::Option::Some(DynType::DT_FLAGS),
            "DT_ENCODING" => ::std::option::Option::Some(DynType::DT_ENCODING),
            "DT_LOOS" => ::std::option::Option::Some(DynType::DT_LOOS),
            "DT_HIOS" => ::std::option::Option::Some(DynType::DT_HIOS),
            "DT_VALRNGLO" => ::std::option::Option::Some(DynType::DT_VALRNGLO),
            "DT_VALRNGHI" => ::std::option::Option::Some(DynType::DT_VALRNGHI),
            "DT_ADDRRNGLO" => ::std::option::Option::Some(DynType::DT_ADDRRNGLO),
            "DT_ADDRRNGHI" => ::std::option::Option::Some(DynType::DT_ADDRRNGHI),
            "DT_VERSYM" => ::std::option::Option::Some(DynType::DT_VERSYM),
            "DT_RELACOUNT" => ::std::option::Option::Some(DynType::DT_RELACOUNT),
            "DT_RELCOUNT" => ::std::option::Option::Some(DynType::DT_RELCOUNT),
            "DT_FLAGS_1" => ::std::option::Option::Some(DynType::DT_FLAGS_1),
            "DT_VERDEF" => ::std::option::Option::Some(DynType::DT_VERDEF),
            "DT_VERDEFNUM" => ::std::option::Option::Some(DynType::DT_VERDEFNUM),
            "DT_VERNEED" => ::std::option::Option::Some(DynType::DT_VERNEED),
            "DT_VERNEEDNUM" => ::std::option::Option::Some(DynType::DT_VERNEEDNUM),
            "DT_LOPROC" => ::std::option::Option::Some(DynType::DT_LOPROC),
            "DT_HIPROC" => ::std::option::Option::Some(DynType::DT_HIPROC),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DynType] = &[
        DynType::DT_NULL,
        DynType::DT_NEEDED,
        DynType::DT_PLTRELSZ,
        DynType::DT_PLTGOT,
        DynType::DT_HASH,
        DynType::DT_STRTAB,
        DynType::DT_SYMTAB,
        DynType::DT_RELA,
        DynType::DT_RELASZ,
        DynType::DT_RELAENT,
        DynType::DT_STRSZ,
        DynType::DT_SYMENT,
        DynType::DT_INIT,
        DynType::DT_FINI,
        DynType::DT_SONAME,
        DynType::DT_RPATH,
        DynType::DT_SYMBOLIC,
        DynType::DT_REL,
        DynType::DT_RELSZ,
        DynType::DT_RELENT,
        DynType::DT_PLTREL,
        DynType::DT_DEBUG,
        DynType::DT_TEXTREL,
        DynType::DT_JMPREL,
        DynType::DT_BIND_NOW,
        DynType::DT_INIT_ARRAY,
        DynType::DT_FINI_ARRAY,
        DynType::DT_INIT_ARRAYSZ,
        DynType::DT_FINI_ARRAYSZ,
        DynType::DT_RUNPATH,
        DynType::DT_FLAGS,
        DynType::DT_ENCODING,
        DynType::DT_LOOS,
        DynType::DT_HIOS,
        DynType::DT_VALRNGLO,
        DynType::DT_VALRNGHI,
        DynType::DT_ADDRRNGLO,
        DynType::DT_ADDRRNGHI,
        DynType::DT_VERSYM,
        DynType::DT_RELACOUNT,
        DynType::DT_RELCOUNT,
        DynType::DT_FLAGS_1,
        DynType::DT_VERDEF,
        DynType::DT_VERDEFNUM,
        DynType::DT_VERNEED,
        DynType::DT_VERNEEDNUM,
        DynType::DT_LOPROC,
        DynType::DT_HIPROC,
    ];
}

impl ::protobuf::EnumFull for DynType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DynType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            DynType::DT_NULL => 0,
            DynType::DT_NEEDED => 1,
            DynType::DT_PLTRELSZ => 2,
            DynType::DT_PLTGOT => 3,
            DynType::DT_HASH => 4,
            DynType::DT_STRTAB => 5,
            DynType::DT_SYMTAB => 6,
            DynType::DT_RELA => 7,
            DynType::DT_RELASZ => 8,
            DynType::DT_RELAENT => 9,
            DynType::DT_STRSZ => 10,
            DynType::DT_SYMENT => 11,
            DynType::DT_INIT => 12,
            DynType::DT_FINI => 13,
            DynType::DT_SONAME => 14,
            DynType::DT_RPATH => 15,
            DynType::DT_SYMBOLIC => 16,
            DynType::DT_REL => 17,
            DynType::DT_RELSZ => 18,
            DynType::DT_RELENT => 19,
            DynType::DT_PLTREL => 20,
            DynType::DT_DEBUG => 21,
            DynType::DT_TEXTREL => 22,
            DynType::DT_JMPREL => 23,
            DynType::DT_BIND_NOW => 24,
            DynType::DT_INIT_ARRAY => 25,
            DynType::DT_FINI_ARRAY => 26,
            DynType::DT_INIT_ARRAYSZ => 27,
            DynType::DT_FINI_ARRAYSZ => 28,
            DynType::DT_RUNPATH => 29,
            DynType::DT_FLAGS => 30,
            DynType::DT_ENCODING => 31,
            DynType::DT_LOOS => 32,
            DynType::DT_HIOS => 33,
            DynType::DT_VALRNGLO => 34,
            DynType::DT_VALRNGHI => 35,
            DynType::DT_ADDRRNGLO => 36,
            DynType::DT_ADDRRNGHI => 37,
            DynType::DT_VERSYM => 38,
            DynType::DT_RELACOUNT => 39,
            DynType::DT_RELCOUNT => 40,
            DynType::DT_FLAGS_1 => 41,
            DynType::DT_VERDEF => 42,
            DynType::DT_VERDEFNUM => 43,
            DynType::DT_VERNEED => 44,
            DynType::DT_VERNEEDNUM => 45,
            DynType::DT_LOPROC => 46,
            DynType::DT_HIPROC => 47,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DynType {
    fn default() -> Self {
        DynType::DT_NULL
    }
}

impl DynType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DynType>("DynType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\telf.proto\x12\x03elf\x1a\nyara.proto\"\xd9\x06\n\x03ELF\x12\x1d\n\
    \x04type\x18\x01\x20\x01(\x0e2\t.elf.TypeR\x04type\x12&\n\x07machine\x18\
    \x02\x20\x01(\x0e2\x0c.elf.MachineR\x07machine\x12\x20\n\x05osabi\x18\
    \x12\x20\x01(\x0e2\n.elf.OsAbiR\x05osabi\x12\x1f\n\x0bentry_point\x18\
    \x03\x20\x01(\x04R\nentryPoint\x12\x1b\n\tsh_offset\x18\x04\x20\x01(\x04\
    R\x08shOffset\x12\"\n\rsh_entry_size\x18\x05\x20\x01(\rR\x0bshEntrySize\
    \x12\x1b\n\tph_offset\x18\x06\x20\x01(\x04R\x08phOffset\x12\"\n\rph_entr\
    y_size\x18\x07\x20\x01(\rR\x0bphEntrySize\x12\x80\x01\n\x12number_of_sec\
    tions\x18\x08\x20\x01(\x04R\x10numberOfSectionsBR\x82\x93\x19N2L\n\x18th\
    is\x20field\x20is\x20deprecated\x12\x20use\x20`elf.sections.len()`\x20in\
    stead\x1a\x0esections.len()\x12\x80\x01\n\x12number_of_segments\x18\t\
    \x20\x01(\x04R\x10numberOfSegmentsBR\x82\x93\x19N2L\n\x18this\x20field\
    \x20is\x20deprecated\x12\x20use\x20`elf.segments.len()`\x20instead\x1a\
    \x0esegments.len()\x12%\n\x0esymtab_entries\x18\n\x20\x01(\x04R\rsymtabE\
    ntries\x12%\n\x0edynsym_entries\x18\x0b\x20\x01(\x04R\rdynsymEntries\x12\
    6\n\x17dynamic_section_entries\x18\x0c\x20\x01(\x04R\x15dynamicSectionEn\
    tries\x12(\n\x08sections\x18\r\x20\x03(\x0b2\x0c.elf.SectionR\x08section\
    s\x12(\n\x08segments\x18\x0e\x20\x03(\x0b2\x0c.elf.SegmentR\x08segments\
    \x12\x20\n\x06symtab\x18\x0f\x20\x03(\x0b2\x08.elf.SymR\x06symtab\x12\
    \x20\n\x06dynsym\x18\x10\x20\x03(\x0b2\x08.elf.SymR\x06dynsym\x12\"\n\
    \x07dynamic\x18\x11\x20\x03(\x0b2\x08.elf.DynR\x07dynamic\"\x9f\x01\n\
    \x07Section\x12$\n\x04type\x18\x01\x20\x02(\x0e2\x10.elf.SectionTypeR\
    \x04type\x12\x14\n\x05flags\x18\x02\x20\x02(\x04R\x05flags\x12\x18\n\x07\
    address\x18\x03\x20\x02(\x04R\x07address\x12\x12\n\x04size\x18\x04\x20\
    \x02(\x04R\x04size\x12\x16\n\x06offset\x18\x05\x20\x02(\x04R\x06offset\
    \x12\x12\n\x04name\x18\x06\x20\x01(\tR\x04name\"\xa7\x02\n\x07Segment\
    \x12$\n\x04type\x18\x01\x20\x02(\x0e2\x10.elf.SegmentTypeR\x04type\x12.\
    \n\x05flags\x18\x02\x20\x02(\rR\x05flagsB\x18\x82\x93\x19\x14*\x12flags:\
    SegmentFlags\x12\x16\n\x06offset\x18\x03\x20\x02(\x04R\x06offset\x12'\n\
    \x0fvirtual_address\x18\x04\x20\x02(\x04R\x0evirtualAddress\x12)\n\x10ph\
    ysical_address\x18\x05\x20\x02(\x04R\x0fphysicalAddress\x12\x1b\n\tfile_\
    size\x18\x06\x20\x02(\x04R\x08fileSize\x12\x1f\n\x0bmemory_size\x18\x07\
    \x20\x02(\x04R\nmemorySize\x12\x1c\n\talignment\x18\x08\x20\x02(\x04R\ta\
    lignment\"\xd1\x01\n\x03Sym\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04nam\
    e\x12\x14\n\x05value\x18\x02\x20\x02(\x04R\x05value\x12\x12\n\x04size\
    \x18\x03\x20\x02(\x04R\x04size\x12\x20\n\x04type\x18\x04\x20\x02(\x0e2\
    \x0c.elf.SymTypeR\x04type\x12\x20\n\x04bind\x18\x05\x20\x02(\x0e2\x0c.el\
    f.SymBindR\x04bind\x12\x14\n\x05shndx\x18\x06\x20\x02(\rR\x05shndx\x122\
    \n\nvisibility\x18\x07\x20\x02(\x0e2\x12.elf.SymVisibilityR\nvisibility\
    \"9\n\x03Dyn\x12\x20\n\x04type\x18\x01\x20\x01(\x0e2\x0c.elf.DynTypeR\
    \x04type\x12\x10\n\x03val\x18\x02\x20\x01(\x04R\x03val*n\n\x04Type\x12\
    \x0b\n\x07ET_NONE\x10\0\x12\n\n\x06ET_REL\x10\x01\x12\x0b\n\x07ET_EXEC\
    \x10\x02\x12\n\n\x06ET_DYN\x10\x03\x12\x0b\n\x07ET_CORE\x10\x04\x12\x0f\
    \n\tET_LOPROC\x10\x80\xfe\x03\x12\x0e\n\tET_HIPROC\x10\xff\x01\x1a\x06\
    \x92\x93\x19\x02\x10\x01*\xea\x01\n\x07Machine\x12\x0b\n\x07EM_NONE\x10\
    \0\x12\n\n\x06EM_M32\x10\x01\x12\x0c\n\x08EM_SPARC\x10\x02\x12\n\n\x06EM\
    _386\x10\x03\x12\n\n\x06EM_68K\x10\x04\x12\n\n\x06EM_88K\x10\x05\x12\x0c\
    \n\x08EM_IAMCU\x10\x06\x12\n\n\x06EM_860\x10\x07\x12\x0b\n\x07EM_MIPS\
    \x10\x08\x12\x0b\n\x07EM_S370\x10\t\x12\x12\n\x0eEM_MIPS_RS3_LE\x10\n\
    \x12\n\n\x06EM_PPC\x10\x14\x12\x0c\n\x08EM_PPC64\x10\x15\x12\n\n\x06EM_A\
    RM\x10(\x12\r\n\tEM_X86_64\x10>\x12\x0f\n\nEM_AARCH64\x10\xb7\x01\x1a\
    \x06\x92\x93\x19\x02\x10\x01*\x8a\x03\n\x05OsAbi\x12\x0e\n\nOSABI_NONE\
    \x10\0\x12\x0e\n\nOSABI_HPUX\x10\x01\x12\x10\n\x0cOSABI_NETBSD\x10\x02\
    \x12\x0f\n\x0bOSABI_LINUX\x10\x03\x12\x12\n\x0eOSABI_GNU_HURD\x10\x04\
    \x12\x11\n\rOSABI_SOLARIS\x10\x06\x12\r\n\tOSABI_AIX\x10\x07\x12\x0e\n\n\
    OSABI_IRIX\x10\x08\x12\x12\n\x0eOSABI_FREE_BSD\x10\t\x12\x0f\n\x0bOSABI_\
    TRU64\x10\n\x12\x11\n\rOSABI_MODESTO\x10\x0b\x12\x11\n\rOSABI_OPENBSD\
    \x10\x0c\x12\x11\n\rOSABI_OPENVMS\x10\r\x12\r\n\tOSABI_NSK\x10\x0e\x12\
    \x0e\n\nOSABI_AROS\x10\x0f\x12\x11\n\rOSABI_FENIXOS\x10\x10\x12\x12\n\
    \x0eOSABI_CLOUDABI\x10\x11\x12\x11\n\rOSABI_OPENVOS\x10\x12\x12\x13\n\
    \x0fOSABI_ARM_AEABI\x10@\x12\r\n\tOSABI_ARM\x10a\x12\x15\n\x10OSABI_STAN\
    DALONE\x10\xff\x01\x1a\x06\x92\x93\x19\x02\x10\x01*\xf4\x01\n\x0bSection\
    Type\x12\x0c\n\x08SHT_NULL\x10\0\x12\x10\n\x0cSHT_PROGBITS\x10\x01\x12\
    \x0e\n\nSHT_SYMTAB\x10\x02\x12\x0e\n\nSHT_STRTAB\x10\x03\x12\x0c\n\x08SH\
    T_RELA\x10\x04\x12\x0c\n\x08SHT_HASH\x10\x05\x12\x0f\n\x0bSHT_DYNAMIC\
    \x10\x06\x12\x0c\n\x08SHT_NOTE\x10\x07\x12\x0e\n\nSHT_NOBITS\x10\x08\x12\
    \x0b\n\x07SHT_REL\x10\t\x12\r\n\tSHT_SHLIB\x10\n\x12\x0e\n\nSHT_DYNSYM\
    \x10\x0b\x12\x12\n\x0eSHT_INIT_ARRAY\x10\x0e\x12\x12\n\x0eSHT_FINI_ARRAY\
    \x10\x0f\x1a\x06\x92\x93\x19\x02\x10\x01*\xe0\x01\n\x0bSegmentType\x12\
    \x0b\n\x07PT_NULL\x10\0\x12\x0b\n\x07PT_LOAD\x10\x01\x12\x0e\n\nPT_DYNAM\
    IC\x10\x02\x12\r\n\tPT_INTERP\x10\x03\x12\x0b\n\x07PT_NOTE\x10\x04\x12\
    \x0c\n\x08PT_SHLIB\x10\x05\x12\x0b\n\x07PT_PHDR\x10\x06\x12\n\n\x06PT_TL\
    S\x10\x07\x12\x17\n\x0fPT_GNU_EH_FRAME\x10\xd0\xca\xd3\xa3\x06\x12\x14\n\
    \x0cPT_GNU_STACK\x10\xd1\xca\xd3\xa3\x06\x12\x14\n\x0cPT_GNU_RELRO\x10\
    \xd2\xca\xd3\xa3\x06\x12\x17\n\x0fPT_GNU_PROPERTY\x10\xd3\xca\xd3\xa3\
    \x06\x1a\x06\x92\x93\x19\x02\x10\x01*4\n\x0cSegmentFlags\x12\x08\n\x04PF\
    _X\x10\x01\x12\x08\n\x04PF_W\x10\x02\x12\x08\n\x04PF_R\x10\x04\x1a\x06\
    \x92\x93\x19\x02\x10\x01*{\n\x07SymType\x12\x0e\n\nSTT_NOTYPE\x10\0\x12\
    \x0e\n\nSTT_OBJECT\x10\x01\x12\x0c\n\x08STT_FUNC\x10\x02\x12\x0f\n\x0bST\
    T_SECTION\x10\x03\x12\x0c\n\x08STT_FILE\x10\x04\x12\x0e\n\nSTT_COMMON\
    \x10\x05\x12\x0b\n\x07STT_TLS\x10\x06\x1a\x06\x92\x93\x19\x02\x10\x01*>\
    \n\x07SymBind\x12\r\n\tSTB_LOCAL\x10\0\x12\x0e\n\nSTB_GLOBAL\x10\x01\x12\
    \x0c\n\x08STB_WEAK\x10\x02\x1a\x06\x92\x93\x19\x02\x10\x01*]\n\rSymVisib\
    ility\x12\x0f\n\x0bSTV_DEFAULT\x10\0\x12\x10\n\x0cSTV_INTERNAL\x10\x01\
    \x12\x0e\n\nSTV_HIDDEN\x10\x02\x12\x11\n\rSTV_PROTECTED\x10\x03\x1a\x06\
    \x92\x93\x19\x02\x10\x01*\xc2\x06\n\x07DynType\x12\x0b\n\x07DT_NULL\x10\
    \0\x12\r\n\tDT_NEEDED\x10\x01\x12\x0f\n\x0bDT_PLTRELSZ\x10\x02\x12\r\n\t\
    DT_PLTGOT\x10\x03\x12\x0b\n\x07DT_HASH\x10\x04\x12\r\n\tDT_STRTAB\x10\
    \x05\x12\r\n\tDT_SYMTAB\x10\x06\x12\x0b\n\x07DT_RELA\x10\x07\x12\r\n\tDT\
    _RELASZ\x10\x08\x12\x0e\n\nDT_RELAENT\x10\t\x12\x0c\n\x08DT_STRSZ\x10\n\
    \x12\r\n\tDT_SYMENT\x10\x0b\x12\x0b\n\x07DT_INIT\x10\x0c\x12\x0b\n\x07DT\
    _FINI\x10\r\x12\r\n\tDT_SONAME\x10\x0e\x12\x0c\n\x08DT_RPATH\x10\x0f\x12\
    \x0f\n\x0bDT_SYMBOLIC\x10\x10\x12\n\n\x06DT_REL\x10\x11\x12\x0c\n\x08DT_\
    RELSZ\x10\x12\x12\r\n\tDT_RELENT\x10\x13\x12\r\n\tDT_PLTREL\x10\x14\x12\
    \x0c\n\x08DT_DEBUG\x10\x15\x12\x0e\n\nDT_TEXTREL\x10\x16\x12\r\n\tDT_JMP\
    REL\x10\x17\x12\x0f\n\x0bDT_BIND_NOW\x10\x18\x12\x11\n\rDT_INIT_ARRAY\
    \x10\x19\x12\x11\n\rDT_FINI_ARRAY\x10\x1a\x12\x13\n\x0fDT_INIT_ARRAYSZ\
    \x10\x1b\x12\x13\n\x0fDT_FINI_ARRAYSZ\x10\x1c\x12\x0e\n\nDT_RUNPATH\x10\
    \x1d\x12\x0c\n\x08DT_FLAGS\x10\x1e\x12\x0f\n\x0bDT_ENCODING\x10\x20\x12\
    \x0f\n\x07DT_LOOS\x10\x8d\x80\x80\x80\x06\x12\x0f\n\x07DT_HIOS\x10\x80\
    \xe0\xff\xff\x06\x12\x13\n\x0bDT_VALRNGLO\x10\x80\xfa\xff\xff\x06\x12\
    \x13\n\x0bDT_VALRNGHI\x10\xff\xfb\xff\xff\x06\x12\x14\n\x0cDT_ADDRRNGLO\
    \x10\x80\xfc\xff\xff\x06\x12\x14\n\x0cDT_ADDRRNGHI\x10\xff\xfd\xff\xff\
    \x06\x12\x11\n\tDT_VERSYM\x10\xf0\xff\xff\xff\x06\x12\x14\n\x0cDT_RELACO\
    UNT\x10\xf9\xff\xff\xff\x06\x12\x13\n\x0bDT_RELCOUNT\x10\xfa\xff\xff\xff\
    \x06\x12\x12\n\nDT_FLAGS_1\x10\xfb\xff\xff\xff\x06\x12\x11\n\tDT_VERDEF\
    \x10\xfc\xff\xff\xff\x06\x12\x14\n\x0cDT_VERDEFNUM\x10\xfd\xff\xff\xff\
    \x06\x12\x12\n\nDT_VERNEED\x10\xfe\xff\xff\xff\x06\x12\x15\n\rDT_VERNEED\
    NUM\x10\xff\xff\xff\xff\x06\x12\x11\n\tDT_LOPROC\x10\x80\x80\x80\x80\x07\
    \x12\x11\n\tDT_HIPROC\x10\xff\xff\xff\xff\x07\x1a\x06\x92\x93\x19\x02\
    \x10\x01B#\xfa\x92\x19\x1f\n\x03elf\x12\x07elf.ELF\x1a\x03elf\"\nelf-mod\
    uleb\x06proto2\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::yara::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(5);
            messages.push(ELF::generated_message_descriptor_data());
            messages.push(Section::generated_message_descriptor_data());
            messages.push(Segment::generated_message_descriptor_data());
            messages.push(Sym::generated_message_descriptor_data());
            messages.push(Dyn::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(10);
            enums.push(Type::generated_enum_descriptor_data());
            enums.push(Machine::generated_enum_descriptor_data());
            enums.push(OsAbi::generated_enum_descriptor_data());
            enums.push(SectionType::generated_enum_descriptor_data());
            enums.push(SegmentType::generated_enum_descriptor_data());
            enums.push(SegmentFlags::generated_enum_descriptor_data());
            enums.push(SymType::generated_enum_descriptor_data());
            enums.push(SymBind::generated_enum_descriptor_data());
            enums.push(SymVisibility::generated_enum_descriptor_data());
            enums.push(DynType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
