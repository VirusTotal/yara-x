// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `yara.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

// @@protoc_insertion_point(message:yara.ModuleOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ModuleOptions {
    // message fields
    // @@protoc_insertion_point(field:yara.ModuleOptions.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:yara.ModuleOptions.root_message)
    pub root_message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:yara.ModuleOptions.rust_module)
    pub rust_module: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:yara.ModuleOptions.cargo_feature)
    pub cargo_feature: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:yara.ModuleOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ModuleOptions {
    fn default() -> &'a ModuleOptions {
        <ModuleOptions as ::protobuf::Message>::default_instance()
    }
}

impl ModuleOptions {
    pub fn new() -> ModuleOptions {
        ::std::default::Default::default()
    }

    // required string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string root_message = 2;

    pub fn root_message(&self) -> &str {
        match self.root_message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_root_message(&mut self) {
        self.root_message = ::std::option::Option::None;
    }

    pub fn has_root_message(&self) -> bool {
        self.root_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_root_message(&mut self, v: ::std::string::String) {
        self.root_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_root_message(&mut self) -> &mut ::std::string::String {
        if self.root_message.is_none() {
            self.root_message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.root_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_root_message(&mut self) -> ::std::string::String {
        self.root_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string rust_module = 3;

    pub fn rust_module(&self) -> &str {
        match self.rust_module.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_rust_module(&mut self) {
        self.rust_module = ::std::option::Option::None;
    }

    pub fn has_rust_module(&self) -> bool {
        self.rust_module.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rust_module(&mut self, v: ::std::string::String) {
        self.rust_module = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rust_module(&mut self) -> &mut ::std::string::String {
        if self.rust_module.is_none() {
            self.rust_module = ::std::option::Option::Some(::std::string::String::new());
        }
        self.rust_module.as_mut().unwrap()
    }

    // Take field
    pub fn take_rust_module(&mut self) -> ::std::string::String {
        self.rust_module.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string cargo_feature = 4;

    pub fn cargo_feature(&self) -> &str {
        match self.cargo_feature.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_cargo_feature(&mut self) {
        self.cargo_feature = ::std::option::Option::None;
    }

    pub fn has_cargo_feature(&self) -> bool {
        self.cargo_feature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cargo_feature(&mut self, v: ::std::string::String) {
        self.cargo_feature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cargo_feature(&mut self) -> &mut ::std::string::String {
        if self.cargo_feature.is_none() {
            self.cargo_feature = ::std::option::Option::Some(::std::string::String::new());
        }
        self.cargo_feature.as_mut().unwrap()
    }

    // Take field
    pub fn take_cargo_feature(&mut self) -> ::std::string::String {
        self.cargo_feature.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ModuleOptions| { &m.name },
            |m: &mut ModuleOptions| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "root_message",
            |m: &ModuleOptions| { &m.root_message },
            |m: &mut ModuleOptions| { &mut m.root_message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rust_module",
            |m: &ModuleOptions| { &m.rust_module },
            |m: &mut ModuleOptions| { &mut m.rust_module },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cargo_feature",
            |m: &ModuleOptions| { &m.cargo_feature },
            |m: &mut ModuleOptions| { &mut m.cargo_feature },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModuleOptions>(
            "ModuleOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ModuleOptions {
    const NAME: &'static str = "ModuleOptions";

    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        if self.root_message.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.root_message = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.rust_module = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.cargo_feature = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.root_message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.rust_module.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.cargo_feature.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.root_message.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.rust_module.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.cargo_feature.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ModuleOptions {
        ModuleOptions::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.root_message = ::std::option::Option::None;
        self.rust_module = ::std::option::Option::None;
        self.cargo_feature = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ModuleOptions {
        static instance: ModuleOptions = ModuleOptions {
            name: ::std::option::Option::None,
            root_message: ::std::option::Option::None,
            rust_module: ::std::option::Option::None,
            cargo_feature: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ModuleOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ModuleOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ModuleOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModuleOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:yara.FieldOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FieldOptions {
    // message fields
    // @@protoc_insertion_point(field:yara.FieldOptions.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:yara.FieldOptions.ignore)
    pub ignore: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:yara.FieldOptions.acl)
    pub acl: ::std::vec::Vec<AclEntry>,
    // @@protoc_insertion_point(field:yara.FieldOptions.lowercase)
    pub lowercase: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:yara.FieldOptions.fmt)
    pub fmt: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:yara.FieldOptions.deprecation_notice)
    pub deprecation_notice: ::protobuf::MessageField<DeprecationNotice>,
    // special fields
    // @@protoc_insertion_point(special_field:yara.FieldOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FieldOptions {
    fn default() -> &'a FieldOptions {
        <FieldOptions as ::protobuf::Message>::default_instance()
    }
}

impl FieldOptions {
    pub fn new() -> FieldOptions {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool ignore = 2;

    pub fn ignore(&self) -> bool {
        self.ignore.unwrap_or(false)
    }

    pub fn clear_ignore(&mut self) {
        self.ignore = ::std::option::Option::None;
    }

    pub fn has_ignore(&self) -> bool {
        self.ignore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ignore(&mut self, v: bool) {
        self.ignore = ::std::option::Option::Some(v);
    }

    // optional bool lowercase = 4;

    pub fn lowercase(&self) -> bool {
        self.lowercase.unwrap_or(false)
    }

    pub fn clear_lowercase(&mut self) {
        self.lowercase = ::std::option::Option::None;
    }

    pub fn has_lowercase(&self) -> bool {
        self.lowercase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lowercase(&mut self, v: bool) {
        self.lowercase = ::std::option::Option::Some(v);
    }

    // optional string fmt = 5;

    pub fn fmt(&self) -> &str {
        match self.fmt.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fmt(&mut self) {
        self.fmt = ::std::option::Option::None;
    }

    pub fn has_fmt(&self) -> bool {
        self.fmt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fmt(&mut self, v: ::std::string::String) {
        self.fmt = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fmt(&mut self) -> &mut ::std::string::String {
        if self.fmt.is_none() {
            self.fmt = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fmt.as_mut().unwrap()
    }

    // Take field
    pub fn take_fmt(&mut self) -> ::std::string::String {
        self.fmt.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &FieldOptions| { &m.name },
            |m: &mut FieldOptions| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ignore",
            |m: &FieldOptions| { &m.ignore },
            |m: &mut FieldOptions| { &mut m.ignore },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "acl",
            |m: &FieldOptions| { &m.acl },
            |m: &mut FieldOptions| { &mut m.acl },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lowercase",
            |m: &FieldOptions| { &m.lowercase },
            |m: &mut FieldOptions| { &mut m.lowercase },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fmt",
            |m: &FieldOptions| { &m.fmt },
            |m: &mut FieldOptions| { &mut m.fmt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeprecationNotice>(
            "deprecation_notice",
            |m: &FieldOptions| { &m.deprecation_notice },
            |m: &mut FieldOptions| { &mut m.deprecation_notice },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FieldOptions>(
            "FieldOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FieldOptions {
    const NAME: &'static str = "FieldOptions";

    fn is_initialized(&self) -> bool {
        for v in &self.acl {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.deprecation_notice {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.ignore = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.acl.push(is.read_message()?);
                },
                32 => {
                    self.lowercase = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    self.fmt = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.deprecation_notice)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.ignore {
            my_size += 1 + 1;
        }
        for value in &self.acl {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.lowercase {
            my_size += 1 + 1;
        }
        if let Some(v) = self.fmt.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.deprecation_notice.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.ignore {
            os.write_bool(2, v)?;
        }
        for v in &self.acl {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.lowercase {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.fmt.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.deprecation_notice.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FieldOptions {
        FieldOptions::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.ignore = ::std::option::Option::None;
        self.acl.clear();
        self.lowercase = ::std::option::Option::None;
        self.fmt = ::std::option::Option::None;
        self.deprecation_notice.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FieldOptions {
        static instance: FieldOptions = FieldOptions {
            name: ::std::option::Option::None,
            ignore: ::std::option::Option::None,
            acl: ::std::vec::Vec::new(),
            lowercase: ::std::option::Option::None,
            fmt: ::std::option::Option::None,
            deprecation_notice: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FieldOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FieldOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FieldOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FieldOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:yara.AclEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AclEntry {
    // message fields
    // @@protoc_insertion_point(field:yara.AclEntry.error_title)
    pub error_title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:yara.AclEntry.error_label)
    pub error_label: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:yara.AclEntry.accept_if)
    pub accept_if: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:yara.AclEntry.reject_if)
    pub reject_if: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:yara.AclEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AclEntry {
    fn default() -> &'a AclEntry {
        <AclEntry as ::protobuf::Message>::default_instance()
    }
}

impl AclEntry {
    pub fn new() -> AclEntry {
        ::std::default::Default::default()
    }

    // required string error_title = 1;

    pub fn error_title(&self) -> &str {
        match self.error_title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error_title(&mut self) {
        self.error_title = ::std::option::Option::None;
    }

    pub fn has_error_title(&self) -> bool {
        self.error_title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_title(&mut self, v: ::std::string::String) {
        self.error_title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_title(&mut self) -> &mut ::std::string::String {
        if self.error_title.is_none() {
            self.error_title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error_title.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_title(&mut self) -> ::std::string::String {
        self.error_title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string error_label = 2;

    pub fn error_label(&self) -> &str {
        match self.error_label.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error_label(&mut self) {
        self.error_label = ::std::option::Option::None;
    }

    pub fn has_error_label(&self) -> bool {
        self.error_label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_label(&mut self, v: ::std::string::String) {
        self.error_label = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_label(&mut self) -> &mut ::std::string::String {
        if self.error_label.is_none() {
            self.error_label = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error_label.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_label(&mut self) -> ::std::string::String {
        self.error_label.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error_title",
            |m: &AclEntry| { &m.error_title },
            |m: &mut AclEntry| { &mut m.error_title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error_label",
            |m: &AclEntry| { &m.error_label },
            |m: &mut AclEntry| { &mut m.error_label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "accept_if",
            |m: &AclEntry| { &m.accept_if },
            |m: &mut AclEntry| { &mut m.accept_if },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "reject_if",
            |m: &AclEntry| { &m.reject_if },
            |m: &mut AclEntry| { &mut m.reject_if },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AclEntry>(
            "AclEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AclEntry {
    const NAME: &'static str = "AclEntry";

    fn is_initialized(&self) -> bool {
        if self.error_title.is_none() {
            return false;
        }
        if self.error_label.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.error_title = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.error_label = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.accept_if.push(is.read_string()?);
                },
                34 => {
                    self.reject_if.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.error_title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.error_label.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.accept_if {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.reject_if {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.error_title.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.error_label.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.accept_if {
            os.write_string(3, &v)?;
        };
        for v in &self.reject_if {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AclEntry {
        AclEntry::new()
    }

    fn clear(&mut self) {
        self.error_title = ::std::option::Option::None;
        self.error_label = ::std::option::Option::None;
        self.accept_if.clear();
        self.reject_if.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AclEntry {
        static instance: AclEntry = AclEntry {
            error_title: ::std::option::Option::None,
            error_label: ::std::option::Option::None,
            accept_if: ::std::vec::Vec::new(),
            reject_if: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AclEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AclEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AclEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AclEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:yara.DeprecationNotice)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeprecationNotice {
    // message fields
    // @@protoc_insertion_point(field:yara.DeprecationNotice.text)
    pub text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:yara.DeprecationNotice.help)
    pub help: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:yara.DeprecationNotice.replacement)
    pub replacement: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:yara.DeprecationNotice.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeprecationNotice {
    fn default() -> &'a DeprecationNotice {
        <DeprecationNotice as ::protobuf::Message>::default_instance()
    }
}

impl DeprecationNotice {
    pub fn new() -> DeprecationNotice {
        ::std::default::Default::default()
    }

    // required string text = 1;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string help = 2;

    pub fn help(&self) -> &str {
        match self.help.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_help(&mut self) {
        self.help = ::std::option::Option::None;
    }

    pub fn has_help(&self) -> bool {
        self.help.is_some()
    }

    // Param is passed by value, moved
    pub fn set_help(&mut self, v: ::std::string::String) {
        self.help = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_help(&mut self) -> &mut ::std::string::String {
        if self.help.is_none() {
            self.help = ::std::option::Option::Some(::std::string::String::new());
        }
        self.help.as_mut().unwrap()
    }

    // Take field
    pub fn take_help(&mut self) -> ::std::string::String {
        self.help.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string replacement = 3;

    pub fn replacement(&self) -> &str {
        match self.replacement.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_replacement(&mut self) {
        self.replacement = ::std::option::Option::None;
    }

    pub fn has_replacement(&self) -> bool {
        self.replacement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replacement(&mut self, v: ::std::string::String) {
        self.replacement = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_replacement(&mut self) -> &mut ::std::string::String {
        if self.replacement.is_none() {
            self.replacement = ::std::option::Option::Some(::std::string::String::new());
        }
        self.replacement.as_mut().unwrap()
    }

    // Take field
    pub fn take_replacement(&mut self) -> ::std::string::String {
        self.replacement.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &DeprecationNotice| { &m.text },
            |m: &mut DeprecationNotice| { &mut m.text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "help",
            |m: &DeprecationNotice| { &m.help },
            |m: &mut DeprecationNotice| { &mut m.help },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replacement",
            |m: &DeprecationNotice| { &m.replacement },
            |m: &mut DeprecationNotice| { &mut m.replacement },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeprecationNotice>(
            "DeprecationNotice",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeprecationNotice {
    const NAME: &'static str = "DeprecationNotice";

    fn is_initialized(&self) -> bool {
        if self.text.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.help = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.replacement = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.help.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.replacement.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.text.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.help.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.replacement.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeprecationNotice {
        DeprecationNotice::new()
    }

    fn clear(&mut self) {
        self.text = ::std::option::Option::None;
        self.help = ::std::option::Option::None;
        self.replacement = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeprecationNotice {
        static instance: DeprecationNotice = DeprecationNotice {
            text: ::std::option::Option::None,
            help: ::std::option::Option::None,
            replacement: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeprecationNotice {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeprecationNotice").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeprecationNotice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeprecationNotice {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:yara.MessageOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MessageOptions {
    // message fields
    // @@protoc_insertion_point(field:yara.MessageOptions.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:yara.MessageOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MessageOptions {
    fn default() -> &'a MessageOptions {
        <MessageOptions as ::protobuf::Message>::default_instance()
    }
}

impl MessageOptions {
    pub fn new() -> MessageOptions {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &MessageOptions| { &m.name },
            |m: &mut MessageOptions| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MessageOptions>(
            "MessageOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MessageOptions {
    const NAME: &'static str = "MessageOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MessageOptions {
        MessageOptions::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MessageOptions {
        static instance: MessageOptions = MessageOptions {
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MessageOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MessageOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MessageOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:yara.EnumOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EnumOptions {
    // message fields
    // @@protoc_insertion_point(field:yara.EnumOptions.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:yara.EnumOptions.inline)
    pub inline: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:yara.EnumOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EnumOptions {
    fn default() -> &'a EnumOptions {
        <EnumOptions as ::protobuf::Message>::default_instance()
    }
}

impl EnumOptions {
    pub fn new() -> EnumOptions {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool inline = 2;

    pub fn inline(&self) -> bool {
        self.inline.unwrap_or(false)
    }

    pub fn clear_inline(&mut self) {
        self.inline = ::std::option::Option::None;
    }

    pub fn has_inline(&self) -> bool {
        self.inline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inline(&mut self, v: bool) {
        self.inline = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &EnumOptions| { &m.name },
            |m: &mut EnumOptions| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "inline",
            |m: &EnumOptions| { &m.inline },
            |m: &mut EnumOptions| { &mut m.inline },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EnumOptions>(
            "EnumOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EnumOptions {
    const NAME: &'static str = "EnumOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.inline = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.inline {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.inline {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EnumOptions {
        EnumOptions::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.inline = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EnumOptions {
        static instance: EnumOptions = EnumOptions {
            name: ::std::option::Option::None,
            inline: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EnumOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EnumOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EnumOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnumOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:yara.EnumValueOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EnumValueOptions {
    // message oneof groups
    pub value: ::std::option::Option<enum_value_options::Value>,
    // special fields
    // @@protoc_insertion_point(special_field:yara.EnumValueOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EnumValueOptions {
    fn default() -> &'a EnumValueOptions {
        <EnumValueOptions as ::protobuf::Message>::default_instance()
    }
}

impl EnumValueOptions {
    pub fn new() -> EnumValueOptions {
        ::std::default::Default::default()
    }

    // optional int64 i64 = 1;

    pub fn i64(&self) -> i64 {
        match self.value {
            ::std::option::Option::Some(enum_value_options::Value::I64(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_i64(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_i64(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(enum_value_options::Value::I64(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_i64(&mut self, v: i64) {
        self.value = ::std::option::Option::Some(enum_value_options::Value::I64(v))
    }

    // optional double f64 = 2;

    pub fn f64(&self) -> f64 {
        match self.value {
            ::std::option::Option::Some(enum_value_options::Value::F64(v)) => v,
            _ => 0.,
        }
    }

    pub fn clear_f64(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_f64(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(enum_value_options::Value::F64(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_f64(&mut self, v: f64) {
        self.value = ::std::option::Option::Some(enum_value_options::Value::F64(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "i64",
            EnumValueOptions::has_i64,
            EnumValueOptions::i64,
            EnumValueOptions::set_i64,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "f64",
            EnumValueOptions::has_f64,
            EnumValueOptions::f64,
            EnumValueOptions::set_f64,
        ));
        oneofs.push(enum_value_options::Value::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EnumValueOptions>(
            "EnumValueOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EnumValueOptions {
    const NAME: &'static str = "EnumValueOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.value = ::std::option::Option::Some(enum_value_options::Value::I64(is.read_int64()?));
                },
                17 => {
                    self.value = ::std::option::Option::Some(enum_value_options::Value::F64(is.read_double()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &enum_value_options::Value::I64(v) => {
                    my_size += ::protobuf::rt::int64_size(1, v);
                },
                &enum_value_options::Value::F64(v) => {
                    my_size += 1 + 8;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &enum_value_options::Value::I64(v) => {
                    os.write_int64(1, v)?;
                },
                &enum_value_options::Value::F64(v) => {
                    os.write_double(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EnumValueOptions {
        EnumValueOptions::new()
    }

    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EnumValueOptions {
        static instance: EnumValueOptions = EnumValueOptions {
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EnumValueOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EnumValueOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EnumValueOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnumValueOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `EnumValueOptions`
pub mod enum_value_options {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:yara.EnumValueOptions.value)
    pub enum Value {
        // @@protoc_insertion_point(oneof_field:yara.EnumValueOptions.i64)
        I64(i64),
        // @@protoc_insertion_point(oneof_field:yara.EnumValueOptions.f64)
        F64(f64),
    }

    impl ::protobuf::Oneof for Value {
    }

    impl ::protobuf::OneofFull for Value {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::EnumValueOptions as ::protobuf::MessageFull>::descriptor().oneof_by_name("value").unwrap()).clone()
        }
    }

    impl Value {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Value>("value")
        }
    }
}

/// Extension fields
pub mod exts {

    pub const module_options: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::FileOptions, super::ModuleOptions> = ::protobuf::ext::ExtFieldOptional::new(51503, ::protobuf::descriptor::field_descriptor_proto::Type::TYPE_MESSAGE);

    pub const field_options: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::FieldOptions, super::FieldOptions> = ::protobuf::ext::ExtFieldOptional::new(51504, ::protobuf::descriptor::field_descriptor_proto::Type::TYPE_MESSAGE);

    pub const message_options: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::MessageOptions, super::MessageOptions> = ::protobuf::ext::ExtFieldOptional::new(51505, ::protobuf::descriptor::field_descriptor_proto::Type::TYPE_MESSAGE);

    pub const enum_options: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::EnumOptions, super::EnumOptions> = ::protobuf::ext::ExtFieldOptional::new(51506, ::protobuf::descriptor::field_descriptor_proto::Type::TYPE_MESSAGE);

    pub const enum_value: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::EnumValueOptions, super::EnumValueOptions> = ::protobuf::ext::ExtFieldOptional::new(51507, ::protobuf::descriptor::field_descriptor_proto::Type::TYPE_MESSAGE);
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\nyara.proto\x12\x04yara\x1a\x20google/protobuf/descriptor.proto\"\x8c\
    \x01\n\rModuleOptions\x12\x12\n\x04name\x18\x01\x20\x02(\tR\x04name\x12!\
    \n\x0croot_message\x18\x02\x20\x02(\tR\x0brootMessage\x12\x1f\n\x0brust_\
    module\x18\x03\x20\x01(\tR\nrustModule\x12#\n\rcargo_feature\x18\x04\x20\
    \x01(\tR\x0ccargoFeature\"\xd4\x01\n\x0cFieldOptions\x12\x12\n\x04name\
    \x18\x01\x20\x01(\tR\x04name\x12\x16\n\x06ignore\x18\x02\x20\x01(\x08R\
    \x06ignore\x12\x20\n\x03acl\x18\x03\x20\x03(\x0b2\x0e.yara.AclEntryR\x03\
    acl\x12\x1c\n\tlowercase\x18\x04\x20\x01(\x08R\tlowercase\x12\x10\n\x03f\
    mt\x18\x05\x20\x01(\tR\x03fmt\x12F\n\x12deprecation_notice\x18\x06\x20\
    \x01(\x0b2\x17.yara.DeprecationNoticeR\x11deprecationNotice\"\x86\x01\n\
    \x08AclEntry\x12\x1f\n\x0berror_title\x18\x01\x20\x02(\tR\nerrorTitle\
    \x12\x1f\n\x0berror_label\x18\x02\x20\x02(\tR\nerrorLabel\x12\x1b\n\tacc\
    ept_if\x18\x03\x20\x03(\tR\x08acceptIf\x12\x1b\n\treject_if\x18\x04\x20\
    \x03(\tR\x08rejectIf\"]\n\x11DeprecationNotice\x12\x12\n\x04text\x18\x01\
    \x20\x02(\tR\x04text\x12\x12\n\x04help\x18\x02\x20\x01(\tR\x04help\x12\
    \x20\n\x0breplacement\x18\x03\x20\x01(\tR\x0breplacement\"$\n\x0eMessage\
    Options\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\"9\n\x0bEnumOption\
    s\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x16\n\x06inline\x18\
    \x02\x20\x01(\x08R\x06inline\"C\n\x10EnumValueOptions\x12\x12\n\x03i64\
    \x18\x01\x20\x01(\x03H\0R\x03i64\x12\x12\n\x03f64\x18\x02\x20\x01(\x01H\
    \0R\x03f64B\x07\n\x05value:Z\n\x0emodule_options\x18\xaf\x92\x03\x20\x01\
    (\x0b2\x13.yara.ModuleOptions\x12\x1c.google.protobuf.FileOptionsR\rmodu\
    leOptions:X\n\rfield_options\x18\xb0\x92\x03\x20\x01(\x0b2\x12.yara.Fiel\
    dOptions\x12\x1d.google.protobuf.FieldOptionsR\x0cfieldOptions:`\n\x0fme\
    ssage_options\x18\xb1\x92\x03\x20\x01(\x0b2\x14.yara.MessageOptions\x12\
    \x1f.google.protobuf.MessageOptionsR\x0emessageOptions:T\n\x0cenum_optio\
    ns\x18\xb2\x92\x03\x20\x01(\x0b2\x11.yara.EnumOptions\x12\x1c.google.pro\
    tobuf.EnumOptionsR\x0benumOptions:Z\n\nenum_value\x18\xb3\x92\x03\x20\
    \x01(\x0b2\x16.yara.EnumValueOptions\x12!.google.protobuf.EnumValueOptio\
    nsR\tenumValueb\x06proto2\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(::protobuf::descriptor::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(7);
            messages.push(ModuleOptions::generated_message_descriptor_data());
            messages.push(FieldOptions::generated_message_descriptor_data());
            messages.push(AclEntry::generated_message_descriptor_data());
            messages.push(DeprecationNotice::generated_message_descriptor_data());
            messages.push(MessageOptions::generated_message_descriptor_data());
            messages.push(EnumOptions::generated_message_descriptor_data());
            messages.push(EnumValueOptions::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
