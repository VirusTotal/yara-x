// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `macho.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

// @@protoc_insertion_point(message:macho.MinVersion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MinVersion {
    // message fields
    // @@protoc_insertion_point(field:macho.MinVersion.device)
    pub device: ::std::option::Option<::protobuf::EnumOrUnknown<DeviceType>>,
    // @@protoc_insertion_point(field:macho.MinVersion.version)
    pub version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:macho.MinVersion.sdk)
    pub sdk: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:macho.MinVersion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MinVersion {
    fn default() -> &'a MinVersion {
        <MinVersion as ::protobuf::Message>::default_instance()
    }
}

impl MinVersion {
    pub fn new() -> MinVersion {
        ::std::default::Default::default()
    }

    // optional .macho.DeviceType device = 1;

    pub fn device(&self) -> DeviceType {
        match self.device {
            Some(e) => e.enum_value_or(DeviceType::MACOSX),
            None => DeviceType::MACOSX,
        }
    }

    pub fn clear_device(&mut self) {
        self.device = ::std::option::Option::None;
    }

    pub fn has_device(&self) -> bool {
        self.device.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device(&mut self, v: DeviceType) {
        self.device = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string version = 2;

    pub fn version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string sdk = 3;

    pub fn sdk(&self) -> &str {
        match self.sdk.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sdk(&mut self) {
        self.sdk = ::std::option::Option::None;
    }

    pub fn has_sdk(&self) -> bool {
        self.sdk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdk(&mut self, v: ::std::string::String) {
        self.sdk = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sdk(&mut self) -> &mut ::std::string::String {
        if self.sdk.is_none() {
            self.sdk = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sdk.as_mut().unwrap()
    }

    // Take field
    pub fn take_sdk(&mut self) -> ::std::string::String {
        self.sdk.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "device",
            |m: &MinVersion| { &m.device },
            |m: &mut MinVersion| { &mut m.device },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &MinVersion| { &m.version },
            |m: &mut MinVersion| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sdk",
            |m: &MinVersion| { &m.sdk },
            |m: &mut MinVersion| { &mut m.sdk },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MinVersion>(
            "MinVersion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MinVersion {
    const NAME: &'static str = "MinVersion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.device = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.version = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.sdk = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.device {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.sdk.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.device {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.version.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.sdk.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MinVersion {
        MinVersion::new()
    }

    fn clear(&mut self) {
        self.device = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.sdk = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MinVersion {
        static instance: MinVersion = MinVersion {
            device: ::std::option::Option::None,
            version: ::std::option::Option::None,
            sdk: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MinVersion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MinVersion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MinVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MinVersion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:macho.BuildVersion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BuildVersion {
    // message fields
    // @@protoc_insertion_point(field:macho.BuildVersion.platform)
    pub platform: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.BuildVersion.minos)
    pub minos: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:macho.BuildVersion.sdk)
    pub sdk: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:macho.BuildVersion.ntools)
    pub ntools: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.BuildVersion.tools)
    pub tools: ::std::vec::Vec<BuildTool>,
    // special fields
    // @@protoc_insertion_point(special_field:macho.BuildVersion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BuildVersion {
    fn default() -> &'a BuildVersion {
        <BuildVersion as ::protobuf::Message>::default_instance()
    }
}

impl BuildVersion {
    pub fn new() -> BuildVersion {
        ::std::default::Default::default()
    }

    // optional uint32 platform = 1;

    pub fn platform(&self) -> u32 {
        self.platform.unwrap_or(0)
    }

    pub fn clear_platform(&mut self) {
        self.platform = ::std::option::Option::None;
    }

    pub fn has_platform(&self) -> bool {
        self.platform.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform(&mut self, v: u32) {
        self.platform = ::std::option::Option::Some(v);
    }

    // optional string minos = 2;

    pub fn minos(&self) -> &str {
        match self.minos.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_minos(&mut self) {
        self.minos = ::std::option::Option::None;
    }

    pub fn has_minos(&self) -> bool {
        self.minos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minos(&mut self, v: ::std::string::String) {
        self.minos = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_minos(&mut self) -> &mut ::std::string::String {
        if self.minos.is_none() {
            self.minos = ::std::option::Option::Some(::std::string::String::new());
        }
        self.minos.as_mut().unwrap()
    }

    // Take field
    pub fn take_minos(&mut self) -> ::std::string::String {
        self.minos.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string sdk = 3;

    pub fn sdk(&self) -> &str {
        match self.sdk.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sdk(&mut self) {
        self.sdk = ::std::option::Option::None;
    }

    pub fn has_sdk(&self) -> bool {
        self.sdk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdk(&mut self, v: ::std::string::String) {
        self.sdk = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sdk(&mut self) -> &mut ::std::string::String {
        if self.sdk.is_none() {
            self.sdk = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sdk.as_mut().unwrap()
    }

    // Take field
    pub fn take_sdk(&mut self) -> ::std::string::String {
        self.sdk.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 ntools = 4;

    pub fn ntools(&self) -> u32 {
        self.ntools.unwrap_or(0)
    }

    pub fn clear_ntools(&mut self) {
        self.ntools = ::std::option::Option::None;
    }

    pub fn has_ntools(&self) -> bool {
        self.ntools.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ntools(&mut self, v: u32) {
        self.ntools = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "platform",
            |m: &BuildVersion| { &m.platform },
            |m: &mut BuildVersion| { &mut m.platform },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minos",
            |m: &BuildVersion| { &m.minos },
            |m: &mut BuildVersion| { &mut m.minos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sdk",
            |m: &BuildVersion| { &m.sdk },
            |m: &mut BuildVersion| { &mut m.sdk },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ntools",
            |m: &BuildVersion| { &m.ntools },
            |m: &mut BuildVersion| { &mut m.ntools },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tools",
            |m: &BuildVersion| { &m.tools },
            |m: &mut BuildVersion| { &mut m.tools },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BuildVersion>(
            "BuildVersion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BuildVersion {
    const NAME: &'static str = "BuildVersion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.platform = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.minos = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.sdk = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.ntools = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.tools.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.platform {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.minos.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.sdk.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.ntools {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.tools {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.platform {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.minos.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.sdk.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.ntools {
            os.write_uint32(4, v)?;
        }
        for v in &self.tools {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BuildVersion {
        BuildVersion::new()
    }

    fn clear(&mut self) {
        self.platform = ::std::option::Option::None;
        self.minos = ::std::option::Option::None;
        self.sdk = ::std::option::Option::None;
        self.ntools = ::std::option::Option::None;
        self.tools.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BuildVersion {
        static instance: BuildVersion = BuildVersion {
            platform: ::std::option::Option::None,
            minos: ::std::option::Option::None,
            sdk: ::std::option::Option::None,
            ntools: ::std::option::Option::None,
            tools: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BuildVersion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BuildVersion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BuildVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuildVersion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:macho.BuildTool)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BuildTool {
    // message fields
    // @@protoc_insertion_point(field:macho.BuildTool.tool)
    pub tool: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.BuildTool.version)
    pub version: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:macho.BuildTool.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BuildTool {
    fn default() -> &'a BuildTool {
        <BuildTool as ::protobuf::Message>::default_instance()
    }
}

impl BuildTool {
    pub fn new() -> BuildTool {
        ::std::default::Default::default()
    }

    // optional uint32 tool = 1;

    pub fn tool(&self) -> u32 {
        self.tool.unwrap_or(0)
    }

    pub fn clear_tool(&mut self) {
        self.tool = ::std::option::Option::None;
    }

    pub fn has_tool(&self) -> bool {
        self.tool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tool(&mut self, v: u32) {
        self.tool = ::std::option::Option::Some(v);
    }

    // optional string version = 2;

    pub fn version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tool",
            |m: &BuildTool| { &m.tool },
            |m: &mut BuildTool| { &mut m.tool },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &BuildTool| { &m.version },
            |m: &mut BuildTool| { &mut m.version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BuildTool>(
            "BuildTool",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BuildTool {
    const NAME: &'static str = "BuildTool";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tool = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.version = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tool {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tool {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.version.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BuildTool {
        BuildTool::new()
    }

    fn clear(&mut self) {
        self.tool = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BuildTool {
        static instance: BuildTool = BuildTool {
            tool: ::std::option::Option::None,
            version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BuildTool {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BuildTool").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BuildTool {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuildTool {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:macho.LinkedItData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LinkedItData {
    // message fields
    // @@protoc_insertion_point(field:macho.LinkedItData.dataoff)
    pub dataoff: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.LinkedItData.datasize)
    pub datasize: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:macho.LinkedItData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinkedItData {
    fn default() -> &'a LinkedItData {
        <LinkedItData as ::protobuf::Message>::default_instance()
    }
}

impl LinkedItData {
    pub fn new() -> LinkedItData {
        ::std::default::Default::default()
    }

    // optional uint32 dataoff = 1;

    pub fn dataoff(&self) -> u32 {
        self.dataoff.unwrap_or(0)
    }

    pub fn clear_dataoff(&mut self) {
        self.dataoff = ::std::option::Option::None;
    }

    pub fn has_dataoff(&self) -> bool {
        self.dataoff.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dataoff(&mut self, v: u32) {
        self.dataoff = ::std::option::Option::Some(v);
    }

    // optional uint32 datasize = 2;

    pub fn datasize(&self) -> u32 {
        self.datasize.unwrap_or(0)
    }

    pub fn clear_datasize(&mut self) {
        self.datasize = ::std::option::Option::None;
    }

    pub fn has_datasize(&self) -> bool {
        self.datasize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_datasize(&mut self, v: u32) {
        self.datasize = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dataoff",
            |m: &LinkedItData| { &m.dataoff },
            |m: &mut LinkedItData| { &mut m.dataoff },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "datasize",
            |m: &LinkedItData| { &m.datasize },
            |m: &mut LinkedItData| { &mut m.datasize },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkedItData>(
            "LinkedItData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinkedItData {
    const NAME: &'static str = "LinkedItData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dataoff = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.datasize = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dataoff {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.datasize {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dataoff {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.datasize {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinkedItData {
        LinkedItData::new()
    }

    fn clear(&mut self) {
        self.dataoff = ::std::option::Option::None;
        self.datasize = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinkedItData {
        static instance: LinkedItData = LinkedItData {
            dataoff: ::std::option::Option::None,
            datasize: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinkedItData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinkedItData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinkedItData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinkedItData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:macho.Certificate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Certificate {
    // message fields
    // @@protoc_insertion_point(field:macho.Certificate.issuer)
    pub issuer: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:macho.Certificate.subject)
    pub subject: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:macho.Certificate.is_self_signed)
    pub is_self_signed: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:macho.Certificate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Certificate {
    fn default() -> &'a Certificate {
        <Certificate as ::protobuf::Message>::default_instance()
    }
}

impl Certificate {
    pub fn new() -> Certificate {
        ::std::default::Default::default()
    }

    // required string issuer = 1;

    pub fn issuer(&self) -> &str {
        match self.issuer.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_issuer(&mut self) {
        self.issuer = ::std::option::Option::None;
    }

    pub fn has_issuer(&self) -> bool {
        self.issuer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_issuer(&mut self, v: ::std::string::String) {
        self.issuer = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_issuer(&mut self) -> &mut ::std::string::String {
        if self.issuer.is_none() {
            self.issuer = ::std::option::Option::Some(::std::string::String::new());
        }
        self.issuer.as_mut().unwrap()
    }

    // Take field
    pub fn take_issuer(&mut self) -> ::std::string::String {
        self.issuer.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string subject = 2;

    pub fn subject(&self) -> &str {
        match self.subject.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_subject(&mut self) {
        self.subject = ::std::option::Option::None;
    }

    pub fn has_subject(&self) -> bool {
        self.subject.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subject(&mut self, v: ::std::string::String) {
        self.subject = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subject(&mut self) -> &mut ::std::string::String {
        if self.subject.is_none() {
            self.subject = ::std::option::Option::Some(::std::string::String::new());
        }
        self.subject.as_mut().unwrap()
    }

    // Take field
    pub fn take_subject(&mut self) -> ::std::string::String {
        self.subject.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required bool is_self_signed = 3;

    pub fn is_self_signed(&self) -> bool {
        self.is_self_signed.unwrap_or(false)
    }

    pub fn clear_is_self_signed(&mut self) {
        self.is_self_signed = ::std::option::Option::None;
    }

    pub fn has_is_self_signed(&self) -> bool {
        self.is_self_signed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_self_signed(&mut self, v: bool) {
        self.is_self_signed = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "issuer",
            |m: &Certificate| { &m.issuer },
            |m: &mut Certificate| { &mut m.issuer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subject",
            |m: &Certificate| { &m.subject },
            |m: &mut Certificate| { &mut m.subject },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_self_signed",
            |m: &Certificate| { &m.is_self_signed },
            |m: &mut Certificate| { &mut m.is_self_signed },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Certificate>(
            "Certificate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Certificate {
    const NAME: &'static str = "Certificate";

    fn is_initialized(&self) -> bool {
        if self.issuer.is_none() {
            return false;
        }
        if self.subject.is_none() {
            return false;
        }
        if self.is_self_signed.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.issuer = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.subject = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.is_self_signed = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.issuer.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.subject.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.is_self_signed {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.issuer.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.subject.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.is_self_signed {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Certificate {
        Certificate::new()
    }

    fn clear(&mut self) {
        self.issuer = ::std::option::Option::None;
        self.subject = ::std::option::Option::None;
        self.is_self_signed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Certificate {
        static instance: Certificate = Certificate {
            issuer: ::std::option::Option::None,
            subject: ::std::option::Option::None,
            is_self_signed: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Certificate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Certificate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Certificate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Certificate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:macho.Dylib)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Dylib {
    // message fields
    // @@protoc_insertion_point(field:macho.Dylib.name)
    pub name: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:macho.Dylib.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Dylib.compatibility_version)
    pub compatibility_version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:macho.Dylib.current_version)
    pub current_version: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:macho.Dylib.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Dylib {
    fn default() -> &'a Dylib {
        <Dylib as ::protobuf::Message>::default_instance()
    }
}

impl Dylib {
    pub fn new() -> Dylib {
        ::std::default::Default::default()
    }

    // required bytes name = 1;

    pub fn name(&self) -> &[u8] {
        match self.name.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::vec::Vec<u8>) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::vec::Vec<u8> {
        self.name.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required uint32 timestamp = 2;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // required string compatibility_version = 3;

    pub fn compatibility_version(&self) -> &str {
        match self.compatibility_version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_compatibility_version(&mut self) {
        self.compatibility_version = ::std::option::Option::None;
    }

    pub fn has_compatibility_version(&self) -> bool {
        self.compatibility_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_compatibility_version(&mut self, v: ::std::string::String) {
        self.compatibility_version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_compatibility_version(&mut self) -> &mut ::std::string::String {
        if self.compatibility_version.is_none() {
            self.compatibility_version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.compatibility_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_compatibility_version(&mut self) -> ::std::string::String {
        self.compatibility_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string current_version = 4;

    pub fn current_version(&self) -> &str {
        match self.current_version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_current_version(&mut self) {
        self.current_version = ::std::option::Option::None;
    }

    pub fn has_current_version(&self) -> bool {
        self.current_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_version(&mut self, v: ::std::string::String) {
        self.current_version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_current_version(&mut self) -> &mut ::std::string::String {
        if self.current_version.is_none() {
            self.current_version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.current_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_current_version(&mut self) -> ::std::string::String {
        self.current_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &Dylib| { &m.name },
            |m: &mut Dylib| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &Dylib| { &m.timestamp },
            |m: &mut Dylib| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "compatibility_version",
            |m: &Dylib| { &m.compatibility_version },
            |m: &mut Dylib| { &mut m.compatibility_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "current_version",
            |m: &Dylib| { &m.current_version },
            |m: &mut Dylib| { &mut m.current_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Dylib>(
            "Dylib",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Dylib {
    const NAME: &'static str = "Dylib";

    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        if self.timestamp.is_none() {
            return false;
        }
        if self.compatibility_version.is_none() {
            return false;
        }
        if self.current_version.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_bytes()?);
                },
                16 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.compatibility_version = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.current_version = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.compatibility_version.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.current_version.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.compatibility_version.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.current_version.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Dylib {
        Dylib::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.compatibility_version = ::std::option::Option::None;
        self.current_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Dylib {
        static instance: Dylib = Dylib {
            name: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            compatibility_version: ::std::option::Option::None,
            current_version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Dylib {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Dylib").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Dylib {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Dylib {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:macho.DyldInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DyldInfo {
    // message fields
    // @@protoc_insertion_point(field:macho.DyldInfo.rebase_off)
    pub rebase_off: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.DyldInfo.rebase_size)
    pub rebase_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.DyldInfo.bind_off)
    pub bind_off: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.DyldInfo.bind_size)
    pub bind_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.DyldInfo.weak_bind_off)
    pub weak_bind_off: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.DyldInfo.weak_bind_size)
    pub weak_bind_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.DyldInfo.lazy_bind_off)
    pub lazy_bind_off: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.DyldInfo.lazy_bind_size)
    pub lazy_bind_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.DyldInfo.export_off)
    pub export_off: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.DyldInfo.export_size)
    pub export_size: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:macho.DyldInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DyldInfo {
    fn default() -> &'a DyldInfo {
        <DyldInfo as ::protobuf::Message>::default_instance()
    }
}

impl DyldInfo {
    pub fn new() -> DyldInfo {
        ::std::default::Default::default()
    }

    // optional uint32 rebase_off = 1;

    pub fn rebase_off(&self) -> u32 {
        self.rebase_off.unwrap_or(0)
    }

    pub fn clear_rebase_off(&mut self) {
        self.rebase_off = ::std::option::Option::None;
    }

    pub fn has_rebase_off(&self) -> bool {
        self.rebase_off.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rebase_off(&mut self, v: u32) {
        self.rebase_off = ::std::option::Option::Some(v);
    }

    // optional uint32 rebase_size = 2;

    pub fn rebase_size(&self) -> u32 {
        self.rebase_size.unwrap_or(0)
    }

    pub fn clear_rebase_size(&mut self) {
        self.rebase_size = ::std::option::Option::None;
    }

    pub fn has_rebase_size(&self) -> bool {
        self.rebase_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rebase_size(&mut self, v: u32) {
        self.rebase_size = ::std::option::Option::Some(v);
    }

    // optional uint32 bind_off = 3;

    pub fn bind_off(&self) -> u32 {
        self.bind_off.unwrap_or(0)
    }

    pub fn clear_bind_off(&mut self) {
        self.bind_off = ::std::option::Option::None;
    }

    pub fn has_bind_off(&self) -> bool {
        self.bind_off.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bind_off(&mut self, v: u32) {
        self.bind_off = ::std::option::Option::Some(v);
    }

    // optional uint32 bind_size = 4;

    pub fn bind_size(&self) -> u32 {
        self.bind_size.unwrap_or(0)
    }

    pub fn clear_bind_size(&mut self) {
        self.bind_size = ::std::option::Option::None;
    }

    pub fn has_bind_size(&self) -> bool {
        self.bind_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bind_size(&mut self, v: u32) {
        self.bind_size = ::std::option::Option::Some(v);
    }

    // optional uint32 weak_bind_off = 5;

    pub fn weak_bind_off(&self) -> u32 {
        self.weak_bind_off.unwrap_or(0)
    }

    pub fn clear_weak_bind_off(&mut self) {
        self.weak_bind_off = ::std::option::Option::None;
    }

    pub fn has_weak_bind_off(&self) -> bool {
        self.weak_bind_off.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weak_bind_off(&mut self, v: u32) {
        self.weak_bind_off = ::std::option::Option::Some(v);
    }

    // optional uint32 weak_bind_size = 6;

    pub fn weak_bind_size(&self) -> u32 {
        self.weak_bind_size.unwrap_or(0)
    }

    pub fn clear_weak_bind_size(&mut self) {
        self.weak_bind_size = ::std::option::Option::None;
    }

    pub fn has_weak_bind_size(&self) -> bool {
        self.weak_bind_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weak_bind_size(&mut self, v: u32) {
        self.weak_bind_size = ::std::option::Option::Some(v);
    }

    // optional uint32 lazy_bind_off = 7;

    pub fn lazy_bind_off(&self) -> u32 {
        self.lazy_bind_off.unwrap_or(0)
    }

    pub fn clear_lazy_bind_off(&mut self) {
        self.lazy_bind_off = ::std::option::Option::None;
    }

    pub fn has_lazy_bind_off(&self) -> bool {
        self.lazy_bind_off.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lazy_bind_off(&mut self, v: u32) {
        self.lazy_bind_off = ::std::option::Option::Some(v);
    }

    // optional uint32 lazy_bind_size = 8;

    pub fn lazy_bind_size(&self) -> u32 {
        self.lazy_bind_size.unwrap_or(0)
    }

    pub fn clear_lazy_bind_size(&mut self) {
        self.lazy_bind_size = ::std::option::Option::None;
    }

    pub fn has_lazy_bind_size(&self) -> bool {
        self.lazy_bind_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lazy_bind_size(&mut self, v: u32) {
        self.lazy_bind_size = ::std::option::Option::Some(v);
    }

    // optional uint32 export_off = 9;

    pub fn export_off(&self) -> u32 {
        self.export_off.unwrap_or(0)
    }

    pub fn clear_export_off(&mut self) {
        self.export_off = ::std::option::Option::None;
    }

    pub fn has_export_off(&self) -> bool {
        self.export_off.is_some()
    }

    // Param is passed by value, moved
    pub fn set_export_off(&mut self, v: u32) {
        self.export_off = ::std::option::Option::Some(v);
    }

    // optional uint32 export_size = 10;

    pub fn export_size(&self) -> u32 {
        self.export_size.unwrap_or(0)
    }

    pub fn clear_export_size(&mut self) {
        self.export_size = ::std::option::Option::None;
    }

    pub fn has_export_size(&self) -> bool {
        self.export_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_export_size(&mut self, v: u32) {
        self.export_size = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rebase_off",
            |m: &DyldInfo| { &m.rebase_off },
            |m: &mut DyldInfo| { &mut m.rebase_off },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rebase_size",
            |m: &DyldInfo| { &m.rebase_size },
            |m: &mut DyldInfo| { &mut m.rebase_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bind_off",
            |m: &DyldInfo| { &m.bind_off },
            |m: &mut DyldInfo| { &mut m.bind_off },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bind_size",
            |m: &DyldInfo| { &m.bind_size },
            |m: &mut DyldInfo| { &mut m.bind_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "weak_bind_off",
            |m: &DyldInfo| { &m.weak_bind_off },
            |m: &mut DyldInfo| { &mut m.weak_bind_off },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "weak_bind_size",
            |m: &DyldInfo| { &m.weak_bind_size },
            |m: &mut DyldInfo| { &mut m.weak_bind_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lazy_bind_off",
            |m: &DyldInfo| { &m.lazy_bind_off },
            |m: &mut DyldInfo| { &mut m.lazy_bind_off },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lazy_bind_size",
            |m: &DyldInfo| { &m.lazy_bind_size },
            |m: &mut DyldInfo| { &mut m.lazy_bind_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "export_off",
            |m: &DyldInfo| { &m.export_off },
            |m: &mut DyldInfo| { &mut m.export_off },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "export_size",
            |m: &DyldInfo| { &m.export_size },
            |m: &mut DyldInfo| { &mut m.export_size },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DyldInfo>(
            "DyldInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DyldInfo {
    const NAME: &'static str = "DyldInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.rebase_off = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.rebase_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.bind_off = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.bind_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.weak_bind_off = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.weak_bind_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.lazy_bind_off = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.lazy_bind_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.export_off = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.export_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rebase_off {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.rebase_size {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.bind_off {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.bind_size {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.weak_bind_off {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.weak_bind_size {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.lazy_bind_off {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.lazy_bind_size {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.export_off {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.export_size {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rebase_off {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.rebase_size {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.bind_off {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.bind_size {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.weak_bind_off {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.weak_bind_size {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.lazy_bind_off {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.lazy_bind_size {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.export_off {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.export_size {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DyldInfo {
        DyldInfo::new()
    }

    fn clear(&mut self) {
        self.rebase_off = ::std::option::Option::None;
        self.rebase_size = ::std::option::Option::None;
        self.bind_off = ::std::option::Option::None;
        self.bind_size = ::std::option::Option::None;
        self.weak_bind_off = ::std::option::Option::None;
        self.weak_bind_size = ::std::option::Option::None;
        self.lazy_bind_off = ::std::option::Option::None;
        self.lazy_bind_size = ::std::option::Option::None;
        self.export_off = ::std::option::Option::None;
        self.export_size = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DyldInfo {
        static instance: DyldInfo = DyldInfo {
            rebase_off: ::std::option::Option::None,
            rebase_size: ::std::option::Option::None,
            bind_off: ::std::option::Option::None,
            bind_size: ::std::option::Option::None,
            weak_bind_off: ::std::option::Option::None,
            weak_bind_size: ::std::option::Option::None,
            lazy_bind_off: ::std::option::Option::None,
            lazy_bind_size: ::std::option::Option::None,
            export_off: ::std::option::Option::None,
            export_size: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DyldInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DyldInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DyldInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DyldInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:macho.Nlist)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Nlist {
    // message fields
    // @@protoc_insertion_point(field:macho.Nlist.n_strx)
    pub n_strx: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Nlist.n_type)
    pub n_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Nlist.n_sect)
    pub n_sect: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Nlist.n_desc)
    pub n_desc: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Nlist.n_value)
    pub n_value: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:macho.Nlist.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Nlist {
    fn default() -> &'a Nlist {
        <Nlist as ::protobuf::Message>::default_instance()
    }
}

impl Nlist {
    pub fn new() -> Nlist {
        ::std::default::Default::default()
    }

    // optional uint32 n_strx = 1;

    pub fn n_strx(&self) -> u32 {
        self.n_strx.unwrap_or(0)
    }

    pub fn clear_n_strx(&mut self) {
        self.n_strx = ::std::option::Option::None;
    }

    pub fn has_n_strx(&self) -> bool {
        self.n_strx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_n_strx(&mut self, v: u32) {
        self.n_strx = ::std::option::Option::Some(v);
    }

    // optional uint32 n_type = 2;

    pub fn n_type(&self) -> u32 {
        self.n_type.unwrap_or(0)
    }

    pub fn clear_n_type(&mut self) {
        self.n_type = ::std::option::Option::None;
    }

    pub fn has_n_type(&self) -> bool {
        self.n_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_n_type(&mut self, v: u32) {
        self.n_type = ::std::option::Option::Some(v);
    }

    // optional uint32 n_sect = 3;

    pub fn n_sect(&self) -> u32 {
        self.n_sect.unwrap_or(0)
    }

    pub fn clear_n_sect(&mut self) {
        self.n_sect = ::std::option::Option::None;
    }

    pub fn has_n_sect(&self) -> bool {
        self.n_sect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_n_sect(&mut self, v: u32) {
        self.n_sect = ::std::option::Option::Some(v);
    }

    // optional uint32 n_desc = 4;

    pub fn n_desc(&self) -> u32 {
        self.n_desc.unwrap_or(0)
    }

    pub fn clear_n_desc(&mut self) {
        self.n_desc = ::std::option::Option::None;
    }

    pub fn has_n_desc(&self) -> bool {
        self.n_desc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_n_desc(&mut self, v: u32) {
        self.n_desc = ::std::option::Option::Some(v);
    }

    // optional uint64 n_value = 5;

    pub fn n_value(&self) -> u64 {
        self.n_value.unwrap_or(0)
    }

    pub fn clear_n_value(&mut self) {
        self.n_value = ::std::option::Option::None;
    }

    pub fn has_n_value(&self) -> bool {
        self.n_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_n_value(&mut self, v: u64) {
        self.n_value = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "n_strx",
            |m: &Nlist| { &m.n_strx },
            |m: &mut Nlist| { &mut m.n_strx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "n_type",
            |m: &Nlist| { &m.n_type },
            |m: &mut Nlist| { &mut m.n_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "n_sect",
            |m: &Nlist| { &m.n_sect },
            |m: &mut Nlist| { &mut m.n_sect },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "n_desc",
            |m: &Nlist| { &m.n_desc },
            |m: &mut Nlist| { &mut m.n_desc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "n_value",
            |m: &Nlist| { &m.n_value },
            |m: &mut Nlist| { &mut m.n_value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Nlist>(
            "Nlist",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Nlist {
    const NAME: &'static str = "Nlist";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.n_strx = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.n_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.n_sect = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.n_desc = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.n_value = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.n_strx {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.n_type {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.n_sect {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.n_desc {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.n_value {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.n_strx {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.n_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.n_sect {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.n_desc {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.n_value {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Nlist {
        Nlist::new()
    }

    fn clear(&mut self) {
        self.n_strx = ::std::option::Option::None;
        self.n_type = ::std::option::Option::None;
        self.n_sect = ::std::option::Option::None;
        self.n_desc = ::std::option::Option::None;
        self.n_value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Nlist {
        static instance: Nlist = Nlist {
            n_strx: ::std::option::Option::None,
            n_type: ::std::option::Option::None,
            n_sect: ::std::option::Option::None,
            n_desc: ::std::option::Option::None,
            n_value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Nlist {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Nlist").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Nlist {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Nlist {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:macho.Symtab)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Symtab {
    // message fields
    // @@protoc_insertion_point(field:macho.Symtab.symoff)
    pub symoff: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Symtab.nsyms)
    pub nsyms: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Symtab.stroff)
    pub stroff: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Symtab.strsize)
    pub strsize: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Symtab.entries)
    pub entries: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:macho.Symtab.nlists)
    pub nlists: ::std::vec::Vec<Nlist>,
    // special fields
    // @@protoc_insertion_point(special_field:macho.Symtab.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Symtab {
    fn default() -> &'a Symtab {
        <Symtab as ::protobuf::Message>::default_instance()
    }
}

impl Symtab {
    pub fn new() -> Symtab {
        ::std::default::Default::default()
    }

    // optional uint32 symoff = 1;

    pub fn symoff(&self) -> u32 {
        self.symoff.unwrap_or(0)
    }

    pub fn clear_symoff(&mut self) {
        self.symoff = ::std::option::Option::None;
    }

    pub fn has_symoff(&self) -> bool {
        self.symoff.is_some()
    }

    // Param is passed by value, moved
    pub fn set_symoff(&mut self, v: u32) {
        self.symoff = ::std::option::Option::Some(v);
    }

    // optional uint32 nsyms = 2;

    pub fn nsyms(&self) -> u32 {
        self.nsyms.unwrap_or(0)
    }

    pub fn clear_nsyms(&mut self) {
        self.nsyms = ::std::option::Option::None;
    }

    pub fn has_nsyms(&self) -> bool {
        self.nsyms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nsyms(&mut self, v: u32) {
        self.nsyms = ::std::option::Option::Some(v);
    }

    // optional uint32 stroff = 3;

    pub fn stroff(&self) -> u32 {
        self.stroff.unwrap_or(0)
    }

    pub fn clear_stroff(&mut self) {
        self.stroff = ::std::option::Option::None;
    }

    pub fn has_stroff(&self) -> bool {
        self.stroff.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stroff(&mut self, v: u32) {
        self.stroff = ::std::option::Option::Some(v);
    }

    // optional uint32 strsize = 4;

    pub fn strsize(&self) -> u32 {
        self.strsize.unwrap_or(0)
    }

    pub fn clear_strsize(&mut self) {
        self.strsize = ::std::option::Option::None;
    }

    pub fn has_strsize(&self) -> bool {
        self.strsize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strsize(&mut self, v: u32) {
        self.strsize = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "symoff",
            |m: &Symtab| { &m.symoff },
            |m: &mut Symtab| { &mut m.symoff },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nsyms",
            |m: &Symtab| { &m.nsyms },
            |m: &mut Symtab| { &mut m.nsyms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stroff",
            |m: &Symtab| { &m.stroff },
            |m: &mut Symtab| { &mut m.stroff },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "strsize",
            |m: &Symtab| { &m.strsize },
            |m: &mut Symtab| { &mut m.strsize },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entries",
            |m: &Symtab| { &m.entries },
            |m: &mut Symtab| { &mut m.entries },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "nlists",
            |m: &Symtab| { &m.nlists },
            |m: &mut Symtab| { &mut m.nlists },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Symtab>(
            "Symtab",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Symtab {
    const NAME: &'static str = "Symtab";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.symoff = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.nsyms = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.stroff = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.strsize = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.entries.push(is.read_bytes()?);
                },
                50 => {
                    self.nlists.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.symoff {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.nsyms {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.stroff {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.strsize {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.entries {
            my_size += ::protobuf::rt::bytes_size(5, &value);
        };
        for value in &self.nlists {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.symoff {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.nsyms {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.stroff {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.strsize {
            os.write_uint32(4, v)?;
        }
        for v in &self.entries {
            os.write_bytes(5, &v)?;
        };
        for v in &self.nlists {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Symtab {
        Symtab::new()
    }

    fn clear(&mut self) {
        self.symoff = ::std::option::Option::None;
        self.nsyms = ::std::option::Option::None;
        self.stroff = ::std::option::Option::None;
        self.strsize = ::std::option::Option::None;
        self.entries.clear();
        self.nlists.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Symtab {
        static instance: Symtab = Symtab {
            symoff: ::std::option::Option::None,
            nsyms: ::std::option::Option::None,
            stroff: ::std::option::Option::None,
            strsize: ::std::option::Option::None,
            entries: ::std::vec::Vec::new(),
            nlists: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Symtab {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Symtab").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Symtab {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Symtab {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:macho.Dysymtab)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Dysymtab {
    // message fields
    // @@protoc_insertion_point(field:macho.Dysymtab.ilocalsym)
    pub ilocalsym: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Dysymtab.nlocalsym)
    pub nlocalsym: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Dysymtab.iextdefsym)
    pub iextdefsym: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Dysymtab.nextdefsym)
    pub nextdefsym: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Dysymtab.iundefsym)
    pub iundefsym: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Dysymtab.nundefsym)
    pub nundefsym: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Dysymtab.tocoff)
    pub tocoff: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Dysymtab.ntoc)
    pub ntoc: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Dysymtab.modtaboff)
    pub modtaboff: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Dysymtab.nmodtab)
    pub nmodtab: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Dysymtab.extrefsymoff)
    pub extrefsymoff: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Dysymtab.nextrefsyms)
    pub nextrefsyms: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Dysymtab.indirectsymoff)
    pub indirectsymoff: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Dysymtab.nindirectsyms)
    pub nindirectsyms: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Dysymtab.extreloff)
    pub extreloff: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Dysymtab.nextrel)
    pub nextrel: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Dysymtab.locreloff)
    pub locreloff: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Dysymtab.nlocrel)
    pub nlocrel: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:macho.Dysymtab.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Dysymtab {
    fn default() -> &'a Dysymtab {
        <Dysymtab as ::protobuf::Message>::default_instance()
    }
}

impl Dysymtab {
    pub fn new() -> Dysymtab {
        ::std::default::Default::default()
    }

    // optional uint32 ilocalsym = 3;

    pub fn ilocalsym(&self) -> u32 {
        self.ilocalsym.unwrap_or(0)
    }

    pub fn clear_ilocalsym(&mut self) {
        self.ilocalsym = ::std::option::Option::None;
    }

    pub fn has_ilocalsym(&self) -> bool {
        self.ilocalsym.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ilocalsym(&mut self, v: u32) {
        self.ilocalsym = ::std::option::Option::Some(v);
    }

    // optional uint32 nlocalsym = 4;

    pub fn nlocalsym(&self) -> u32 {
        self.nlocalsym.unwrap_or(0)
    }

    pub fn clear_nlocalsym(&mut self) {
        self.nlocalsym = ::std::option::Option::None;
    }

    pub fn has_nlocalsym(&self) -> bool {
        self.nlocalsym.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nlocalsym(&mut self, v: u32) {
        self.nlocalsym = ::std::option::Option::Some(v);
    }

    // optional uint32 iextdefsym = 5;

    pub fn iextdefsym(&self) -> u32 {
        self.iextdefsym.unwrap_or(0)
    }

    pub fn clear_iextdefsym(&mut self) {
        self.iextdefsym = ::std::option::Option::None;
    }

    pub fn has_iextdefsym(&self) -> bool {
        self.iextdefsym.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iextdefsym(&mut self, v: u32) {
        self.iextdefsym = ::std::option::Option::Some(v);
    }

    // optional uint32 nextdefsym = 6;

    pub fn nextdefsym(&self) -> u32 {
        self.nextdefsym.unwrap_or(0)
    }

    pub fn clear_nextdefsym(&mut self) {
        self.nextdefsym = ::std::option::Option::None;
    }

    pub fn has_nextdefsym(&self) -> bool {
        self.nextdefsym.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nextdefsym(&mut self, v: u32) {
        self.nextdefsym = ::std::option::Option::Some(v);
    }

    // optional uint32 iundefsym = 7;

    pub fn iundefsym(&self) -> u32 {
        self.iundefsym.unwrap_or(0)
    }

    pub fn clear_iundefsym(&mut self) {
        self.iundefsym = ::std::option::Option::None;
    }

    pub fn has_iundefsym(&self) -> bool {
        self.iundefsym.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iundefsym(&mut self, v: u32) {
        self.iundefsym = ::std::option::Option::Some(v);
    }

    // optional uint32 nundefsym = 8;

    pub fn nundefsym(&self) -> u32 {
        self.nundefsym.unwrap_or(0)
    }

    pub fn clear_nundefsym(&mut self) {
        self.nundefsym = ::std::option::Option::None;
    }

    pub fn has_nundefsym(&self) -> bool {
        self.nundefsym.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nundefsym(&mut self, v: u32) {
        self.nundefsym = ::std::option::Option::Some(v);
    }

    // optional uint32 tocoff = 9;

    pub fn tocoff(&self) -> u32 {
        self.tocoff.unwrap_or(0)
    }

    pub fn clear_tocoff(&mut self) {
        self.tocoff = ::std::option::Option::None;
    }

    pub fn has_tocoff(&self) -> bool {
        self.tocoff.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tocoff(&mut self, v: u32) {
        self.tocoff = ::std::option::Option::Some(v);
    }

    // optional uint32 ntoc = 10;

    pub fn ntoc(&self) -> u32 {
        self.ntoc.unwrap_or(0)
    }

    pub fn clear_ntoc(&mut self) {
        self.ntoc = ::std::option::Option::None;
    }

    pub fn has_ntoc(&self) -> bool {
        self.ntoc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ntoc(&mut self, v: u32) {
        self.ntoc = ::std::option::Option::Some(v);
    }

    // optional uint32 modtaboff = 11;

    pub fn modtaboff(&self) -> u32 {
        self.modtaboff.unwrap_or(0)
    }

    pub fn clear_modtaboff(&mut self) {
        self.modtaboff = ::std::option::Option::None;
    }

    pub fn has_modtaboff(&self) -> bool {
        self.modtaboff.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modtaboff(&mut self, v: u32) {
        self.modtaboff = ::std::option::Option::Some(v);
    }

    // optional uint32 nmodtab = 12;

    pub fn nmodtab(&self) -> u32 {
        self.nmodtab.unwrap_or(0)
    }

    pub fn clear_nmodtab(&mut self) {
        self.nmodtab = ::std::option::Option::None;
    }

    pub fn has_nmodtab(&self) -> bool {
        self.nmodtab.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nmodtab(&mut self, v: u32) {
        self.nmodtab = ::std::option::Option::Some(v);
    }

    // optional uint32 extrefsymoff = 13;

    pub fn extrefsymoff(&self) -> u32 {
        self.extrefsymoff.unwrap_or(0)
    }

    pub fn clear_extrefsymoff(&mut self) {
        self.extrefsymoff = ::std::option::Option::None;
    }

    pub fn has_extrefsymoff(&self) -> bool {
        self.extrefsymoff.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extrefsymoff(&mut self, v: u32) {
        self.extrefsymoff = ::std::option::Option::Some(v);
    }

    // optional uint32 nextrefsyms = 14;

    pub fn nextrefsyms(&self) -> u32 {
        self.nextrefsyms.unwrap_or(0)
    }

    pub fn clear_nextrefsyms(&mut self) {
        self.nextrefsyms = ::std::option::Option::None;
    }

    pub fn has_nextrefsyms(&self) -> bool {
        self.nextrefsyms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nextrefsyms(&mut self, v: u32) {
        self.nextrefsyms = ::std::option::Option::Some(v);
    }

    // optional uint32 indirectsymoff = 15;

    pub fn indirectsymoff(&self) -> u32 {
        self.indirectsymoff.unwrap_or(0)
    }

    pub fn clear_indirectsymoff(&mut self) {
        self.indirectsymoff = ::std::option::Option::None;
    }

    pub fn has_indirectsymoff(&self) -> bool {
        self.indirectsymoff.is_some()
    }

    // Param is passed by value, moved
    pub fn set_indirectsymoff(&mut self, v: u32) {
        self.indirectsymoff = ::std::option::Option::Some(v);
    }

    // optional uint32 nindirectsyms = 16;

    pub fn nindirectsyms(&self) -> u32 {
        self.nindirectsyms.unwrap_or(0)
    }

    pub fn clear_nindirectsyms(&mut self) {
        self.nindirectsyms = ::std::option::Option::None;
    }

    pub fn has_nindirectsyms(&self) -> bool {
        self.nindirectsyms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nindirectsyms(&mut self, v: u32) {
        self.nindirectsyms = ::std::option::Option::Some(v);
    }

    // optional uint32 extreloff = 17;

    pub fn extreloff(&self) -> u32 {
        self.extreloff.unwrap_or(0)
    }

    pub fn clear_extreloff(&mut self) {
        self.extreloff = ::std::option::Option::None;
    }

    pub fn has_extreloff(&self) -> bool {
        self.extreloff.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extreloff(&mut self, v: u32) {
        self.extreloff = ::std::option::Option::Some(v);
    }

    // optional uint32 nextrel = 18;

    pub fn nextrel(&self) -> u32 {
        self.nextrel.unwrap_or(0)
    }

    pub fn clear_nextrel(&mut self) {
        self.nextrel = ::std::option::Option::None;
    }

    pub fn has_nextrel(&self) -> bool {
        self.nextrel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nextrel(&mut self, v: u32) {
        self.nextrel = ::std::option::Option::Some(v);
    }

    // optional uint32 locreloff = 19;

    pub fn locreloff(&self) -> u32 {
        self.locreloff.unwrap_or(0)
    }

    pub fn clear_locreloff(&mut self) {
        self.locreloff = ::std::option::Option::None;
    }

    pub fn has_locreloff(&self) -> bool {
        self.locreloff.is_some()
    }

    // Param is passed by value, moved
    pub fn set_locreloff(&mut self, v: u32) {
        self.locreloff = ::std::option::Option::Some(v);
    }

    // optional uint32 nlocrel = 20;

    pub fn nlocrel(&self) -> u32 {
        self.nlocrel.unwrap_or(0)
    }

    pub fn clear_nlocrel(&mut self) {
        self.nlocrel = ::std::option::Option::None;
    }

    pub fn has_nlocrel(&self) -> bool {
        self.nlocrel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nlocrel(&mut self, v: u32) {
        self.nlocrel = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(18);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ilocalsym",
            |m: &Dysymtab| { &m.ilocalsym },
            |m: &mut Dysymtab| { &mut m.ilocalsym },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nlocalsym",
            |m: &Dysymtab| { &m.nlocalsym },
            |m: &mut Dysymtab| { &mut m.nlocalsym },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "iextdefsym",
            |m: &Dysymtab| { &m.iextdefsym },
            |m: &mut Dysymtab| { &mut m.iextdefsym },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nextdefsym",
            |m: &Dysymtab| { &m.nextdefsym },
            |m: &mut Dysymtab| { &mut m.nextdefsym },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "iundefsym",
            |m: &Dysymtab| { &m.iundefsym },
            |m: &mut Dysymtab| { &mut m.iundefsym },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nundefsym",
            |m: &Dysymtab| { &m.nundefsym },
            |m: &mut Dysymtab| { &mut m.nundefsym },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tocoff",
            |m: &Dysymtab| { &m.tocoff },
            |m: &mut Dysymtab| { &mut m.tocoff },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ntoc",
            |m: &Dysymtab| { &m.ntoc },
            |m: &mut Dysymtab| { &mut m.ntoc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "modtaboff",
            |m: &Dysymtab| { &m.modtaboff },
            |m: &mut Dysymtab| { &mut m.modtaboff },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nmodtab",
            |m: &Dysymtab| { &m.nmodtab },
            |m: &mut Dysymtab| { &mut m.nmodtab },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "extrefsymoff",
            |m: &Dysymtab| { &m.extrefsymoff },
            |m: &mut Dysymtab| { &mut m.extrefsymoff },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nextrefsyms",
            |m: &Dysymtab| { &m.nextrefsyms },
            |m: &mut Dysymtab| { &mut m.nextrefsyms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "indirectsymoff",
            |m: &Dysymtab| { &m.indirectsymoff },
            |m: &mut Dysymtab| { &mut m.indirectsymoff },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nindirectsyms",
            |m: &Dysymtab| { &m.nindirectsyms },
            |m: &mut Dysymtab| { &mut m.nindirectsyms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "extreloff",
            |m: &Dysymtab| { &m.extreloff },
            |m: &mut Dysymtab| { &mut m.extreloff },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nextrel",
            |m: &Dysymtab| { &m.nextrel },
            |m: &mut Dysymtab| { &mut m.nextrel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "locreloff",
            |m: &Dysymtab| { &m.locreloff },
            |m: &mut Dysymtab| { &mut m.locreloff },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nlocrel",
            |m: &Dysymtab| { &m.nlocrel },
            |m: &mut Dysymtab| { &mut m.nlocrel },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Dysymtab>(
            "Dysymtab",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Dysymtab {
    const NAME: &'static str = "Dysymtab";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                24 => {
                    self.ilocalsym = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.nlocalsym = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.iextdefsym = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.nextdefsym = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.iundefsym = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.nundefsym = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.tocoff = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.ntoc = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.modtaboff = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.nmodtab = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.extrefsymoff = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.nextrefsyms = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.indirectsymoff = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.nindirectsyms = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.extreloff = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.nextrel = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.locreloff = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.nlocrel = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ilocalsym {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.nlocalsym {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.iextdefsym {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.nextdefsym {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.iundefsym {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.nundefsym {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.tocoff {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.ntoc {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.modtaboff {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.nmodtab {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.extrefsymoff {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.nextrefsyms {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.indirectsymoff {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.nindirectsyms {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.extreloff {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.nextrel {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.locreloff {
            my_size += ::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.nlocrel {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ilocalsym {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.nlocalsym {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.iextdefsym {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.nextdefsym {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.iundefsym {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.nundefsym {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.tocoff {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.ntoc {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.modtaboff {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.nmodtab {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.extrefsymoff {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.nextrefsyms {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.indirectsymoff {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.nindirectsyms {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.extreloff {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.nextrel {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.locreloff {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.nlocrel {
            os.write_uint32(20, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Dysymtab {
        Dysymtab::new()
    }

    fn clear(&mut self) {
        self.ilocalsym = ::std::option::Option::None;
        self.nlocalsym = ::std::option::Option::None;
        self.iextdefsym = ::std::option::Option::None;
        self.nextdefsym = ::std::option::Option::None;
        self.iundefsym = ::std::option::Option::None;
        self.nundefsym = ::std::option::Option::None;
        self.tocoff = ::std::option::Option::None;
        self.ntoc = ::std::option::Option::None;
        self.modtaboff = ::std::option::Option::None;
        self.nmodtab = ::std::option::Option::None;
        self.extrefsymoff = ::std::option::Option::None;
        self.nextrefsyms = ::std::option::Option::None;
        self.indirectsymoff = ::std::option::Option::None;
        self.nindirectsyms = ::std::option::Option::None;
        self.extreloff = ::std::option::Option::None;
        self.nextrel = ::std::option::Option::None;
        self.locreloff = ::std::option::Option::None;
        self.nlocrel = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Dysymtab {
        static instance: Dysymtab = Dysymtab {
            ilocalsym: ::std::option::Option::None,
            nlocalsym: ::std::option::Option::None,
            iextdefsym: ::std::option::Option::None,
            nextdefsym: ::std::option::Option::None,
            iundefsym: ::std::option::Option::None,
            nundefsym: ::std::option::Option::None,
            tocoff: ::std::option::Option::None,
            ntoc: ::std::option::Option::None,
            modtaboff: ::std::option::Option::None,
            nmodtab: ::std::option::Option::None,
            extrefsymoff: ::std::option::Option::None,
            nextrefsyms: ::std::option::Option::None,
            indirectsymoff: ::std::option::Option::None,
            nindirectsyms: ::std::option::Option::None,
            extreloff: ::std::option::Option::None,
            nextrel: ::std::option::Option::None,
            locreloff: ::std::option::Option::None,
            nlocrel: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Dysymtab {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Dysymtab").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Dysymtab {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Dysymtab {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:macho.Section)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Section {
    // message fields
    // @@protoc_insertion_point(field:macho.Section.segname)
    pub segname: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:macho.Section.sectname)
    pub sectname: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:macho.Section.addr)
    pub addr: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:macho.Section.size)
    pub size: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:macho.Section.offset)
    pub offset: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Section.align)
    pub align: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Section.reloff)
    pub reloff: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Section.nreloc)
    pub nreloc: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Section.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Section.reserved1)
    pub reserved1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Section.reserved2)
    pub reserved2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Section.reserved3)
    pub reserved3: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:macho.Section.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Section {
    fn default() -> &'a Section {
        <Section as ::protobuf::Message>::default_instance()
    }
}

impl Section {
    pub fn new() -> Section {
        ::std::default::Default::default()
    }

    // optional bytes segname = 1;

    pub fn segname(&self) -> &[u8] {
        match self.segname.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_segname(&mut self) {
        self.segname = ::std::option::Option::None;
    }

    pub fn has_segname(&self) -> bool {
        self.segname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_segname(&mut self, v: ::std::vec::Vec<u8>) {
        self.segname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_segname(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.segname.is_none() {
            self.segname = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.segname.as_mut().unwrap()
    }

    // Take field
    pub fn take_segname(&mut self) -> ::std::vec::Vec<u8> {
        self.segname.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes sectname = 2;

    pub fn sectname(&self) -> &[u8] {
        match self.sectname.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sectname(&mut self) {
        self.sectname = ::std::option::Option::None;
    }

    pub fn has_sectname(&self) -> bool {
        self.sectname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sectname(&mut self, v: ::std::vec::Vec<u8>) {
        self.sectname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sectname(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sectname.is_none() {
            self.sectname = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.sectname.as_mut().unwrap()
    }

    // Take field
    pub fn take_sectname(&mut self) -> ::std::vec::Vec<u8> {
        self.sectname.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 addr = 3;

    pub fn addr(&self) -> u64 {
        self.addr.unwrap_or(0)
    }

    pub fn clear_addr(&mut self) {
        self.addr = ::std::option::Option::None;
    }

    pub fn has_addr(&self) -> bool {
        self.addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_addr(&mut self, v: u64) {
        self.addr = ::std::option::Option::Some(v);
    }

    // optional uint64 size = 4;

    pub fn size(&self) -> u64 {
        self.size.unwrap_or(0)
    }

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u64) {
        self.size = ::std::option::Option::Some(v);
    }

    // optional uint32 offset = 5;

    pub fn offset(&self) -> u32 {
        self.offset.unwrap_or(0)
    }

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u32) {
        self.offset = ::std::option::Option::Some(v);
    }

    // optional uint32 align = 6;

    pub fn align(&self) -> u32 {
        self.align.unwrap_or(0)
    }

    pub fn clear_align(&mut self) {
        self.align = ::std::option::Option::None;
    }

    pub fn has_align(&self) -> bool {
        self.align.is_some()
    }

    // Param is passed by value, moved
    pub fn set_align(&mut self, v: u32) {
        self.align = ::std::option::Option::Some(v);
    }

    // optional uint32 reloff = 7;

    pub fn reloff(&self) -> u32 {
        self.reloff.unwrap_or(0)
    }

    pub fn clear_reloff(&mut self) {
        self.reloff = ::std::option::Option::None;
    }

    pub fn has_reloff(&self) -> bool {
        self.reloff.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reloff(&mut self, v: u32) {
        self.reloff = ::std::option::Option::Some(v);
    }

    // optional uint32 nreloc = 8;

    pub fn nreloc(&self) -> u32 {
        self.nreloc.unwrap_or(0)
    }

    pub fn clear_nreloc(&mut self) {
        self.nreloc = ::std::option::Option::None;
    }

    pub fn has_nreloc(&self) -> bool {
        self.nreloc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nreloc(&mut self, v: u32) {
        self.nreloc = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 9;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 reserved1 = 10;

    pub fn reserved1(&self) -> u32 {
        self.reserved1.unwrap_or(0)
    }

    pub fn clear_reserved1(&mut self) {
        self.reserved1 = ::std::option::Option::None;
    }

    pub fn has_reserved1(&self) -> bool {
        self.reserved1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reserved1(&mut self, v: u32) {
        self.reserved1 = ::std::option::Option::Some(v);
    }

    // optional uint32 reserved2 = 11;

    pub fn reserved2(&self) -> u32 {
        self.reserved2.unwrap_or(0)
    }

    pub fn clear_reserved2(&mut self) {
        self.reserved2 = ::std::option::Option::None;
    }

    pub fn has_reserved2(&self) -> bool {
        self.reserved2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reserved2(&mut self, v: u32) {
        self.reserved2 = ::std::option::Option::Some(v);
    }

    // optional uint32 reserved3 = 12;

    pub fn reserved3(&self) -> u32 {
        self.reserved3.unwrap_or(0)
    }

    pub fn clear_reserved3(&mut self) {
        self.reserved3 = ::std::option::Option::None;
    }

    pub fn has_reserved3(&self) -> bool {
        self.reserved3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reserved3(&mut self, v: u32) {
        self.reserved3 = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "segname",
            |m: &Section| { &m.segname },
            |m: &mut Section| { &mut m.segname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sectname",
            |m: &Section| { &m.sectname },
            |m: &mut Section| { &mut m.sectname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "addr",
            |m: &Section| { &m.addr },
            |m: &mut Section| { &mut m.addr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "size",
            |m: &Section| { &m.size },
            |m: &mut Section| { &mut m.size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "offset",
            |m: &Section| { &m.offset },
            |m: &mut Section| { &mut m.offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "align",
            |m: &Section| { &m.align },
            |m: &mut Section| { &mut m.align },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reloff",
            |m: &Section| { &m.reloff },
            |m: &mut Section| { &mut m.reloff },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nreloc",
            |m: &Section| { &m.nreloc },
            |m: &mut Section| { &mut m.nreloc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &Section| { &m.flags },
            |m: &mut Section| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reserved1",
            |m: &Section| { &m.reserved1 },
            |m: &mut Section| { &mut m.reserved1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reserved2",
            |m: &Section| { &m.reserved2 },
            |m: &mut Section| { &mut m.reserved2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reserved3",
            |m: &Section| { &m.reserved3 },
            |m: &mut Section| { &mut m.reserved3 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Section>(
            "Section",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Section {
    const NAME: &'static str = "Section";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.segname = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.sectname = ::std::option::Option::Some(is.read_bytes()?);
                },
                24 => {
                    self.addr = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.size = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.offset = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.align = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.reloff = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.nreloc = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.reserved1 = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.reserved2 = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.reserved3 = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.segname.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.sectname.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.addr {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.align {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.reloff {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.nreloc {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.reserved1 {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.reserved2 {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.reserved3 {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.segname.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.sectname.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.addr {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.size {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.align {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.reloff {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.nreloc {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.reserved1 {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.reserved2 {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.reserved3 {
            os.write_uint32(12, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Section {
        Section::new()
    }

    fn clear(&mut self) {
        self.segname = ::std::option::Option::None;
        self.sectname = ::std::option::Option::None;
        self.addr = ::std::option::Option::None;
        self.size = ::std::option::Option::None;
        self.offset = ::std::option::Option::None;
        self.align = ::std::option::Option::None;
        self.reloff = ::std::option::Option::None;
        self.nreloc = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.reserved1 = ::std::option::Option::None;
        self.reserved2 = ::std::option::Option::None;
        self.reserved3 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Section {
        static instance: Section = Section {
            segname: ::std::option::Option::None,
            sectname: ::std::option::Option::None,
            addr: ::std::option::Option::None,
            size: ::std::option::Option::None,
            offset: ::std::option::Option::None,
            align: ::std::option::Option::None,
            reloff: ::std::option::Option::None,
            nreloc: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            reserved1: ::std::option::Option::None,
            reserved2: ::std::option::Option::None,
            reserved3: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Section {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Section").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Section {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Section {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:macho.Segment)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Segment {
    // message fields
    // @@protoc_insertion_point(field:macho.Segment.segname)
    pub segname: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:macho.Segment.vmaddr)
    pub vmaddr: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:macho.Segment.vmsize)
    pub vmsize: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:macho.Segment.fileoff)
    pub fileoff: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:macho.Segment.filesize)
    pub filesize: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:macho.Segment.maxprot)
    pub maxprot: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Segment.initprot)
    pub initprot: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Segment.nsects)
    pub nsects: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Segment.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Segment.sections)
    pub sections: ::std::vec::Vec<Section>,
    // special fields
    // @@protoc_insertion_point(special_field:macho.Segment.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Segment {
    fn default() -> &'a Segment {
        <Segment as ::protobuf::Message>::default_instance()
    }
}

impl Segment {
    pub fn new() -> Segment {
        ::std::default::Default::default()
    }

    // optional bytes segname = 3;

    pub fn segname(&self) -> &[u8] {
        match self.segname.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_segname(&mut self) {
        self.segname = ::std::option::Option::None;
    }

    pub fn has_segname(&self) -> bool {
        self.segname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_segname(&mut self, v: ::std::vec::Vec<u8>) {
        self.segname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_segname(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.segname.is_none() {
            self.segname = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.segname.as_mut().unwrap()
    }

    // Take field
    pub fn take_segname(&mut self) -> ::std::vec::Vec<u8> {
        self.segname.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 vmaddr = 4;

    pub fn vmaddr(&self) -> u64 {
        self.vmaddr.unwrap_or(0)
    }

    pub fn clear_vmaddr(&mut self) {
        self.vmaddr = ::std::option::Option::None;
    }

    pub fn has_vmaddr(&self) -> bool {
        self.vmaddr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vmaddr(&mut self, v: u64) {
        self.vmaddr = ::std::option::Option::Some(v);
    }

    // optional uint64 vmsize = 5;

    pub fn vmsize(&self) -> u64 {
        self.vmsize.unwrap_or(0)
    }

    pub fn clear_vmsize(&mut self) {
        self.vmsize = ::std::option::Option::None;
    }

    pub fn has_vmsize(&self) -> bool {
        self.vmsize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vmsize(&mut self, v: u64) {
        self.vmsize = ::std::option::Option::Some(v);
    }

    // optional uint64 fileoff = 6;

    pub fn fileoff(&self) -> u64 {
        self.fileoff.unwrap_or(0)
    }

    pub fn clear_fileoff(&mut self) {
        self.fileoff = ::std::option::Option::None;
    }

    pub fn has_fileoff(&self) -> bool {
        self.fileoff.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileoff(&mut self, v: u64) {
        self.fileoff = ::std::option::Option::Some(v);
    }

    // optional uint64 filesize = 7;

    pub fn filesize(&self) -> u64 {
        self.filesize.unwrap_or(0)
    }

    pub fn clear_filesize(&mut self) {
        self.filesize = ::std::option::Option::None;
    }

    pub fn has_filesize(&self) -> bool {
        self.filesize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesize(&mut self, v: u64) {
        self.filesize = ::std::option::Option::Some(v);
    }

    // optional uint32 maxprot = 8;

    pub fn maxprot(&self) -> u32 {
        self.maxprot.unwrap_or(0)
    }

    pub fn clear_maxprot(&mut self) {
        self.maxprot = ::std::option::Option::None;
    }

    pub fn has_maxprot(&self) -> bool {
        self.maxprot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxprot(&mut self, v: u32) {
        self.maxprot = ::std::option::Option::Some(v);
    }

    // optional uint32 initprot = 9;

    pub fn initprot(&self) -> u32 {
        self.initprot.unwrap_or(0)
    }

    pub fn clear_initprot(&mut self) {
        self.initprot = ::std::option::Option::None;
    }

    pub fn has_initprot(&self) -> bool {
        self.initprot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initprot(&mut self, v: u32) {
        self.initprot = ::std::option::Option::Some(v);
    }

    // optional uint32 nsects = 10;

    pub fn nsects(&self) -> u32 {
        self.nsects.unwrap_or(0)
    }

    pub fn clear_nsects(&mut self) {
        self.nsects = ::std::option::Option::None;
    }

    pub fn has_nsects(&self) -> bool {
        self.nsects.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nsects(&mut self, v: u32) {
        self.nsects = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 11;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "segname",
            |m: &Segment| { &m.segname },
            |m: &mut Segment| { &mut m.segname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vmaddr",
            |m: &Segment| { &m.vmaddr },
            |m: &mut Segment| { &mut m.vmaddr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vmsize",
            |m: &Segment| { &m.vmsize },
            |m: &mut Segment| { &mut m.vmsize },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileoff",
            |m: &Segment| { &m.fileoff },
            |m: &mut Segment| { &mut m.fileoff },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "filesize",
            |m: &Segment| { &m.filesize },
            |m: &mut Segment| { &mut m.filesize },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "maxprot",
            |m: &Segment| { &m.maxprot },
            |m: &mut Segment| { &mut m.maxprot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "initprot",
            |m: &Segment| { &m.initprot },
            |m: &mut Segment| { &mut m.initprot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nsects",
            |m: &Segment| { &m.nsects },
            |m: &mut Segment| { &mut m.nsects },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &Segment| { &m.flags },
            |m: &mut Segment| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sections",
            |m: &Segment| { &m.sections },
            |m: &mut Segment| { &mut m.sections },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Segment>(
            "Segment",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Segment {
    const NAME: &'static str = "Segment";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                26 => {
                    self.segname = ::std::option::Option::Some(is.read_bytes()?);
                },
                32 => {
                    self.vmaddr = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.vmsize = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.fileoff = ::std::option::Option::Some(is.read_uint64()?);
                },
                56 => {
                    self.filesize = ::std::option::Option::Some(is.read_uint64()?);
                },
                64 => {
                    self.maxprot = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.initprot = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.nsects = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                98 => {
                    self.sections.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.segname.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.vmaddr {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.vmsize {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.fileoff {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.filesize {
            my_size += ::protobuf::rt::uint64_size(7, v);
        }
        if let Some(v) = self.maxprot {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.initprot {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.nsects {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        for value in &self.sections {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.segname.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.vmaddr {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.vmsize {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.fileoff {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.filesize {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.maxprot {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.initprot {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.nsects {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(11, v)?;
        }
        for v in &self.sections {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Segment {
        Segment::new()
    }

    fn clear(&mut self) {
        self.segname = ::std::option::Option::None;
        self.vmaddr = ::std::option::Option::None;
        self.vmsize = ::std::option::Option::None;
        self.fileoff = ::std::option::Option::None;
        self.filesize = ::std::option::Option::None;
        self.maxprot = ::std::option::Option::None;
        self.initprot = ::std::option::Option::None;
        self.nsects = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.sections.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Segment {
        static instance: Segment = Segment {
            segname: ::std::option::Option::None,
            vmaddr: ::std::option::Option::None,
            vmsize: ::std::option::Option::None,
            fileoff: ::std::option::Option::None,
            filesize: ::std::option::Option::None,
            maxprot: ::std::option::Option::None,
            initprot: ::std::option::Option::None,
            nsects: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            sections: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Segment {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Segment").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Segment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Segment {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:macho.FatArch)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FatArch {
    // message fields
    // @@protoc_insertion_point(field:macho.FatArch.cputype)
    pub cputype: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.FatArch.cpusubtype)
    pub cpusubtype: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.FatArch.offset)
    pub offset: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:macho.FatArch.size)
    pub size: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:macho.FatArch.align)
    pub align: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.FatArch.reserved)
    pub reserved: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:macho.FatArch.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FatArch {
    fn default() -> &'a FatArch {
        <FatArch as ::protobuf::Message>::default_instance()
    }
}

impl FatArch {
    pub fn new() -> FatArch {
        ::std::default::Default::default()
    }

    // optional uint32 cputype = 1;

    pub fn cputype(&self) -> u32 {
        self.cputype.unwrap_or(0)
    }

    pub fn clear_cputype(&mut self) {
        self.cputype = ::std::option::Option::None;
    }

    pub fn has_cputype(&self) -> bool {
        self.cputype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cputype(&mut self, v: u32) {
        self.cputype = ::std::option::Option::Some(v);
    }

    // optional uint32 cpusubtype = 2;

    pub fn cpusubtype(&self) -> u32 {
        self.cpusubtype.unwrap_or(0)
    }

    pub fn clear_cpusubtype(&mut self) {
        self.cpusubtype = ::std::option::Option::None;
    }

    pub fn has_cpusubtype(&self) -> bool {
        self.cpusubtype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpusubtype(&mut self, v: u32) {
        self.cpusubtype = ::std::option::Option::Some(v);
    }

    // optional uint64 offset = 3;

    pub fn offset(&self) -> u64 {
        self.offset.unwrap_or(0)
    }

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u64) {
        self.offset = ::std::option::Option::Some(v);
    }

    // optional uint64 size = 4;

    pub fn size(&self) -> u64 {
        self.size.unwrap_or(0)
    }

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u64) {
        self.size = ::std::option::Option::Some(v);
    }

    // optional uint32 align = 5;

    pub fn align(&self) -> u32 {
        self.align.unwrap_or(0)
    }

    pub fn clear_align(&mut self) {
        self.align = ::std::option::Option::None;
    }

    pub fn has_align(&self) -> bool {
        self.align.is_some()
    }

    // Param is passed by value, moved
    pub fn set_align(&mut self, v: u32) {
        self.align = ::std::option::Option::Some(v);
    }

    // optional uint32 reserved = 6;

    pub fn reserved(&self) -> u32 {
        self.reserved.unwrap_or(0)
    }

    pub fn clear_reserved(&mut self) {
        self.reserved = ::std::option::Option::None;
    }

    pub fn has_reserved(&self) -> bool {
        self.reserved.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reserved(&mut self, v: u32) {
        self.reserved = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cputype",
            |m: &FatArch| { &m.cputype },
            |m: &mut FatArch| { &mut m.cputype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cpusubtype",
            |m: &FatArch| { &m.cpusubtype },
            |m: &mut FatArch| { &mut m.cpusubtype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "offset",
            |m: &FatArch| { &m.offset },
            |m: &mut FatArch| { &mut m.offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "size",
            |m: &FatArch| { &m.size },
            |m: &mut FatArch| { &mut m.size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "align",
            |m: &FatArch| { &m.align },
            |m: &mut FatArch| { &mut m.align },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reserved",
            |m: &FatArch| { &m.reserved },
            |m: &mut FatArch| { &mut m.reserved },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FatArch>(
            "FatArch",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FatArch {
    const NAME: &'static str = "FatArch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cputype = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.cpusubtype = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.offset = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.size = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.align = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.reserved = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cputype {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.cpusubtype {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.align {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.reserved {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cputype {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.cpusubtype {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.size {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.align {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.reserved {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FatArch {
        FatArch::new()
    }

    fn clear(&mut self) {
        self.cputype = ::std::option::Option::None;
        self.cpusubtype = ::std::option::Option::None;
        self.offset = ::std::option::Option::None;
        self.size = ::std::option::Option::None;
        self.align = ::std::option::Option::None;
        self.reserved = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FatArch {
        static instance: FatArch = FatArch {
            cputype: ::std::option::Option::None,
            cpusubtype: ::std::option::Option::None,
            offset: ::std::option::Option::None,
            size: ::std::option::Option::None,
            align: ::std::option::Option::None,
            reserved: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FatArch {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FatArch").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FatArch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FatArch {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:macho.File)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct File {
    // message fields
    // @@protoc_insertion_point(field:macho.File.magic)
    pub magic: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.File.cputype)
    pub cputype: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.File.cpusubtype)
    pub cpusubtype: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.File.filetype)
    pub filetype: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.File.ncmds)
    pub ncmds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.File.sizeofcmds)
    pub sizeofcmds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.File.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.File.reserved)
    pub reserved: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.File.number_of_segments)
    pub number_of_segments: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:macho.File.dynamic_linker)
    pub dynamic_linker: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:macho.File.entry_point)
    pub entry_point: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:macho.File.stack_size)
    pub stack_size: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:macho.File.source_version)
    pub source_version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:macho.File.segments)
    pub segments: ::std::vec::Vec<Segment>,
    // @@protoc_insertion_point(field:macho.File.dylibs)
    pub dylibs: ::std::vec::Vec<Dylib>,
    // @@protoc_insertion_point(field:macho.File.rpaths)
    pub rpaths: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:macho.File.entitlements)
    pub entitlements: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:macho.File.symtab)
    pub symtab: ::protobuf::MessageField<Symtab>,
    // @@protoc_insertion_point(field:macho.File.dysymtab)
    pub dysymtab: ::protobuf::MessageField<Dysymtab>,
    // @@protoc_insertion_point(field:macho.File.dyld_info)
    pub dyld_info: ::protobuf::MessageField<DyldInfo>,
    // @@protoc_insertion_point(field:macho.File.code_signature_data)
    pub code_signature_data: ::protobuf::MessageField<LinkedItData>,
    // @@protoc_insertion_point(field:macho.File.certificates)
    pub certificates: ::std::vec::Vec<Certificate>,
    // @@protoc_insertion_point(field:macho.File.uuid)
    pub uuid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:macho.File.build_version)
    pub build_version: ::protobuf::MessageField<BuildVersion>,
    // @@protoc_insertion_point(field:macho.File.min_version)
    pub min_version: ::protobuf::MessageField<MinVersion>,
    // @@protoc_insertion_point(field:macho.File.exports)
    pub exports: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:macho.File.imports)
    pub imports: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:macho.File.linker_options)
    pub linker_options: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:macho.File.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a File {
    fn default() -> &'a File {
        <File as ::protobuf::Message>::default_instance()
    }
}

impl File {
    pub fn new() -> File {
        ::std::default::Default::default()
    }

    // optional uint32 magic = 1;

    pub fn magic(&self) -> u32 {
        self.magic.unwrap_or(0)
    }

    pub fn clear_magic(&mut self) {
        self.magic = ::std::option::Option::None;
    }

    pub fn has_magic(&self) -> bool {
        self.magic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_magic(&mut self, v: u32) {
        self.magic = ::std::option::Option::Some(v);
    }

    // optional uint32 cputype = 2;

    pub fn cputype(&self) -> u32 {
        self.cputype.unwrap_or(0)
    }

    pub fn clear_cputype(&mut self) {
        self.cputype = ::std::option::Option::None;
    }

    pub fn has_cputype(&self) -> bool {
        self.cputype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cputype(&mut self, v: u32) {
        self.cputype = ::std::option::Option::Some(v);
    }

    // optional uint32 cpusubtype = 3;

    pub fn cpusubtype(&self) -> u32 {
        self.cpusubtype.unwrap_or(0)
    }

    pub fn clear_cpusubtype(&mut self) {
        self.cpusubtype = ::std::option::Option::None;
    }

    pub fn has_cpusubtype(&self) -> bool {
        self.cpusubtype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpusubtype(&mut self, v: u32) {
        self.cpusubtype = ::std::option::Option::Some(v);
    }

    // optional uint32 filetype = 4;

    pub fn filetype(&self) -> u32 {
        self.filetype.unwrap_or(0)
    }

    pub fn clear_filetype(&mut self) {
        self.filetype = ::std::option::Option::None;
    }

    pub fn has_filetype(&self) -> bool {
        self.filetype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filetype(&mut self, v: u32) {
        self.filetype = ::std::option::Option::Some(v);
    }

    // optional uint32 ncmds = 5;

    pub fn ncmds(&self) -> u32 {
        self.ncmds.unwrap_or(0)
    }

    pub fn clear_ncmds(&mut self) {
        self.ncmds = ::std::option::Option::None;
    }

    pub fn has_ncmds(&self) -> bool {
        self.ncmds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ncmds(&mut self, v: u32) {
        self.ncmds = ::std::option::Option::Some(v);
    }

    // optional uint32 sizeofcmds = 6;

    pub fn sizeofcmds(&self) -> u32 {
        self.sizeofcmds.unwrap_or(0)
    }

    pub fn clear_sizeofcmds(&mut self) {
        self.sizeofcmds = ::std::option::Option::None;
    }

    pub fn has_sizeofcmds(&self) -> bool {
        self.sizeofcmds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sizeofcmds(&mut self, v: u32) {
        self.sizeofcmds = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 7;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 reserved = 8;

    pub fn reserved(&self) -> u32 {
        self.reserved.unwrap_or(0)
    }

    pub fn clear_reserved(&mut self) {
        self.reserved = ::std::option::Option::None;
    }

    pub fn has_reserved(&self) -> bool {
        self.reserved.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reserved(&mut self, v: u32) {
        self.reserved = ::std::option::Option::Some(v);
    }

    // optional uint64 number_of_segments = 9;

    pub fn number_of_segments(&self) -> u64 {
        self.number_of_segments.unwrap_or(0)
    }

    pub fn clear_number_of_segments(&mut self) {
        self.number_of_segments = ::std::option::Option::None;
    }

    pub fn has_number_of_segments(&self) -> bool {
        self.number_of_segments.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number_of_segments(&mut self, v: u64) {
        self.number_of_segments = ::std::option::Option::Some(v);
    }

    // optional bytes dynamic_linker = 10;

    pub fn dynamic_linker(&self) -> &[u8] {
        match self.dynamic_linker.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_dynamic_linker(&mut self) {
        self.dynamic_linker = ::std::option::Option::None;
    }

    pub fn has_dynamic_linker(&self) -> bool {
        self.dynamic_linker.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dynamic_linker(&mut self, v: ::std::vec::Vec<u8>) {
        self.dynamic_linker = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dynamic_linker(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.dynamic_linker.is_none() {
            self.dynamic_linker = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.dynamic_linker.as_mut().unwrap()
    }

    // Take field
    pub fn take_dynamic_linker(&mut self) -> ::std::vec::Vec<u8> {
        self.dynamic_linker.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 entry_point = 11;

    pub fn entry_point(&self) -> u64 {
        self.entry_point.unwrap_or(0)
    }

    pub fn clear_entry_point(&mut self) {
        self.entry_point = ::std::option::Option::None;
    }

    pub fn has_entry_point(&self) -> bool {
        self.entry_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entry_point(&mut self, v: u64) {
        self.entry_point = ::std::option::Option::Some(v);
    }

    // optional uint64 stack_size = 12;

    pub fn stack_size(&self) -> u64 {
        self.stack_size.unwrap_or(0)
    }

    pub fn clear_stack_size(&mut self) {
        self.stack_size = ::std::option::Option::None;
    }

    pub fn has_stack_size(&self) -> bool {
        self.stack_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stack_size(&mut self, v: u64) {
        self.stack_size = ::std::option::Option::Some(v);
    }

    // optional string source_version = 13;

    pub fn source_version(&self) -> &str {
        match self.source_version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_source_version(&mut self) {
        self.source_version = ::std::option::Option::None;
    }

    pub fn has_source_version(&self) -> bool {
        self.source_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_version(&mut self, v: ::std::string::String) {
        self.source_version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_version(&mut self) -> &mut ::std::string::String {
        if self.source_version.is_none() {
            self.source_version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.source_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_source_version(&mut self) -> ::std::string::String {
        self.source_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string uuid = 23;

    pub fn uuid(&self) -> &str {
        match self.uuid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_uuid(&mut self) {
        self.uuid = ::std::option::Option::None;
    }

    pub fn has_uuid(&self) -> bool {
        self.uuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: ::std::string::String) {
        self.uuid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid(&mut self) -> &mut ::std::string::String {
        if self.uuid.is_none() {
            self.uuid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.uuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uuid(&mut self) -> ::std::string::String {
        self.uuid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(28);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "magic",
            |m: &File| { &m.magic },
            |m: &mut File| { &mut m.magic },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cputype",
            |m: &File| { &m.cputype },
            |m: &mut File| { &mut m.cputype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cpusubtype",
            |m: &File| { &m.cpusubtype },
            |m: &mut File| { &mut m.cpusubtype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "filetype",
            |m: &File| { &m.filetype },
            |m: &mut File| { &mut m.filetype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ncmds",
            |m: &File| { &m.ncmds },
            |m: &mut File| { &mut m.ncmds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sizeofcmds",
            |m: &File| { &m.sizeofcmds },
            |m: &mut File| { &mut m.sizeofcmds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &File| { &m.flags },
            |m: &mut File| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reserved",
            |m: &File| { &m.reserved },
            |m: &mut File| { &mut m.reserved },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "number_of_segments",
            |m: &File| { &m.number_of_segments },
            |m: &mut File| { &mut m.number_of_segments },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dynamic_linker",
            |m: &File| { &m.dynamic_linker },
            |m: &mut File| { &mut m.dynamic_linker },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entry_point",
            |m: &File| { &m.entry_point },
            |m: &mut File| { &mut m.entry_point },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stack_size",
            |m: &File| { &m.stack_size },
            |m: &mut File| { &mut m.stack_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_version",
            |m: &File| { &m.source_version },
            |m: &mut File| { &mut m.source_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "segments",
            |m: &File| { &m.segments },
            |m: &mut File| { &mut m.segments },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dylibs",
            |m: &File| { &m.dylibs },
            |m: &mut File| { &mut m.dylibs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rpaths",
            |m: &File| { &m.rpaths },
            |m: &mut File| { &mut m.rpaths },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entitlements",
            |m: &File| { &m.entitlements },
            |m: &mut File| { &mut m.entitlements },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Symtab>(
            "symtab",
            |m: &File| { &m.symtab },
            |m: &mut File| { &mut m.symtab },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Dysymtab>(
            "dysymtab",
            |m: &File| { &m.dysymtab },
            |m: &mut File| { &mut m.dysymtab },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DyldInfo>(
            "dyld_info",
            |m: &File| { &m.dyld_info },
            |m: &mut File| { &mut m.dyld_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LinkedItData>(
            "code_signature_data",
            |m: &File| { &m.code_signature_data },
            |m: &mut File| { &mut m.code_signature_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "certificates",
            |m: &File| { &m.certificates },
            |m: &mut File| { &mut m.certificates },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uuid",
            |m: &File| { &m.uuid },
            |m: &mut File| { &mut m.uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BuildVersion>(
            "build_version",
            |m: &File| { &m.build_version },
            |m: &mut File| { &mut m.build_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MinVersion>(
            "min_version",
            |m: &File| { &m.min_version },
            |m: &mut File| { &mut m.min_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "exports",
            |m: &File| { &m.exports },
            |m: &mut File| { &mut m.exports },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "imports",
            |m: &File| { &m.imports },
            |m: &mut File| { &mut m.imports },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "linker_options",
            |m: &File| { &m.linker_options },
            |m: &mut File| { &mut m.linker_options },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<File>(
            "File",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for File {
    const NAME: &'static str = "File";

    fn is_initialized(&self) -> bool {
        for v in &self.segments {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dylibs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.symtab {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dysymtab {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dyld_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.code_signature_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.certificates {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.build_version {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.min_version {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.magic = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.cputype = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.cpusubtype = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.filetype = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.ncmds = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.sizeofcmds = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.reserved = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.number_of_segments = ::std::option::Option::Some(is.read_uint64()?);
                },
                82 => {
                    self.dynamic_linker = ::std::option::Option::Some(is.read_bytes()?);
                },
                88 => {
                    self.entry_point = ::std::option::Option::Some(is.read_uint64()?);
                },
                96 => {
                    self.stack_size = ::std::option::Option::Some(is.read_uint64()?);
                },
                106 => {
                    self.source_version = ::std::option::Option::Some(is.read_string()?);
                },
                114 => {
                    self.segments.push(is.read_message()?);
                },
                122 => {
                    self.dylibs.push(is.read_message()?);
                },
                130 => {
                    self.rpaths.push(is.read_bytes()?);
                },
                138 => {
                    self.entitlements.push(is.read_string()?);
                },
                146 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.symtab)?;
                },
                154 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dysymtab)?;
                },
                162 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dyld_info)?;
                },
                170 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.code_signature_data)?;
                },
                178 => {
                    self.certificates.push(is.read_message()?);
                },
                186 => {
                    self.uuid = ::std::option::Option::Some(is.read_string()?);
                },
                194 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.build_version)?;
                },
                202 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.min_version)?;
                },
                210 => {
                    self.exports.push(is.read_string()?);
                },
                218 => {
                    self.imports.push(is.read_string()?);
                },
                226 => {
                    self.linker_options.push(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.magic {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.cputype {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.cpusubtype {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.filetype {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.ncmds {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.sizeofcmds {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.reserved {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.number_of_segments {
            my_size += ::protobuf::rt::uint64_size(9, v);
        }
        if let Some(v) = self.dynamic_linker.as_ref() {
            my_size += ::protobuf::rt::bytes_size(10, &v);
        }
        if let Some(v) = self.entry_point {
            my_size += ::protobuf::rt::uint64_size(11, v);
        }
        if let Some(v) = self.stack_size {
            my_size += ::protobuf::rt::uint64_size(12, v);
        }
        if let Some(v) = self.source_version.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        for value in &self.segments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.dylibs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.rpaths {
            my_size += ::protobuf::rt::bytes_size(16, &value);
        };
        for value in &self.entitlements {
            my_size += ::protobuf::rt::string_size(17, &value);
        };
        if let Some(v) = self.symtab.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dysymtab.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dyld_info.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.code_signature_data.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.certificates {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.uuid.as_ref() {
            my_size += ::protobuf::rt::string_size(23, &v);
        }
        if let Some(v) = self.build_version.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.min_version.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.exports {
            my_size += ::protobuf::rt::string_size(26, &value);
        };
        for value in &self.imports {
            my_size += ::protobuf::rt::string_size(27, &value);
        };
        for value in &self.linker_options {
            my_size += ::protobuf::rt::bytes_size(28, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.magic {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.cputype {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.cpusubtype {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.filetype {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.ncmds {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.sizeofcmds {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.reserved {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.number_of_segments {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.dynamic_linker.as_ref() {
            os.write_bytes(10, v)?;
        }
        if let Some(v) = self.entry_point {
            os.write_uint64(11, v)?;
        }
        if let Some(v) = self.stack_size {
            os.write_uint64(12, v)?;
        }
        if let Some(v) = self.source_version.as_ref() {
            os.write_string(13, v)?;
        }
        for v in &self.segments {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        };
        for v in &self.dylibs {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        };
        for v in &self.rpaths {
            os.write_bytes(16, &v)?;
        };
        for v in &self.entitlements {
            os.write_string(17, &v)?;
        };
        if let Some(v) = self.symtab.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        if let Some(v) = self.dysymtab.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        }
        if let Some(v) = self.dyld_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        }
        if let Some(v) = self.code_signature_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        }
        for v in &self.certificates {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        };
        if let Some(v) = self.uuid.as_ref() {
            os.write_string(23, v)?;
        }
        if let Some(v) = self.build_version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        if let Some(v) = self.min_version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        }
        for v in &self.exports {
            os.write_string(26, &v)?;
        };
        for v in &self.imports {
            os.write_string(27, &v)?;
        };
        for v in &self.linker_options {
            os.write_bytes(28, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> File {
        File::new()
    }

    fn clear(&mut self) {
        self.magic = ::std::option::Option::None;
        self.cputype = ::std::option::Option::None;
        self.cpusubtype = ::std::option::Option::None;
        self.filetype = ::std::option::Option::None;
        self.ncmds = ::std::option::Option::None;
        self.sizeofcmds = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.reserved = ::std::option::Option::None;
        self.number_of_segments = ::std::option::Option::None;
        self.dynamic_linker = ::std::option::Option::None;
        self.entry_point = ::std::option::Option::None;
        self.stack_size = ::std::option::Option::None;
        self.source_version = ::std::option::Option::None;
        self.segments.clear();
        self.dylibs.clear();
        self.rpaths.clear();
        self.entitlements.clear();
        self.symtab.clear();
        self.dysymtab.clear();
        self.dyld_info.clear();
        self.code_signature_data.clear();
        self.certificates.clear();
        self.uuid = ::std::option::Option::None;
        self.build_version.clear();
        self.min_version.clear();
        self.exports.clear();
        self.imports.clear();
        self.linker_options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static File {
        static instance: File = File {
            magic: ::std::option::Option::None,
            cputype: ::std::option::Option::None,
            cpusubtype: ::std::option::Option::None,
            filetype: ::std::option::Option::None,
            ncmds: ::std::option::Option::None,
            sizeofcmds: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            reserved: ::std::option::Option::None,
            number_of_segments: ::std::option::Option::None,
            dynamic_linker: ::std::option::Option::None,
            entry_point: ::std::option::Option::None,
            stack_size: ::std::option::Option::None,
            source_version: ::std::option::Option::None,
            segments: ::std::vec::Vec::new(),
            dylibs: ::std::vec::Vec::new(),
            rpaths: ::std::vec::Vec::new(),
            entitlements: ::std::vec::Vec::new(),
            symtab: ::protobuf::MessageField::none(),
            dysymtab: ::protobuf::MessageField::none(),
            dyld_info: ::protobuf::MessageField::none(),
            code_signature_data: ::protobuf::MessageField::none(),
            certificates: ::std::vec::Vec::new(),
            uuid: ::std::option::Option::None,
            build_version: ::protobuf::MessageField::none(),
            min_version: ::protobuf::MessageField::none(),
            exports: ::std::vec::Vec::new(),
            imports: ::std::vec::Vec::new(),
            linker_options: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for File {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("File").unwrap()).clone()
    }
}

impl ::std::fmt::Display for File {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for File {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:macho.Macho)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Macho {
    // message fields
    // @@protoc_insertion_point(field:macho.Macho.magic)
    pub magic: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Macho.cputype)
    pub cputype: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Macho.cpusubtype)
    pub cpusubtype: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Macho.filetype)
    pub filetype: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Macho.ncmds)
    pub ncmds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Macho.sizeofcmds)
    pub sizeofcmds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Macho.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Macho.reserved)
    pub reserved: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Macho.number_of_segments)
    pub number_of_segments: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:macho.Macho.dynamic_linker)
    pub dynamic_linker: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:macho.Macho.entry_point)
    pub entry_point: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:macho.Macho.stack_size)
    pub stack_size: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:macho.Macho.source_version)
    pub source_version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:macho.Macho.symtab)
    pub symtab: ::protobuf::MessageField<Symtab>,
    // @@protoc_insertion_point(field:macho.Macho.dysymtab)
    pub dysymtab: ::protobuf::MessageField<Dysymtab>,
    // @@protoc_insertion_point(field:macho.Macho.code_signature_data)
    pub code_signature_data: ::protobuf::MessageField<LinkedItData>,
    // @@protoc_insertion_point(field:macho.Macho.segments)
    pub segments: ::std::vec::Vec<Segment>,
    // @@protoc_insertion_point(field:macho.Macho.dylibs)
    pub dylibs: ::std::vec::Vec<Dylib>,
    // @@protoc_insertion_point(field:macho.Macho.dyld_info)
    pub dyld_info: ::protobuf::MessageField<DyldInfo>,
    // @@protoc_insertion_point(field:macho.Macho.rpaths)
    pub rpaths: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:macho.Macho.entitlements)
    pub entitlements: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:macho.Macho.certificates)
    pub certificates: ::std::vec::Vec<Certificate>,
    // @@protoc_insertion_point(field:macho.Macho.uuid)
    pub uuid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:macho.Macho.build_version)
    pub build_version: ::protobuf::MessageField<BuildVersion>,
    // @@protoc_insertion_point(field:macho.Macho.min_version)
    pub min_version: ::protobuf::MessageField<MinVersion>,
    // @@protoc_insertion_point(field:macho.Macho.exports)
    pub exports: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:macho.Macho.imports)
    pub imports: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:macho.Macho.linker_options)
    pub linker_options: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:macho.Macho.fat_magic)
    pub fat_magic: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Macho.nfat_arch)
    pub nfat_arch: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:macho.Macho.fat_arch)
    pub fat_arch: ::std::vec::Vec<FatArch>,
    // @@protoc_insertion_point(field:macho.Macho.file)
    pub file: ::std::vec::Vec<File>,
    // special fields
    // @@protoc_insertion_point(special_field:macho.Macho.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Macho {
    fn default() -> &'a Macho {
        <Macho as ::protobuf::Message>::default_instance()
    }
}

impl Macho {
    pub fn new() -> Macho {
        ::std::default::Default::default()
    }

    // optional uint32 magic = 1;

    pub fn magic(&self) -> u32 {
        self.magic.unwrap_or(0)
    }

    pub fn clear_magic(&mut self) {
        self.magic = ::std::option::Option::None;
    }

    pub fn has_magic(&self) -> bool {
        self.magic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_magic(&mut self, v: u32) {
        self.magic = ::std::option::Option::Some(v);
    }

    // optional uint32 cputype = 2;

    pub fn cputype(&self) -> u32 {
        self.cputype.unwrap_or(0)
    }

    pub fn clear_cputype(&mut self) {
        self.cputype = ::std::option::Option::None;
    }

    pub fn has_cputype(&self) -> bool {
        self.cputype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cputype(&mut self, v: u32) {
        self.cputype = ::std::option::Option::Some(v);
    }

    // optional uint32 cpusubtype = 3;

    pub fn cpusubtype(&self) -> u32 {
        self.cpusubtype.unwrap_or(0)
    }

    pub fn clear_cpusubtype(&mut self) {
        self.cpusubtype = ::std::option::Option::None;
    }

    pub fn has_cpusubtype(&self) -> bool {
        self.cpusubtype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpusubtype(&mut self, v: u32) {
        self.cpusubtype = ::std::option::Option::Some(v);
    }

    // optional uint32 filetype = 4;

    pub fn filetype(&self) -> u32 {
        self.filetype.unwrap_or(0)
    }

    pub fn clear_filetype(&mut self) {
        self.filetype = ::std::option::Option::None;
    }

    pub fn has_filetype(&self) -> bool {
        self.filetype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filetype(&mut self, v: u32) {
        self.filetype = ::std::option::Option::Some(v);
    }

    // optional uint32 ncmds = 5;

    pub fn ncmds(&self) -> u32 {
        self.ncmds.unwrap_or(0)
    }

    pub fn clear_ncmds(&mut self) {
        self.ncmds = ::std::option::Option::None;
    }

    pub fn has_ncmds(&self) -> bool {
        self.ncmds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ncmds(&mut self, v: u32) {
        self.ncmds = ::std::option::Option::Some(v);
    }

    // optional uint32 sizeofcmds = 6;

    pub fn sizeofcmds(&self) -> u32 {
        self.sizeofcmds.unwrap_or(0)
    }

    pub fn clear_sizeofcmds(&mut self) {
        self.sizeofcmds = ::std::option::Option::None;
    }

    pub fn has_sizeofcmds(&self) -> bool {
        self.sizeofcmds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sizeofcmds(&mut self, v: u32) {
        self.sizeofcmds = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 7;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 reserved = 8;

    pub fn reserved(&self) -> u32 {
        self.reserved.unwrap_or(0)
    }

    pub fn clear_reserved(&mut self) {
        self.reserved = ::std::option::Option::None;
    }

    pub fn has_reserved(&self) -> bool {
        self.reserved.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reserved(&mut self, v: u32) {
        self.reserved = ::std::option::Option::Some(v);
    }

    // optional uint64 number_of_segments = 9;

    pub fn number_of_segments(&self) -> u64 {
        self.number_of_segments.unwrap_or(0)
    }

    pub fn clear_number_of_segments(&mut self) {
        self.number_of_segments = ::std::option::Option::None;
    }

    pub fn has_number_of_segments(&self) -> bool {
        self.number_of_segments.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number_of_segments(&mut self, v: u64) {
        self.number_of_segments = ::std::option::Option::Some(v);
    }

    // optional bytes dynamic_linker = 10;

    pub fn dynamic_linker(&self) -> &[u8] {
        match self.dynamic_linker.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_dynamic_linker(&mut self) {
        self.dynamic_linker = ::std::option::Option::None;
    }

    pub fn has_dynamic_linker(&self) -> bool {
        self.dynamic_linker.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dynamic_linker(&mut self, v: ::std::vec::Vec<u8>) {
        self.dynamic_linker = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dynamic_linker(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.dynamic_linker.is_none() {
            self.dynamic_linker = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.dynamic_linker.as_mut().unwrap()
    }

    // Take field
    pub fn take_dynamic_linker(&mut self) -> ::std::vec::Vec<u8> {
        self.dynamic_linker.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 entry_point = 11;

    pub fn entry_point(&self) -> u64 {
        self.entry_point.unwrap_or(0)
    }

    pub fn clear_entry_point(&mut self) {
        self.entry_point = ::std::option::Option::None;
    }

    pub fn has_entry_point(&self) -> bool {
        self.entry_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entry_point(&mut self, v: u64) {
        self.entry_point = ::std::option::Option::Some(v);
    }

    // optional uint64 stack_size = 12;

    pub fn stack_size(&self) -> u64 {
        self.stack_size.unwrap_or(0)
    }

    pub fn clear_stack_size(&mut self) {
        self.stack_size = ::std::option::Option::None;
    }

    pub fn has_stack_size(&self) -> bool {
        self.stack_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stack_size(&mut self, v: u64) {
        self.stack_size = ::std::option::Option::Some(v);
    }

    // optional string source_version = 13;

    pub fn source_version(&self) -> &str {
        match self.source_version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_source_version(&mut self) {
        self.source_version = ::std::option::Option::None;
    }

    pub fn has_source_version(&self) -> bool {
        self.source_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_version(&mut self, v: ::std::string::String) {
        self.source_version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_version(&mut self) -> &mut ::std::string::String {
        if self.source_version.is_none() {
            self.source_version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.source_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_source_version(&mut self) -> ::std::string::String {
        self.source_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string uuid = 23;

    pub fn uuid(&self) -> &str {
        match self.uuid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_uuid(&mut self) {
        self.uuid = ::std::option::Option::None;
    }

    pub fn has_uuid(&self) -> bool {
        self.uuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: ::std::string::String) {
        self.uuid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid(&mut self) -> &mut ::std::string::String {
        if self.uuid.is_none() {
            self.uuid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.uuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uuid(&mut self) -> ::std::string::String {
        self.uuid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 fat_magic = 29;

    pub fn fat_magic(&self) -> u32 {
        self.fat_magic.unwrap_or(0)
    }

    pub fn clear_fat_magic(&mut self) {
        self.fat_magic = ::std::option::Option::None;
    }

    pub fn has_fat_magic(&self) -> bool {
        self.fat_magic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fat_magic(&mut self, v: u32) {
        self.fat_magic = ::std::option::Option::Some(v);
    }

    // optional uint32 nfat_arch = 30;

    pub fn nfat_arch(&self) -> u32 {
        self.nfat_arch.unwrap_or(0)
    }

    pub fn clear_nfat_arch(&mut self) {
        self.nfat_arch = ::std::option::Option::None;
    }

    pub fn has_nfat_arch(&self) -> bool {
        self.nfat_arch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nfat_arch(&mut self, v: u32) {
        self.nfat_arch = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(32);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "magic",
            |m: &Macho| { &m.magic },
            |m: &mut Macho| { &mut m.magic },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cputype",
            |m: &Macho| { &m.cputype },
            |m: &mut Macho| { &mut m.cputype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cpusubtype",
            |m: &Macho| { &m.cpusubtype },
            |m: &mut Macho| { &mut m.cpusubtype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "filetype",
            |m: &Macho| { &m.filetype },
            |m: &mut Macho| { &mut m.filetype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ncmds",
            |m: &Macho| { &m.ncmds },
            |m: &mut Macho| { &mut m.ncmds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sizeofcmds",
            |m: &Macho| { &m.sizeofcmds },
            |m: &mut Macho| { &mut m.sizeofcmds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &Macho| { &m.flags },
            |m: &mut Macho| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reserved",
            |m: &Macho| { &m.reserved },
            |m: &mut Macho| { &mut m.reserved },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "number_of_segments",
            |m: &Macho| { &m.number_of_segments },
            |m: &mut Macho| { &mut m.number_of_segments },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dynamic_linker",
            |m: &Macho| { &m.dynamic_linker },
            |m: &mut Macho| { &mut m.dynamic_linker },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entry_point",
            |m: &Macho| { &m.entry_point },
            |m: &mut Macho| { &mut m.entry_point },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stack_size",
            |m: &Macho| { &m.stack_size },
            |m: &mut Macho| { &mut m.stack_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_version",
            |m: &Macho| { &m.source_version },
            |m: &mut Macho| { &mut m.source_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Symtab>(
            "symtab",
            |m: &Macho| { &m.symtab },
            |m: &mut Macho| { &mut m.symtab },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Dysymtab>(
            "dysymtab",
            |m: &Macho| { &m.dysymtab },
            |m: &mut Macho| { &mut m.dysymtab },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LinkedItData>(
            "code_signature_data",
            |m: &Macho| { &m.code_signature_data },
            |m: &mut Macho| { &mut m.code_signature_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "segments",
            |m: &Macho| { &m.segments },
            |m: &mut Macho| { &mut m.segments },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dylibs",
            |m: &Macho| { &m.dylibs },
            |m: &mut Macho| { &mut m.dylibs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DyldInfo>(
            "dyld_info",
            |m: &Macho| { &m.dyld_info },
            |m: &mut Macho| { &mut m.dyld_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rpaths",
            |m: &Macho| { &m.rpaths },
            |m: &mut Macho| { &mut m.rpaths },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entitlements",
            |m: &Macho| { &m.entitlements },
            |m: &mut Macho| { &mut m.entitlements },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "certificates",
            |m: &Macho| { &m.certificates },
            |m: &mut Macho| { &mut m.certificates },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uuid",
            |m: &Macho| { &m.uuid },
            |m: &mut Macho| { &mut m.uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BuildVersion>(
            "build_version",
            |m: &Macho| { &m.build_version },
            |m: &mut Macho| { &mut m.build_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MinVersion>(
            "min_version",
            |m: &Macho| { &m.min_version },
            |m: &mut Macho| { &mut m.min_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "exports",
            |m: &Macho| { &m.exports },
            |m: &mut Macho| { &mut m.exports },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "imports",
            |m: &Macho| { &m.imports },
            |m: &mut Macho| { &mut m.imports },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "linker_options",
            |m: &Macho| { &m.linker_options },
            |m: &mut Macho| { &mut m.linker_options },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fat_magic",
            |m: &Macho| { &m.fat_magic },
            |m: &mut Macho| { &mut m.fat_magic },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nfat_arch",
            |m: &Macho| { &m.nfat_arch },
            |m: &mut Macho| { &mut m.nfat_arch },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fat_arch",
            |m: &Macho| { &m.fat_arch },
            |m: &mut Macho| { &mut m.fat_arch },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "file",
            |m: &Macho| { &m.file },
            |m: &mut Macho| { &mut m.file },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Macho>(
            "Macho",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Macho {
    const NAME: &'static str = "Macho";

    fn is_initialized(&self) -> bool {
        for v in &self.symtab {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dysymtab {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.code_signature_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.segments {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dylibs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dyld_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.certificates {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.build_version {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.min_version {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fat_arch {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.file {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.magic = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.cputype = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.cpusubtype = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.filetype = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.ncmds = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.sizeofcmds = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.reserved = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.number_of_segments = ::std::option::Option::Some(is.read_uint64()?);
                },
                82 => {
                    self.dynamic_linker = ::std::option::Option::Some(is.read_bytes()?);
                },
                88 => {
                    self.entry_point = ::std::option::Option::Some(is.read_uint64()?);
                },
                96 => {
                    self.stack_size = ::std::option::Option::Some(is.read_uint64()?);
                },
                106 => {
                    self.source_version = ::std::option::Option::Some(is.read_string()?);
                },
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.symtab)?;
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dysymtab)?;
                },
                130 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.code_signature_data)?;
                },
                138 => {
                    self.segments.push(is.read_message()?);
                },
                146 => {
                    self.dylibs.push(is.read_message()?);
                },
                154 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dyld_info)?;
                },
                162 => {
                    self.rpaths.push(is.read_bytes()?);
                },
                170 => {
                    self.entitlements.push(is.read_string()?);
                },
                178 => {
                    self.certificates.push(is.read_message()?);
                },
                186 => {
                    self.uuid = ::std::option::Option::Some(is.read_string()?);
                },
                194 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.build_version)?;
                },
                202 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.min_version)?;
                },
                210 => {
                    self.exports.push(is.read_string()?);
                },
                218 => {
                    self.imports.push(is.read_string()?);
                },
                226 => {
                    self.linker_options.push(is.read_bytes()?);
                },
                232 => {
                    self.fat_magic = ::std::option::Option::Some(is.read_uint32()?);
                },
                240 => {
                    self.nfat_arch = ::std::option::Option::Some(is.read_uint32()?);
                },
                250 => {
                    self.fat_arch.push(is.read_message()?);
                },
                258 => {
                    self.file.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.magic {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.cputype {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.cpusubtype {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.filetype {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.ncmds {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.sizeofcmds {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.reserved {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.number_of_segments {
            my_size += ::protobuf::rt::uint64_size(9, v);
        }
        if let Some(v) = self.dynamic_linker.as_ref() {
            my_size += ::protobuf::rt::bytes_size(10, &v);
        }
        if let Some(v) = self.entry_point {
            my_size += ::protobuf::rt::uint64_size(11, v);
        }
        if let Some(v) = self.stack_size {
            my_size += ::protobuf::rt::uint64_size(12, v);
        }
        if let Some(v) = self.source_version.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.symtab.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dysymtab.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.code_signature_data.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.segments {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.dylibs {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.dyld_info.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.rpaths {
            my_size += ::protobuf::rt::bytes_size(20, &value);
        };
        for value in &self.entitlements {
            my_size += ::protobuf::rt::string_size(21, &value);
        };
        for value in &self.certificates {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.uuid.as_ref() {
            my_size += ::protobuf::rt::string_size(23, &v);
        }
        if let Some(v) = self.build_version.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.min_version.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.exports {
            my_size += ::protobuf::rt::string_size(26, &value);
        };
        for value in &self.imports {
            my_size += ::protobuf::rt::string_size(27, &value);
        };
        for value in &self.linker_options {
            my_size += ::protobuf::rt::bytes_size(28, &value);
        };
        if let Some(v) = self.fat_magic {
            my_size += ::protobuf::rt::uint32_size(29, v);
        }
        if let Some(v) = self.nfat_arch {
            my_size += ::protobuf::rt::uint32_size(30, v);
        }
        for value in &self.fat_arch {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.file {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.magic {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.cputype {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.cpusubtype {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.filetype {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.ncmds {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.sizeofcmds {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.reserved {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.number_of_segments {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.dynamic_linker.as_ref() {
            os.write_bytes(10, v)?;
        }
        if let Some(v) = self.entry_point {
            os.write_uint64(11, v)?;
        }
        if let Some(v) = self.stack_size {
            os.write_uint64(12, v)?;
        }
        if let Some(v) = self.source_version.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.symtab.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        if let Some(v) = self.dysymtab.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.code_signature_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        for v in &self.segments {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        };
        for v in &self.dylibs {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        };
        if let Some(v) = self.dyld_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        }
        for v in &self.rpaths {
            os.write_bytes(20, &v)?;
        };
        for v in &self.entitlements {
            os.write_string(21, &v)?;
        };
        for v in &self.certificates {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        };
        if let Some(v) = self.uuid.as_ref() {
            os.write_string(23, v)?;
        }
        if let Some(v) = self.build_version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        if let Some(v) = self.min_version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        }
        for v in &self.exports {
            os.write_string(26, &v)?;
        };
        for v in &self.imports {
            os.write_string(27, &v)?;
        };
        for v in &self.linker_options {
            os.write_bytes(28, &v)?;
        };
        if let Some(v) = self.fat_magic {
            os.write_uint32(29, v)?;
        }
        if let Some(v) = self.nfat_arch {
            os.write_uint32(30, v)?;
        }
        for v in &self.fat_arch {
            ::protobuf::rt::write_message_field_with_cached_size(31, v, os)?;
        };
        for v in &self.file {
            ::protobuf::rt::write_message_field_with_cached_size(32, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Macho {
        Macho::new()
    }

    fn clear(&mut self) {
        self.magic = ::std::option::Option::None;
        self.cputype = ::std::option::Option::None;
        self.cpusubtype = ::std::option::Option::None;
        self.filetype = ::std::option::Option::None;
        self.ncmds = ::std::option::Option::None;
        self.sizeofcmds = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.reserved = ::std::option::Option::None;
        self.number_of_segments = ::std::option::Option::None;
        self.dynamic_linker = ::std::option::Option::None;
        self.entry_point = ::std::option::Option::None;
        self.stack_size = ::std::option::Option::None;
        self.source_version = ::std::option::Option::None;
        self.symtab.clear();
        self.dysymtab.clear();
        self.code_signature_data.clear();
        self.segments.clear();
        self.dylibs.clear();
        self.dyld_info.clear();
        self.rpaths.clear();
        self.entitlements.clear();
        self.certificates.clear();
        self.uuid = ::std::option::Option::None;
        self.build_version.clear();
        self.min_version.clear();
        self.exports.clear();
        self.imports.clear();
        self.linker_options.clear();
        self.fat_magic = ::std::option::Option::None;
        self.nfat_arch = ::std::option::Option::None;
        self.fat_arch.clear();
        self.file.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Macho {
        static instance: Macho = Macho {
            magic: ::std::option::Option::None,
            cputype: ::std::option::Option::None,
            cpusubtype: ::std::option::Option::None,
            filetype: ::std::option::Option::None,
            ncmds: ::std::option::Option::None,
            sizeofcmds: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            reserved: ::std::option::Option::None,
            number_of_segments: ::std::option::Option::None,
            dynamic_linker: ::std::option::Option::None,
            entry_point: ::std::option::Option::None,
            stack_size: ::std::option::Option::None,
            source_version: ::std::option::Option::None,
            symtab: ::protobuf::MessageField::none(),
            dysymtab: ::protobuf::MessageField::none(),
            code_signature_data: ::protobuf::MessageField::none(),
            segments: ::std::vec::Vec::new(),
            dylibs: ::std::vec::Vec::new(),
            dyld_info: ::protobuf::MessageField::none(),
            rpaths: ::std::vec::Vec::new(),
            entitlements: ::std::vec::Vec::new(),
            certificates: ::std::vec::Vec::new(),
            uuid: ::std::option::Option::None,
            build_version: ::protobuf::MessageField::none(),
            min_version: ::protobuf::MessageField::none(),
            exports: ::std::vec::Vec::new(),
            imports: ::std::vec::Vec::new(),
            linker_options: ::std::vec::Vec::new(),
            fat_magic: ::std::option::Option::None,
            nfat_arch: ::std::option::Option::None,
            fat_arch: ::std::vec::Vec::new(),
            file: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Macho {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Macho").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Macho {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Macho {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:macho.Header)
pub enum Header {
    // @@protoc_insertion_point(enum_value:macho.Header.MH_MAGIC)
    MH_MAGIC = 0,
    // @@protoc_insertion_point(enum_value:macho.Header.MH_CIGAM)
    MH_CIGAM = 1,
    // @@protoc_insertion_point(enum_value:macho.Header.MH_MAGIC_64)
    MH_MAGIC_64 = 2,
    // @@protoc_insertion_point(enum_value:macho.Header.MH_CIGAM_64)
    MH_CIGAM_64 = 3,
}

impl ::protobuf::Enum for Header {
    const NAME: &'static str = "Header";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Header> {
        match value {
            0 => ::std::option::Option::Some(Header::MH_MAGIC),
            1 => ::std::option::Option::Some(Header::MH_CIGAM),
            2 => ::std::option::Option::Some(Header::MH_MAGIC_64),
            3 => ::std::option::Option::Some(Header::MH_CIGAM_64),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Header> {
        match str {
            "MH_MAGIC" => ::std::option::Option::Some(Header::MH_MAGIC),
            "MH_CIGAM" => ::std::option::Option::Some(Header::MH_CIGAM),
            "MH_MAGIC_64" => ::std::option::Option::Some(Header::MH_MAGIC_64),
            "MH_CIGAM_64" => ::std::option::Option::Some(Header::MH_CIGAM_64),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Header] = &[
        Header::MH_MAGIC,
        Header::MH_CIGAM,
        Header::MH_MAGIC_64,
        Header::MH_CIGAM_64,
    ];
}

impl ::protobuf::EnumFull for Header {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Header").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Header {
    fn default() -> Self {
        Header::MH_MAGIC
    }
}

impl Header {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Header>("Header")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:macho.FatHeader)
pub enum FatHeader {
    // @@protoc_insertion_point(enum_value:macho.FatHeader.FAT_MAGIC)
    FAT_MAGIC = 0,
    // @@protoc_insertion_point(enum_value:macho.FatHeader.FAT_CIGAM)
    FAT_CIGAM = 1,
    // @@protoc_insertion_point(enum_value:macho.FatHeader.FAT_MAGIC_64)
    FAT_MAGIC_64 = 2,
    // @@protoc_insertion_point(enum_value:macho.FatHeader.FAT_CIGAM_64)
    FAT_CIGAM_64 = 3,
}

impl ::protobuf::Enum for FatHeader {
    const NAME: &'static str = "FatHeader";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FatHeader> {
        match value {
            0 => ::std::option::Option::Some(FatHeader::FAT_MAGIC),
            1 => ::std::option::Option::Some(FatHeader::FAT_CIGAM),
            2 => ::std::option::Option::Some(FatHeader::FAT_MAGIC_64),
            3 => ::std::option::Option::Some(FatHeader::FAT_CIGAM_64),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<FatHeader> {
        match str {
            "FAT_MAGIC" => ::std::option::Option::Some(FatHeader::FAT_MAGIC),
            "FAT_CIGAM" => ::std::option::Option::Some(FatHeader::FAT_CIGAM),
            "FAT_MAGIC_64" => ::std::option::Option::Some(FatHeader::FAT_MAGIC_64),
            "FAT_CIGAM_64" => ::std::option::Option::Some(FatHeader::FAT_CIGAM_64),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [FatHeader] = &[
        FatHeader::FAT_MAGIC,
        FatHeader::FAT_CIGAM,
        FatHeader::FAT_MAGIC_64,
        FatHeader::FAT_CIGAM_64,
    ];
}

impl ::protobuf::EnumFull for FatHeader {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("FatHeader").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for FatHeader {
    fn default() -> Self {
        FatHeader::FAT_MAGIC
    }
}

impl FatHeader {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<FatHeader>("FatHeader")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:macho.Mask64Bit)
pub enum Mask64Bit {
    // @@protoc_insertion_point(enum_value:macho.Mask64Bit.CPU_ARCH_ABI64)
    CPU_ARCH_ABI64 = 16777216,
    // @@protoc_insertion_point(enum_value:macho.Mask64Bit.CPU_SUBTYPE_LIB64)
    CPU_SUBTYPE_LIB64 = 0,
}

impl ::protobuf::Enum for Mask64Bit {
    const NAME: &'static str = "Mask64Bit";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Mask64Bit> {
        match value {
            16777216 => ::std::option::Option::Some(Mask64Bit::CPU_ARCH_ABI64),
            0 => ::std::option::Option::Some(Mask64Bit::CPU_SUBTYPE_LIB64),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Mask64Bit> {
        match str {
            "CPU_ARCH_ABI64" => ::std::option::Option::Some(Mask64Bit::CPU_ARCH_ABI64),
            "CPU_SUBTYPE_LIB64" => ::std::option::Option::Some(Mask64Bit::CPU_SUBTYPE_LIB64),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Mask64Bit] = &[
        Mask64Bit::CPU_ARCH_ABI64,
        Mask64Bit::CPU_SUBTYPE_LIB64,
    ];
}

impl ::protobuf::EnumFull for Mask64Bit {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Mask64Bit").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            Mask64Bit::CPU_ARCH_ABI64 => 0,
            Mask64Bit::CPU_SUBTYPE_LIB64 => 1,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for Mask64Bit {
    fn default() -> Self {
        Mask64Bit::CPU_ARCH_ABI64
    }
}

impl Mask64Bit {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Mask64Bit>("Mask64Bit")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:macho.CpuType)
pub enum CpuType {
    // @@protoc_insertion_point(enum_value:macho.CpuType.CPU_TYPE_MC680X0)
    CPU_TYPE_MC680X0 = 6,
    // @@protoc_insertion_point(enum_value:macho.CpuType.CPU_TYPE_X86)
    CPU_TYPE_X86 = 7,
    // @@protoc_insertion_point(enum_value:macho.CpuType.CPU_TYPE_X86_64)
    CPU_TYPE_X86_64 = 16777223,
    // @@protoc_insertion_point(enum_value:macho.CpuType.CPU_TYPE_MIPS)
    CPU_TYPE_MIPS = 8,
    // @@protoc_insertion_point(enum_value:macho.CpuType.CPU_TYPE_MC98000)
    CPU_TYPE_MC98000 = 10,
    // @@protoc_insertion_point(enum_value:macho.CpuType.CPU_TYPE_ARM)
    CPU_TYPE_ARM = 12,
    // @@protoc_insertion_point(enum_value:macho.CpuType.CPU_TYPE_ARM64)
    CPU_TYPE_ARM64 = 16777228,
    // @@protoc_insertion_point(enum_value:macho.CpuType.CPU_TYPE_MC88000)
    CPU_TYPE_MC88000 = 13,
    // @@protoc_insertion_point(enum_value:macho.CpuType.CPU_TYPE_SPARC)
    CPU_TYPE_SPARC = 14,
    // @@protoc_insertion_point(enum_value:macho.CpuType.CPU_TYPE_POWERPC)
    CPU_TYPE_POWERPC = 18,
    // @@protoc_insertion_point(enum_value:macho.CpuType.CPU_TYPE_POWERPC64)
    CPU_TYPE_POWERPC64 = 16777234,
}

impl ::protobuf::Enum for CpuType {
    const NAME: &'static str = "CpuType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CpuType> {
        match value {
            6 => ::std::option::Option::Some(CpuType::CPU_TYPE_MC680X0),
            7 => ::std::option::Option::Some(CpuType::CPU_TYPE_X86),
            16777223 => ::std::option::Option::Some(CpuType::CPU_TYPE_X86_64),
            8 => ::std::option::Option::Some(CpuType::CPU_TYPE_MIPS),
            10 => ::std::option::Option::Some(CpuType::CPU_TYPE_MC98000),
            12 => ::std::option::Option::Some(CpuType::CPU_TYPE_ARM),
            16777228 => ::std::option::Option::Some(CpuType::CPU_TYPE_ARM64),
            13 => ::std::option::Option::Some(CpuType::CPU_TYPE_MC88000),
            14 => ::std::option::Option::Some(CpuType::CPU_TYPE_SPARC),
            18 => ::std::option::Option::Some(CpuType::CPU_TYPE_POWERPC),
            16777234 => ::std::option::Option::Some(CpuType::CPU_TYPE_POWERPC64),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CpuType> {
        match str {
            "CPU_TYPE_MC680X0" => ::std::option::Option::Some(CpuType::CPU_TYPE_MC680X0),
            "CPU_TYPE_X86" => ::std::option::Option::Some(CpuType::CPU_TYPE_X86),
            "CPU_TYPE_X86_64" => ::std::option::Option::Some(CpuType::CPU_TYPE_X86_64),
            "CPU_TYPE_MIPS" => ::std::option::Option::Some(CpuType::CPU_TYPE_MIPS),
            "CPU_TYPE_MC98000" => ::std::option::Option::Some(CpuType::CPU_TYPE_MC98000),
            "CPU_TYPE_ARM" => ::std::option::Option::Some(CpuType::CPU_TYPE_ARM),
            "CPU_TYPE_ARM64" => ::std::option::Option::Some(CpuType::CPU_TYPE_ARM64),
            "CPU_TYPE_MC88000" => ::std::option::Option::Some(CpuType::CPU_TYPE_MC88000),
            "CPU_TYPE_SPARC" => ::std::option::Option::Some(CpuType::CPU_TYPE_SPARC),
            "CPU_TYPE_POWERPC" => ::std::option::Option::Some(CpuType::CPU_TYPE_POWERPC),
            "CPU_TYPE_POWERPC64" => ::std::option::Option::Some(CpuType::CPU_TYPE_POWERPC64),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CpuType] = &[
        CpuType::CPU_TYPE_MC680X0,
        CpuType::CPU_TYPE_X86,
        CpuType::CPU_TYPE_X86_64,
        CpuType::CPU_TYPE_MIPS,
        CpuType::CPU_TYPE_MC98000,
        CpuType::CPU_TYPE_ARM,
        CpuType::CPU_TYPE_ARM64,
        CpuType::CPU_TYPE_MC88000,
        CpuType::CPU_TYPE_SPARC,
        CpuType::CPU_TYPE_POWERPC,
        CpuType::CPU_TYPE_POWERPC64,
    ];
}

impl ::protobuf::EnumFull for CpuType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CpuType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            CpuType::CPU_TYPE_MC680X0 => 0,
            CpuType::CPU_TYPE_X86 => 1,
            CpuType::CPU_TYPE_X86_64 => 2,
            CpuType::CPU_TYPE_MIPS => 3,
            CpuType::CPU_TYPE_MC98000 => 4,
            CpuType::CPU_TYPE_ARM => 5,
            CpuType::CPU_TYPE_ARM64 => 6,
            CpuType::CPU_TYPE_MC88000 => 7,
            CpuType::CPU_TYPE_SPARC => 8,
            CpuType::CPU_TYPE_POWERPC => 9,
            CpuType::CPU_TYPE_POWERPC64 => 10,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CpuType {
    fn default() -> Self {
        CpuType::CPU_TYPE_MC680X0
    }
}

impl CpuType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CpuType>("CpuType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:macho.CpuI386Type)
pub enum CpuI386Type {
    // @@protoc_insertion_point(enum_value:macho.CpuI386Type.CPU_TYPE_I386)
    CPU_TYPE_I386 = 7,
}

impl ::protobuf::Enum for CpuI386Type {
    const NAME: &'static str = "CpuI386Type";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CpuI386Type> {
        match value {
            7 => ::std::option::Option::Some(CpuI386Type::CPU_TYPE_I386),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CpuI386Type> {
        match str {
            "CPU_TYPE_I386" => ::std::option::Option::Some(CpuI386Type::CPU_TYPE_I386),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CpuI386Type] = &[
        CpuI386Type::CPU_TYPE_I386,
    ];
}

impl ::protobuf::EnumFull for CpuI386Type {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CpuI386Type").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            CpuI386Type::CPU_TYPE_I386 => 0,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CpuI386Type {
    fn default() -> Self {
        CpuI386Type::CPU_TYPE_I386
    }
}

impl CpuI386Type {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CpuI386Type>("CpuI386Type")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:macho.CpuIntelSubType)
pub enum CpuIntelSubType {
    // @@protoc_insertion_point(enum_value:macho.CpuIntelSubType.CPU_SUBTYPE_INTEL_MODEL_ALL)
    CPU_SUBTYPE_INTEL_MODEL_ALL = 0,
    // @@protoc_insertion_point(enum_value:macho.CpuIntelSubType.CPU_SUBTYPE_386)
    CPU_SUBTYPE_386 = 3,
    // @@protoc_insertion_point(enum_value:macho.CpuIntelSubType.CPU_SUBTYPE_486)
    CPU_SUBTYPE_486 = 4,
    // @@protoc_insertion_point(enum_value:macho.CpuIntelSubType.CPU_SUBTYPE_486SX)
    CPU_SUBTYPE_486SX = 132,
    // @@protoc_insertion_point(enum_value:macho.CpuIntelSubType.CPU_SUBTYPE_586)
    CPU_SUBTYPE_586 = 5,
    // @@protoc_insertion_point(enum_value:macho.CpuIntelSubType.CPU_SUBTYPE_CELERON)
    CPU_SUBTYPE_CELERON = 103,
    // @@protoc_insertion_point(enum_value:macho.CpuIntelSubType.CPU_SUBTYPE_CELERON_MOBILE)
    CPU_SUBTYPE_CELERON_MOBILE = 119,
    // @@protoc_insertion_point(enum_value:macho.CpuIntelSubType.CPU_SUBTYPE_ITANIUM)
    CPU_SUBTYPE_ITANIUM = 11,
    // @@protoc_insertion_point(enum_value:macho.CpuIntelSubType.CPU_SUBTYPE_ITANIUM_2)
    CPU_SUBTYPE_ITANIUM_2 = 27,
    // @@protoc_insertion_point(enum_value:macho.CpuIntelSubType.CPU_SUBTYPE_XEON)
    CPU_SUBTYPE_XEON = 12,
    // @@protoc_insertion_point(enum_value:macho.CpuIntelSubType.CPU_SUBTYPE_XEON_MP)
    CPU_SUBTYPE_XEON_MP = 28,
}

impl ::protobuf::Enum for CpuIntelSubType {
    const NAME: &'static str = "CpuIntelSubType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CpuIntelSubType> {
        match value {
            0 => ::std::option::Option::Some(CpuIntelSubType::CPU_SUBTYPE_INTEL_MODEL_ALL),
            3 => ::std::option::Option::Some(CpuIntelSubType::CPU_SUBTYPE_386),
            4 => ::std::option::Option::Some(CpuIntelSubType::CPU_SUBTYPE_486),
            132 => ::std::option::Option::Some(CpuIntelSubType::CPU_SUBTYPE_486SX),
            5 => ::std::option::Option::Some(CpuIntelSubType::CPU_SUBTYPE_586),
            103 => ::std::option::Option::Some(CpuIntelSubType::CPU_SUBTYPE_CELERON),
            119 => ::std::option::Option::Some(CpuIntelSubType::CPU_SUBTYPE_CELERON_MOBILE),
            11 => ::std::option::Option::Some(CpuIntelSubType::CPU_SUBTYPE_ITANIUM),
            27 => ::std::option::Option::Some(CpuIntelSubType::CPU_SUBTYPE_ITANIUM_2),
            12 => ::std::option::Option::Some(CpuIntelSubType::CPU_SUBTYPE_XEON),
            28 => ::std::option::Option::Some(CpuIntelSubType::CPU_SUBTYPE_XEON_MP),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CpuIntelSubType> {
        match str {
            "CPU_SUBTYPE_INTEL_MODEL_ALL" => ::std::option::Option::Some(CpuIntelSubType::CPU_SUBTYPE_INTEL_MODEL_ALL),
            "CPU_SUBTYPE_386" => ::std::option::Option::Some(CpuIntelSubType::CPU_SUBTYPE_386),
            "CPU_SUBTYPE_486" => ::std::option::Option::Some(CpuIntelSubType::CPU_SUBTYPE_486),
            "CPU_SUBTYPE_486SX" => ::std::option::Option::Some(CpuIntelSubType::CPU_SUBTYPE_486SX),
            "CPU_SUBTYPE_586" => ::std::option::Option::Some(CpuIntelSubType::CPU_SUBTYPE_586),
            "CPU_SUBTYPE_CELERON" => ::std::option::Option::Some(CpuIntelSubType::CPU_SUBTYPE_CELERON),
            "CPU_SUBTYPE_CELERON_MOBILE" => ::std::option::Option::Some(CpuIntelSubType::CPU_SUBTYPE_CELERON_MOBILE),
            "CPU_SUBTYPE_ITANIUM" => ::std::option::Option::Some(CpuIntelSubType::CPU_SUBTYPE_ITANIUM),
            "CPU_SUBTYPE_ITANIUM_2" => ::std::option::Option::Some(CpuIntelSubType::CPU_SUBTYPE_ITANIUM_2),
            "CPU_SUBTYPE_XEON" => ::std::option::Option::Some(CpuIntelSubType::CPU_SUBTYPE_XEON),
            "CPU_SUBTYPE_XEON_MP" => ::std::option::Option::Some(CpuIntelSubType::CPU_SUBTYPE_XEON_MP),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CpuIntelSubType] = &[
        CpuIntelSubType::CPU_SUBTYPE_INTEL_MODEL_ALL,
        CpuIntelSubType::CPU_SUBTYPE_386,
        CpuIntelSubType::CPU_SUBTYPE_486,
        CpuIntelSubType::CPU_SUBTYPE_486SX,
        CpuIntelSubType::CPU_SUBTYPE_586,
        CpuIntelSubType::CPU_SUBTYPE_CELERON,
        CpuIntelSubType::CPU_SUBTYPE_CELERON_MOBILE,
        CpuIntelSubType::CPU_SUBTYPE_ITANIUM,
        CpuIntelSubType::CPU_SUBTYPE_ITANIUM_2,
        CpuIntelSubType::CPU_SUBTYPE_XEON,
        CpuIntelSubType::CPU_SUBTYPE_XEON_MP,
    ];
}

impl ::protobuf::EnumFull for CpuIntelSubType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CpuIntelSubType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            CpuIntelSubType::CPU_SUBTYPE_INTEL_MODEL_ALL => 0,
            CpuIntelSubType::CPU_SUBTYPE_386 => 1,
            CpuIntelSubType::CPU_SUBTYPE_486 => 2,
            CpuIntelSubType::CPU_SUBTYPE_486SX => 3,
            CpuIntelSubType::CPU_SUBTYPE_586 => 4,
            CpuIntelSubType::CPU_SUBTYPE_CELERON => 5,
            CpuIntelSubType::CPU_SUBTYPE_CELERON_MOBILE => 6,
            CpuIntelSubType::CPU_SUBTYPE_ITANIUM => 7,
            CpuIntelSubType::CPU_SUBTYPE_ITANIUM_2 => 8,
            CpuIntelSubType::CPU_SUBTYPE_XEON => 9,
            CpuIntelSubType::CPU_SUBTYPE_XEON_MP => 10,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for CpuIntelSubType {
    fn default() -> Self {
        CpuIntelSubType::CPU_SUBTYPE_INTEL_MODEL_ALL
    }
}

impl CpuIntelSubType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CpuIntelSubType>("CpuIntelSubType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:macho.CpuI386SubType)
pub enum CpuI386SubType {
    // @@protoc_insertion_point(enum_value:macho.CpuI386SubType.CPU_SUBTYPE_I386_ALL)
    CPU_SUBTYPE_I386_ALL = 3,
}

impl ::protobuf::Enum for CpuI386SubType {
    const NAME: &'static str = "CpuI386SubType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CpuI386SubType> {
        match value {
            3 => ::std::option::Option::Some(CpuI386SubType::CPU_SUBTYPE_I386_ALL),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CpuI386SubType> {
        match str {
            "CPU_SUBTYPE_I386_ALL" => ::std::option::Option::Some(CpuI386SubType::CPU_SUBTYPE_I386_ALL),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CpuI386SubType] = &[
        CpuI386SubType::CPU_SUBTYPE_I386_ALL,
    ];
}

impl ::protobuf::EnumFull for CpuI386SubType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CpuI386SubType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            CpuI386SubType::CPU_SUBTYPE_I386_ALL => 0,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CpuI386SubType {
    fn default() -> Self {
        CpuI386SubType::CPU_SUBTYPE_I386_ALL
    }
}

impl CpuI386SubType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CpuI386SubType>("CpuI386SubType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:macho.CpuX86SubType)
pub enum CpuX86SubType {
    // @@protoc_insertion_point(enum_value:macho.CpuX86SubType.CPU_SUBTYPE_X86_64_ALL)
    CPU_SUBTYPE_X86_64_ALL = 3,
}

impl ::protobuf::Enum for CpuX86SubType {
    const NAME: &'static str = "CpuX86SubType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CpuX86SubType> {
        match value {
            3 => ::std::option::Option::Some(CpuX86SubType::CPU_SUBTYPE_X86_64_ALL),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CpuX86SubType> {
        match str {
            "CPU_SUBTYPE_X86_64_ALL" => ::std::option::Option::Some(CpuX86SubType::CPU_SUBTYPE_X86_64_ALL),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CpuX86SubType] = &[
        CpuX86SubType::CPU_SUBTYPE_X86_64_ALL,
    ];
}

impl ::protobuf::EnumFull for CpuX86SubType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CpuX86SubType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            CpuX86SubType::CPU_SUBTYPE_X86_64_ALL => 0,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CpuX86SubType {
    fn default() -> Self {
        CpuX86SubType::CPU_SUBTYPE_X86_64_ALL
    }
}

impl CpuX86SubType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CpuX86SubType>("CpuX86SubType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:macho.CpuIntelPentiumSubType)
pub enum CpuIntelPentiumSubType {
    // @@protoc_insertion_point(enum_value:macho.CpuIntelPentiumSubType.CPU_SUBTYPE_PENT)
    CPU_SUBTYPE_PENT = 5,
    // @@protoc_insertion_point(enum_value:macho.CpuIntelPentiumSubType.CPU_SUBTYPE_PENTPRO)
    CPU_SUBTYPE_PENTPRO = 22,
    // @@protoc_insertion_point(enum_value:macho.CpuIntelPentiumSubType.CPU_SUBTYPE_PENTII_M3)
    CPU_SUBTYPE_PENTII_M3 = 54,
    // @@protoc_insertion_point(enum_value:macho.CpuIntelPentiumSubType.CPU_SUBTYPE_PENTII_M5)
    CPU_SUBTYPE_PENTII_M5 = 86,
    // @@protoc_insertion_point(enum_value:macho.CpuIntelPentiumSubType.CPU_SUBTYPE_PENTIUM_3)
    CPU_SUBTYPE_PENTIUM_3 = 8,
    // @@protoc_insertion_point(enum_value:macho.CpuIntelPentiumSubType.CPU_SUBTYPE_PENTIUM_3_M)
    CPU_SUBTYPE_PENTIUM_3_M = 24,
    // @@protoc_insertion_point(enum_value:macho.CpuIntelPentiumSubType.CPU_SUBTYPE_PENTIUM_3_XEON)
    CPU_SUBTYPE_PENTIUM_3_XEON = 40,
    // @@protoc_insertion_point(enum_value:macho.CpuIntelPentiumSubType.CPU_SUBTYPE_PENTIUM_M)
    CPU_SUBTYPE_PENTIUM_M = 9,
    // @@protoc_insertion_point(enum_value:macho.CpuIntelPentiumSubType.CPU_SUBTYPE_PENTIUM_4)
    CPU_SUBTYPE_PENTIUM_4 = 10,
    // @@protoc_insertion_point(enum_value:macho.CpuIntelPentiumSubType.CPU_SUBTYPE_PENTIUM_4_M)
    CPU_SUBTYPE_PENTIUM_4_M = 26,
}

impl ::protobuf::Enum for CpuIntelPentiumSubType {
    const NAME: &'static str = "CpuIntelPentiumSubType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CpuIntelPentiumSubType> {
        match value {
            5 => ::std::option::Option::Some(CpuIntelPentiumSubType::CPU_SUBTYPE_PENT),
            22 => ::std::option::Option::Some(CpuIntelPentiumSubType::CPU_SUBTYPE_PENTPRO),
            54 => ::std::option::Option::Some(CpuIntelPentiumSubType::CPU_SUBTYPE_PENTII_M3),
            86 => ::std::option::Option::Some(CpuIntelPentiumSubType::CPU_SUBTYPE_PENTII_M5),
            8 => ::std::option::Option::Some(CpuIntelPentiumSubType::CPU_SUBTYPE_PENTIUM_3),
            24 => ::std::option::Option::Some(CpuIntelPentiumSubType::CPU_SUBTYPE_PENTIUM_3_M),
            40 => ::std::option::Option::Some(CpuIntelPentiumSubType::CPU_SUBTYPE_PENTIUM_3_XEON),
            9 => ::std::option::Option::Some(CpuIntelPentiumSubType::CPU_SUBTYPE_PENTIUM_M),
            10 => ::std::option::Option::Some(CpuIntelPentiumSubType::CPU_SUBTYPE_PENTIUM_4),
            26 => ::std::option::Option::Some(CpuIntelPentiumSubType::CPU_SUBTYPE_PENTIUM_4_M),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CpuIntelPentiumSubType> {
        match str {
            "CPU_SUBTYPE_PENT" => ::std::option::Option::Some(CpuIntelPentiumSubType::CPU_SUBTYPE_PENT),
            "CPU_SUBTYPE_PENTPRO" => ::std::option::Option::Some(CpuIntelPentiumSubType::CPU_SUBTYPE_PENTPRO),
            "CPU_SUBTYPE_PENTII_M3" => ::std::option::Option::Some(CpuIntelPentiumSubType::CPU_SUBTYPE_PENTII_M3),
            "CPU_SUBTYPE_PENTII_M5" => ::std::option::Option::Some(CpuIntelPentiumSubType::CPU_SUBTYPE_PENTII_M5),
            "CPU_SUBTYPE_PENTIUM_3" => ::std::option::Option::Some(CpuIntelPentiumSubType::CPU_SUBTYPE_PENTIUM_3),
            "CPU_SUBTYPE_PENTIUM_3_M" => ::std::option::Option::Some(CpuIntelPentiumSubType::CPU_SUBTYPE_PENTIUM_3_M),
            "CPU_SUBTYPE_PENTIUM_3_XEON" => ::std::option::Option::Some(CpuIntelPentiumSubType::CPU_SUBTYPE_PENTIUM_3_XEON),
            "CPU_SUBTYPE_PENTIUM_M" => ::std::option::Option::Some(CpuIntelPentiumSubType::CPU_SUBTYPE_PENTIUM_M),
            "CPU_SUBTYPE_PENTIUM_4" => ::std::option::Option::Some(CpuIntelPentiumSubType::CPU_SUBTYPE_PENTIUM_4),
            "CPU_SUBTYPE_PENTIUM_4_M" => ::std::option::Option::Some(CpuIntelPentiumSubType::CPU_SUBTYPE_PENTIUM_4_M),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CpuIntelPentiumSubType] = &[
        CpuIntelPentiumSubType::CPU_SUBTYPE_PENT,
        CpuIntelPentiumSubType::CPU_SUBTYPE_PENTPRO,
        CpuIntelPentiumSubType::CPU_SUBTYPE_PENTII_M3,
        CpuIntelPentiumSubType::CPU_SUBTYPE_PENTII_M5,
        CpuIntelPentiumSubType::CPU_SUBTYPE_PENTIUM_3,
        CpuIntelPentiumSubType::CPU_SUBTYPE_PENTIUM_3_M,
        CpuIntelPentiumSubType::CPU_SUBTYPE_PENTIUM_3_XEON,
        CpuIntelPentiumSubType::CPU_SUBTYPE_PENTIUM_M,
        CpuIntelPentiumSubType::CPU_SUBTYPE_PENTIUM_4,
        CpuIntelPentiumSubType::CPU_SUBTYPE_PENTIUM_4_M,
    ];
}

impl ::protobuf::EnumFull for CpuIntelPentiumSubType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CpuIntelPentiumSubType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            CpuIntelPentiumSubType::CPU_SUBTYPE_PENT => 0,
            CpuIntelPentiumSubType::CPU_SUBTYPE_PENTPRO => 1,
            CpuIntelPentiumSubType::CPU_SUBTYPE_PENTII_M3 => 2,
            CpuIntelPentiumSubType::CPU_SUBTYPE_PENTII_M5 => 3,
            CpuIntelPentiumSubType::CPU_SUBTYPE_PENTIUM_3 => 4,
            CpuIntelPentiumSubType::CPU_SUBTYPE_PENTIUM_3_M => 5,
            CpuIntelPentiumSubType::CPU_SUBTYPE_PENTIUM_3_XEON => 6,
            CpuIntelPentiumSubType::CPU_SUBTYPE_PENTIUM_M => 7,
            CpuIntelPentiumSubType::CPU_SUBTYPE_PENTIUM_4 => 8,
            CpuIntelPentiumSubType::CPU_SUBTYPE_PENTIUM_4_M => 9,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CpuIntelPentiumSubType {
    fn default() -> Self {
        CpuIntelPentiumSubType::CPU_SUBTYPE_PENT
    }
}

impl CpuIntelPentiumSubType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CpuIntelPentiumSubType>("CpuIntelPentiumSubType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:macho.CpuArmSubType)
pub enum CpuArmSubType {
    // @@protoc_insertion_point(enum_value:macho.CpuArmSubType.CPU_SUBTYPE_ARM_ALL)
    CPU_SUBTYPE_ARM_ALL = 0,
    // @@protoc_insertion_point(enum_value:macho.CpuArmSubType.CPU_SUBTYPE_ARM_V4T)
    CPU_SUBTYPE_ARM_V4T = 5,
    // @@protoc_insertion_point(enum_value:macho.CpuArmSubType.CPU_SUBTYPE_ARM_V6)
    CPU_SUBTYPE_ARM_V6 = 6,
    // @@protoc_insertion_point(enum_value:macho.CpuArmSubType.CPU_SUBTYPE_ARM_V5)
    CPU_SUBTYPE_ARM_V5 = 7,
    // @@protoc_insertion_point(enum_value:macho.CpuArmSubType.CPU_SUBTYPE_ARM_XSCALE)
    CPU_SUBTYPE_ARM_XSCALE = 8,
    // @@protoc_insertion_point(enum_value:macho.CpuArmSubType.CPU_SUBTYPE_ARM_V7)
    CPU_SUBTYPE_ARM_V7 = 9,
    // @@protoc_insertion_point(enum_value:macho.CpuArmSubType.CPU_SUBTYPE_ARM_V7F)
    CPU_SUBTYPE_ARM_V7F = 10,
    // @@protoc_insertion_point(enum_value:macho.CpuArmSubType.CPU_SUBTYPE_ARM_V7S)
    CPU_SUBTYPE_ARM_V7S = 11,
    // @@protoc_insertion_point(enum_value:macho.CpuArmSubType.CPU_SUBTYPE_ARM_V7K)
    CPU_SUBTYPE_ARM_V7K = 12,
    // @@protoc_insertion_point(enum_value:macho.CpuArmSubType.CPU_SUBTYPE_ARM_V6M)
    CPU_SUBTYPE_ARM_V6M = 14,
    // @@protoc_insertion_point(enum_value:macho.CpuArmSubType.CPU_SUBTYPE_ARM_V7M)
    CPU_SUBTYPE_ARM_V7M = 15,
    // @@protoc_insertion_point(enum_value:macho.CpuArmSubType.CPU_SUBTYPE_ARM_V7EM)
    CPU_SUBTYPE_ARM_V7EM = 16,
}

impl ::protobuf::Enum for CpuArmSubType {
    const NAME: &'static str = "CpuArmSubType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CpuArmSubType> {
        match value {
            0 => ::std::option::Option::Some(CpuArmSubType::CPU_SUBTYPE_ARM_ALL),
            5 => ::std::option::Option::Some(CpuArmSubType::CPU_SUBTYPE_ARM_V4T),
            6 => ::std::option::Option::Some(CpuArmSubType::CPU_SUBTYPE_ARM_V6),
            7 => ::std::option::Option::Some(CpuArmSubType::CPU_SUBTYPE_ARM_V5),
            8 => ::std::option::Option::Some(CpuArmSubType::CPU_SUBTYPE_ARM_XSCALE),
            9 => ::std::option::Option::Some(CpuArmSubType::CPU_SUBTYPE_ARM_V7),
            10 => ::std::option::Option::Some(CpuArmSubType::CPU_SUBTYPE_ARM_V7F),
            11 => ::std::option::Option::Some(CpuArmSubType::CPU_SUBTYPE_ARM_V7S),
            12 => ::std::option::Option::Some(CpuArmSubType::CPU_SUBTYPE_ARM_V7K),
            14 => ::std::option::Option::Some(CpuArmSubType::CPU_SUBTYPE_ARM_V6M),
            15 => ::std::option::Option::Some(CpuArmSubType::CPU_SUBTYPE_ARM_V7M),
            16 => ::std::option::Option::Some(CpuArmSubType::CPU_SUBTYPE_ARM_V7EM),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CpuArmSubType> {
        match str {
            "CPU_SUBTYPE_ARM_ALL" => ::std::option::Option::Some(CpuArmSubType::CPU_SUBTYPE_ARM_ALL),
            "CPU_SUBTYPE_ARM_V4T" => ::std::option::Option::Some(CpuArmSubType::CPU_SUBTYPE_ARM_V4T),
            "CPU_SUBTYPE_ARM_V6" => ::std::option::Option::Some(CpuArmSubType::CPU_SUBTYPE_ARM_V6),
            "CPU_SUBTYPE_ARM_V5" => ::std::option::Option::Some(CpuArmSubType::CPU_SUBTYPE_ARM_V5),
            "CPU_SUBTYPE_ARM_XSCALE" => ::std::option::Option::Some(CpuArmSubType::CPU_SUBTYPE_ARM_XSCALE),
            "CPU_SUBTYPE_ARM_V7" => ::std::option::Option::Some(CpuArmSubType::CPU_SUBTYPE_ARM_V7),
            "CPU_SUBTYPE_ARM_V7F" => ::std::option::Option::Some(CpuArmSubType::CPU_SUBTYPE_ARM_V7F),
            "CPU_SUBTYPE_ARM_V7S" => ::std::option::Option::Some(CpuArmSubType::CPU_SUBTYPE_ARM_V7S),
            "CPU_SUBTYPE_ARM_V7K" => ::std::option::Option::Some(CpuArmSubType::CPU_SUBTYPE_ARM_V7K),
            "CPU_SUBTYPE_ARM_V6M" => ::std::option::Option::Some(CpuArmSubType::CPU_SUBTYPE_ARM_V6M),
            "CPU_SUBTYPE_ARM_V7M" => ::std::option::Option::Some(CpuArmSubType::CPU_SUBTYPE_ARM_V7M),
            "CPU_SUBTYPE_ARM_V7EM" => ::std::option::Option::Some(CpuArmSubType::CPU_SUBTYPE_ARM_V7EM),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CpuArmSubType] = &[
        CpuArmSubType::CPU_SUBTYPE_ARM_ALL,
        CpuArmSubType::CPU_SUBTYPE_ARM_V4T,
        CpuArmSubType::CPU_SUBTYPE_ARM_V6,
        CpuArmSubType::CPU_SUBTYPE_ARM_V5,
        CpuArmSubType::CPU_SUBTYPE_ARM_XSCALE,
        CpuArmSubType::CPU_SUBTYPE_ARM_V7,
        CpuArmSubType::CPU_SUBTYPE_ARM_V7F,
        CpuArmSubType::CPU_SUBTYPE_ARM_V7S,
        CpuArmSubType::CPU_SUBTYPE_ARM_V7K,
        CpuArmSubType::CPU_SUBTYPE_ARM_V6M,
        CpuArmSubType::CPU_SUBTYPE_ARM_V7M,
        CpuArmSubType::CPU_SUBTYPE_ARM_V7EM,
    ];
}

impl ::protobuf::EnumFull for CpuArmSubType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CpuArmSubType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            CpuArmSubType::CPU_SUBTYPE_ARM_ALL => 0,
            CpuArmSubType::CPU_SUBTYPE_ARM_V4T => 1,
            CpuArmSubType::CPU_SUBTYPE_ARM_V6 => 2,
            CpuArmSubType::CPU_SUBTYPE_ARM_V5 => 3,
            CpuArmSubType::CPU_SUBTYPE_ARM_XSCALE => 4,
            CpuArmSubType::CPU_SUBTYPE_ARM_V7 => 5,
            CpuArmSubType::CPU_SUBTYPE_ARM_V7F => 6,
            CpuArmSubType::CPU_SUBTYPE_ARM_V7S => 7,
            CpuArmSubType::CPU_SUBTYPE_ARM_V7K => 8,
            CpuArmSubType::CPU_SUBTYPE_ARM_V6M => 9,
            CpuArmSubType::CPU_SUBTYPE_ARM_V7M => 10,
            CpuArmSubType::CPU_SUBTYPE_ARM_V7EM => 11,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for CpuArmSubType {
    fn default() -> Self {
        CpuArmSubType::CPU_SUBTYPE_ARM_ALL
    }
}

impl CpuArmSubType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CpuArmSubType>("CpuArmSubType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:macho.CpuArm64SubType)
pub enum CpuArm64SubType {
    // @@protoc_insertion_point(enum_value:macho.CpuArm64SubType.CPU_SUBTYPE_ARM_V5TEJ)
    CPU_SUBTYPE_ARM_V5TEJ = 7,
    // @@protoc_insertion_point(enum_value:macho.CpuArm64SubType.CPU_SUBTYPE_ARM64_ALL)
    CPU_SUBTYPE_ARM64_ALL = 0,
}

impl ::protobuf::Enum for CpuArm64SubType {
    const NAME: &'static str = "CpuArm64SubType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CpuArm64SubType> {
        match value {
            7 => ::std::option::Option::Some(CpuArm64SubType::CPU_SUBTYPE_ARM_V5TEJ),
            0 => ::std::option::Option::Some(CpuArm64SubType::CPU_SUBTYPE_ARM64_ALL),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CpuArm64SubType> {
        match str {
            "CPU_SUBTYPE_ARM_V5TEJ" => ::std::option::Option::Some(CpuArm64SubType::CPU_SUBTYPE_ARM_V5TEJ),
            "CPU_SUBTYPE_ARM64_ALL" => ::std::option::Option::Some(CpuArm64SubType::CPU_SUBTYPE_ARM64_ALL),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CpuArm64SubType] = &[
        CpuArm64SubType::CPU_SUBTYPE_ARM_V5TEJ,
        CpuArm64SubType::CPU_SUBTYPE_ARM64_ALL,
    ];
}

impl ::protobuf::EnumFull for CpuArm64SubType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CpuArm64SubType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            CpuArm64SubType::CPU_SUBTYPE_ARM_V5TEJ => 0,
            CpuArm64SubType::CPU_SUBTYPE_ARM64_ALL => 1,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CpuArm64SubType {
    fn default() -> Self {
        CpuArm64SubType::CPU_SUBTYPE_ARM_V5TEJ
    }
}

impl CpuArm64SubType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CpuArm64SubType>("CpuArm64SubType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:macho.CpuSparcSubType)
pub enum CpuSparcSubType {
    // @@protoc_insertion_point(enum_value:macho.CpuSparcSubType.CPU_SUBTYPE_SPARC_ALL)
    CPU_SUBTYPE_SPARC_ALL = 0,
}

impl ::protobuf::Enum for CpuSparcSubType {
    const NAME: &'static str = "CpuSparcSubType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CpuSparcSubType> {
        match value {
            0 => ::std::option::Option::Some(CpuSparcSubType::CPU_SUBTYPE_SPARC_ALL),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CpuSparcSubType> {
        match str {
            "CPU_SUBTYPE_SPARC_ALL" => ::std::option::Option::Some(CpuSparcSubType::CPU_SUBTYPE_SPARC_ALL),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CpuSparcSubType] = &[
        CpuSparcSubType::CPU_SUBTYPE_SPARC_ALL,
    ];
}

impl ::protobuf::EnumFull for CpuSparcSubType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CpuSparcSubType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for CpuSparcSubType {
    fn default() -> Self {
        CpuSparcSubType::CPU_SUBTYPE_SPARC_ALL
    }
}

impl CpuSparcSubType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CpuSparcSubType>("CpuSparcSubType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:macho.CpuPowerPCSubType)
pub enum CpuPowerPCSubType {
    // @@protoc_insertion_point(enum_value:macho.CpuPowerPCSubType.CPU_SUBTYPE_POWERPC_ALL)
    CPU_SUBTYPE_POWERPC_ALL = 0,
    // @@protoc_insertion_point(enum_value:macho.CpuPowerPCSubType.CPU_SUBTYPE_POWERPC_601)
    CPU_SUBTYPE_POWERPC_601 = 1,
    // @@protoc_insertion_point(enum_value:macho.CpuPowerPCSubType.CPU_SUBTYPE_POWERPC_602)
    CPU_SUBTYPE_POWERPC_602 = 2,
    // @@protoc_insertion_point(enum_value:macho.CpuPowerPCSubType.CPU_SUBTYPE_POWERPC_603)
    CPU_SUBTYPE_POWERPC_603 = 3,
    // @@protoc_insertion_point(enum_value:macho.CpuPowerPCSubType.CPU_SUBTYPE_POWERPC_603e)
    CPU_SUBTYPE_POWERPC_603e = 4,
    // @@protoc_insertion_point(enum_value:macho.CpuPowerPCSubType.CPU_SUBTYPE_POWERPC_603ev)
    CPU_SUBTYPE_POWERPC_603ev = 5,
    // @@protoc_insertion_point(enum_value:macho.CpuPowerPCSubType.CPU_SUBTYPE_POWERPC_604)
    CPU_SUBTYPE_POWERPC_604 = 6,
    // @@protoc_insertion_point(enum_value:macho.CpuPowerPCSubType.CPU_SUBTYPE_POWERPC_604e)
    CPU_SUBTYPE_POWERPC_604e = 7,
    // @@protoc_insertion_point(enum_value:macho.CpuPowerPCSubType.CPU_SUBTYPE_POWERPC_620)
    CPU_SUBTYPE_POWERPC_620 = 8,
    // @@protoc_insertion_point(enum_value:macho.CpuPowerPCSubType.CPU_SUBTYPE_POWERPC_750)
    CPU_SUBTYPE_POWERPC_750 = 9,
    // @@protoc_insertion_point(enum_value:macho.CpuPowerPCSubType.CPU_SUBTYPE_POWERPC_7400)
    CPU_SUBTYPE_POWERPC_7400 = 10,
    // @@protoc_insertion_point(enum_value:macho.CpuPowerPCSubType.CPU_SUBTYPE_POWERPC_7450)
    CPU_SUBTYPE_POWERPC_7450 = 11,
    // @@protoc_insertion_point(enum_value:macho.CpuPowerPCSubType.CPU_SUBTYPE_POWERPC_970)
    CPU_SUBTYPE_POWERPC_970 = 100,
}

impl ::protobuf::Enum for CpuPowerPCSubType {
    const NAME: &'static str = "CpuPowerPCSubType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CpuPowerPCSubType> {
        match value {
            0 => ::std::option::Option::Some(CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_ALL),
            1 => ::std::option::Option::Some(CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_601),
            2 => ::std::option::Option::Some(CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_602),
            3 => ::std::option::Option::Some(CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_603),
            4 => ::std::option::Option::Some(CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_603e),
            5 => ::std::option::Option::Some(CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_603ev),
            6 => ::std::option::Option::Some(CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_604),
            7 => ::std::option::Option::Some(CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_604e),
            8 => ::std::option::Option::Some(CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_620),
            9 => ::std::option::Option::Some(CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_750),
            10 => ::std::option::Option::Some(CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_7400),
            11 => ::std::option::Option::Some(CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_7450),
            100 => ::std::option::Option::Some(CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_970),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CpuPowerPCSubType> {
        match str {
            "CPU_SUBTYPE_POWERPC_ALL" => ::std::option::Option::Some(CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_ALL),
            "CPU_SUBTYPE_POWERPC_601" => ::std::option::Option::Some(CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_601),
            "CPU_SUBTYPE_POWERPC_602" => ::std::option::Option::Some(CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_602),
            "CPU_SUBTYPE_POWERPC_603" => ::std::option::Option::Some(CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_603),
            "CPU_SUBTYPE_POWERPC_603e" => ::std::option::Option::Some(CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_603e),
            "CPU_SUBTYPE_POWERPC_603ev" => ::std::option::Option::Some(CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_603ev),
            "CPU_SUBTYPE_POWERPC_604" => ::std::option::Option::Some(CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_604),
            "CPU_SUBTYPE_POWERPC_604e" => ::std::option::Option::Some(CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_604e),
            "CPU_SUBTYPE_POWERPC_620" => ::std::option::Option::Some(CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_620),
            "CPU_SUBTYPE_POWERPC_750" => ::std::option::Option::Some(CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_750),
            "CPU_SUBTYPE_POWERPC_7400" => ::std::option::Option::Some(CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_7400),
            "CPU_SUBTYPE_POWERPC_7450" => ::std::option::Option::Some(CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_7450),
            "CPU_SUBTYPE_POWERPC_970" => ::std::option::Option::Some(CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_970),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CpuPowerPCSubType] = &[
        CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_ALL,
        CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_601,
        CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_602,
        CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_603,
        CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_603e,
        CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_603ev,
        CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_604,
        CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_604e,
        CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_620,
        CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_750,
        CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_7400,
        CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_7450,
        CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_970,
    ];
}

impl ::protobuf::EnumFull for CpuPowerPCSubType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CpuPowerPCSubType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_ALL => 0,
            CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_601 => 1,
            CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_602 => 2,
            CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_603 => 3,
            CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_603e => 4,
            CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_603ev => 5,
            CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_604 => 6,
            CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_604e => 7,
            CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_620 => 8,
            CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_750 => 9,
            CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_7400 => 10,
            CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_7450 => 11,
            CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_970 => 12,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for CpuPowerPCSubType {
    fn default() -> Self {
        CpuPowerPCSubType::CPU_SUBTYPE_POWERPC_ALL
    }
}

impl CpuPowerPCSubType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CpuPowerPCSubType>("CpuPowerPCSubType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:macho.CpuMcSubType)
pub enum CpuMcSubType {
    // @@protoc_insertion_point(enum_value:macho.CpuMcSubType.CPU_SUBTYPE_MC980000_ALL)
    CPU_SUBTYPE_MC980000_ALL = 0,
    // @@protoc_insertion_point(enum_value:macho.CpuMcSubType.CPU_SUBTYPE_MC98601)
    CPU_SUBTYPE_MC98601 = 1,
}

impl ::protobuf::Enum for CpuMcSubType {
    const NAME: &'static str = "CpuMcSubType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CpuMcSubType> {
        match value {
            0 => ::std::option::Option::Some(CpuMcSubType::CPU_SUBTYPE_MC980000_ALL),
            1 => ::std::option::Option::Some(CpuMcSubType::CPU_SUBTYPE_MC98601),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CpuMcSubType> {
        match str {
            "CPU_SUBTYPE_MC980000_ALL" => ::std::option::Option::Some(CpuMcSubType::CPU_SUBTYPE_MC980000_ALL),
            "CPU_SUBTYPE_MC98601" => ::std::option::Option::Some(CpuMcSubType::CPU_SUBTYPE_MC98601),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CpuMcSubType] = &[
        CpuMcSubType::CPU_SUBTYPE_MC980000_ALL,
        CpuMcSubType::CPU_SUBTYPE_MC98601,
    ];
}

impl ::protobuf::EnumFull for CpuMcSubType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CpuMcSubType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for CpuMcSubType {
    fn default() -> Self {
        CpuMcSubType::CPU_SUBTYPE_MC980000_ALL
    }
}

impl CpuMcSubType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CpuMcSubType>("CpuMcSubType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:macho.FileType)
pub enum FileType {
    // @@protoc_insertion_point(enum_value:macho.FileType.MH_OBJECT)
    MH_OBJECT = 1,
    // @@protoc_insertion_point(enum_value:macho.FileType.MH_EXECUTE)
    MH_EXECUTE = 2,
    // @@protoc_insertion_point(enum_value:macho.FileType.MH_FVMLIB)
    MH_FVMLIB = 3,
    // @@protoc_insertion_point(enum_value:macho.FileType.MH_CORE)
    MH_CORE = 4,
    // @@protoc_insertion_point(enum_value:macho.FileType.MH_PRELOAD)
    MH_PRELOAD = 5,
    // @@protoc_insertion_point(enum_value:macho.FileType.MH_DYLIB)
    MH_DYLIB = 6,
    // @@protoc_insertion_point(enum_value:macho.FileType.MH_DYLINKER)
    MH_DYLINKER = 7,
    // @@protoc_insertion_point(enum_value:macho.FileType.MH_BUNDLE)
    MH_BUNDLE = 8,
    // @@protoc_insertion_point(enum_value:macho.FileType.MH_DYLIB_STUB)
    MH_DYLIB_STUB = 9,
    // @@protoc_insertion_point(enum_value:macho.FileType.MH_DSYM)
    MH_DSYM = 10,
    // @@protoc_insertion_point(enum_value:macho.FileType.MH_KEXT_BUNDLE)
    MH_KEXT_BUNDLE = 11,
}

impl ::protobuf::Enum for FileType {
    const NAME: &'static str = "FileType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FileType> {
        match value {
            1 => ::std::option::Option::Some(FileType::MH_OBJECT),
            2 => ::std::option::Option::Some(FileType::MH_EXECUTE),
            3 => ::std::option::Option::Some(FileType::MH_FVMLIB),
            4 => ::std::option::Option::Some(FileType::MH_CORE),
            5 => ::std::option::Option::Some(FileType::MH_PRELOAD),
            6 => ::std::option::Option::Some(FileType::MH_DYLIB),
            7 => ::std::option::Option::Some(FileType::MH_DYLINKER),
            8 => ::std::option::Option::Some(FileType::MH_BUNDLE),
            9 => ::std::option::Option::Some(FileType::MH_DYLIB_STUB),
            10 => ::std::option::Option::Some(FileType::MH_DSYM),
            11 => ::std::option::Option::Some(FileType::MH_KEXT_BUNDLE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<FileType> {
        match str {
            "MH_OBJECT" => ::std::option::Option::Some(FileType::MH_OBJECT),
            "MH_EXECUTE" => ::std::option::Option::Some(FileType::MH_EXECUTE),
            "MH_FVMLIB" => ::std::option::Option::Some(FileType::MH_FVMLIB),
            "MH_CORE" => ::std::option::Option::Some(FileType::MH_CORE),
            "MH_PRELOAD" => ::std::option::Option::Some(FileType::MH_PRELOAD),
            "MH_DYLIB" => ::std::option::Option::Some(FileType::MH_DYLIB),
            "MH_DYLINKER" => ::std::option::Option::Some(FileType::MH_DYLINKER),
            "MH_BUNDLE" => ::std::option::Option::Some(FileType::MH_BUNDLE),
            "MH_DYLIB_STUB" => ::std::option::Option::Some(FileType::MH_DYLIB_STUB),
            "MH_DSYM" => ::std::option::Option::Some(FileType::MH_DSYM),
            "MH_KEXT_BUNDLE" => ::std::option::Option::Some(FileType::MH_KEXT_BUNDLE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [FileType] = &[
        FileType::MH_OBJECT,
        FileType::MH_EXECUTE,
        FileType::MH_FVMLIB,
        FileType::MH_CORE,
        FileType::MH_PRELOAD,
        FileType::MH_DYLIB,
        FileType::MH_DYLINKER,
        FileType::MH_BUNDLE,
        FileType::MH_DYLIB_STUB,
        FileType::MH_DSYM,
        FileType::MH_KEXT_BUNDLE,
    ];
}

impl ::protobuf::EnumFull for FileType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("FileType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            FileType::MH_OBJECT => 0,
            FileType::MH_EXECUTE => 1,
            FileType::MH_FVMLIB => 2,
            FileType::MH_CORE => 3,
            FileType::MH_PRELOAD => 4,
            FileType::MH_DYLIB => 5,
            FileType::MH_DYLINKER => 6,
            FileType::MH_BUNDLE => 7,
            FileType::MH_DYLIB_STUB => 8,
            FileType::MH_DSYM => 9,
            FileType::MH_KEXT_BUNDLE => 10,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for FileType {
    fn default() -> Self {
        FileType::MH_OBJECT
    }
}

impl FileType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<FileType>("FileType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:macho.FileFlag)
pub enum FileFlag {
    // @@protoc_insertion_point(enum_value:macho.FileFlag.MH_NOUNDEFS)
    MH_NOUNDEFS = 1,
    // @@protoc_insertion_point(enum_value:macho.FileFlag.MH_INCRLINK)
    MH_INCRLINK = 2,
    // @@protoc_insertion_point(enum_value:macho.FileFlag.MH_DYLDLINK)
    MH_DYLDLINK = 4,
    // @@protoc_insertion_point(enum_value:macho.FileFlag.MH_BINDATLOAD)
    MH_BINDATLOAD = 8,
    // @@protoc_insertion_point(enum_value:macho.FileFlag.MH_PREBOUND)
    MH_PREBOUND = 16,
    // @@protoc_insertion_point(enum_value:macho.FileFlag.MH_SPLIT_SEGS)
    MH_SPLIT_SEGS = 32,
    // @@protoc_insertion_point(enum_value:macho.FileFlag.MH_LAZY_INIT)
    MH_LAZY_INIT = 64,
    // @@protoc_insertion_point(enum_value:macho.FileFlag.MH_TWOLEVEL)
    MH_TWOLEVEL = 128,
    // @@protoc_insertion_point(enum_value:macho.FileFlag.MH_FORCE_FLAT)
    MH_FORCE_FLAT = 256,
    // @@protoc_insertion_point(enum_value:macho.FileFlag.MH_NOMULTIDEFS)
    MH_NOMULTIDEFS = 512,
    // @@protoc_insertion_point(enum_value:macho.FileFlag.MH_NOFIXPREBINDING)
    MH_NOFIXPREBINDING = 1024,
    // @@protoc_insertion_point(enum_value:macho.FileFlag.MH_PREBINDABLE)
    MH_PREBINDABLE = 2048,
    // @@protoc_insertion_point(enum_value:macho.FileFlag.MH_ALLMODSBOUND)
    MH_ALLMODSBOUND = 4096,
    // @@protoc_insertion_point(enum_value:macho.FileFlag.MH_SUBSECTIONS_VIA_SYMBOLS)
    MH_SUBSECTIONS_VIA_SYMBOLS = 8192,
    // @@protoc_insertion_point(enum_value:macho.FileFlag.MH_CANONICAL)
    MH_CANONICAL = 16384,
    // @@protoc_insertion_point(enum_value:macho.FileFlag.MH_WEAK_DEFINES)
    MH_WEAK_DEFINES = 32768,
    // @@protoc_insertion_point(enum_value:macho.FileFlag.MH_BINDS_TO_WEAK)
    MH_BINDS_TO_WEAK = 65536,
    // @@protoc_insertion_point(enum_value:macho.FileFlag.MH_ALLOW_STACK_EXECUTION)
    MH_ALLOW_STACK_EXECUTION = 131072,
    // @@protoc_insertion_point(enum_value:macho.FileFlag.MH_ROOT_SAFE)
    MH_ROOT_SAFE = 262144,
    // @@protoc_insertion_point(enum_value:macho.FileFlag.MH_SETUID_SAFE)
    MH_SETUID_SAFE = 524288,
    // @@protoc_insertion_point(enum_value:macho.FileFlag.MH_NO_REEXPORTED_DYLIBS)
    MH_NO_REEXPORTED_DYLIBS = 1048576,
    // @@protoc_insertion_point(enum_value:macho.FileFlag.MH_PIE)
    MH_PIE = 2097152,
    // @@protoc_insertion_point(enum_value:macho.FileFlag.MH_DEAD_STRIPPABLE_DYLIB)
    MH_DEAD_STRIPPABLE_DYLIB = 4194304,
    // @@protoc_insertion_point(enum_value:macho.FileFlag.MH_HAS_TLV_DESCRIPTORS)
    MH_HAS_TLV_DESCRIPTORS = 8388608,
    // @@protoc_insertion_point(enum_value:macho.FileFlag.MH_NO_HEAP_EXECUTION)
    MH_NO_HEAP_EXECUTION = 16777216,
    // @@protoc_insertion_point(enum_value:macho.FileFlag.MH_APP_EXTENSION_SAFE)
    MH_APP_EXTENSION_SAFE = 33554432,
}

impl ::protobuf::Enum for FileFlag {
    const NAME: &'static str = "FileFlag";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FileFlag> {
        match value {
            1 => ::std::option::Option::Some(FileFlag::MH_NOUNDEFS),
            2 => ::std::option::Option::Some(FileFlag::MH_INCRLINK),
            4 => ::std::option::Option::Some(FileFlag::MH_DYLDLINK),
            8 => ::std::option::Option::Some(FileFlag::MH_BINDATLOAD),
            16 => ::std::option::Option::Some(FileFlag::MH_PREBOUND),
            32 => ::std::option::Option::Some(FileFlag::MH_SPLIT_SEGS),
            64 => ::std::option::Option::Some(FileFlag::MH_LAZY_INIT),
            128 => ::std::option::Option::Some(FileFlag::MH_TWOLEVEL),
            256 => ::std::option::Option::Some(FileFlag::MH_FORCE_FLAT),
            512 => ::std::option::Option::Some(FileFlag::MH_NOMULTIDEFS),
            1024 => ::std::option::Option::Some(FileFlag::MH_NOFIXPREBINDING),
            2048 => ::std::option::Option::Some(FileFlag::MH_PREBINDABLE),
            4096 => ::std::option::Option::Some(FileFlag::MH_ALLMODSBOUND),
            8192 => ::std::option::Option::Some(FileFlag::MH_SUBSECTIONS_VIA_SYMBOLS),
            16384 => ::std::option::Option::Some(FileFlag::MH_CANONICAL),
            32768 => ::std::option::Option::Some(FileFlag::MH_WEAK_DEFINES),
            65536 => ::std::option::Option::Some(FileFlag::MH_BINDS_TO_WEAK),
            131072 => ::std::option::Option::Some(FileFlag::MH_ALLOW_STACK_EXECUTION),
            262144 => ::std::option::Option::Some(FileFlag::MH_ROOT_SAFE),
            524288 => ::std::option::Option::Some(FileFlag::MH_SETUID_SAFE),
            1048576 => ::std::option::Option::Some(FileFlag::MH_NO_REEXPORTED_DYLIBS),
            2097152 => ::std::option::Option::Some(FileFlag::MH_PIE),
            4194304 => ::std::option::Option::Some(FileFlag::MH_DEAD_STRIPPABLE_DYLIB),
            8388608 => ::std::option::Option::Some(FileFlag::MH_HAS_TLV_DESCRIPTORS),
            16777216 => ::std::option::Option::Some(FileFlag::MH_NO_HEAP_EXECUTION),
            33554432 => ::std::option::Option::Some(FileFlag::MH_APP_EXTENSION_SAFE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<FileFlag> {
        match str {
            "MH_NOUNDEFS" => ::std::option::Option::Some(FileFlag::MH_NOUNDEFS),
            "MH_INCRLINK" => ::std::option::Option::Some(FileFlag::MH_INCRLINK),
            "MH_DYLDLINK" => ::std::option::Option::Some(FileFlag::MH_DYLDLINK),
            "MH_BINDATLOAD" => ::std::option::Option::Some(FileFlag::MH_BINDATLOAD),
            "MH_PREBOUND" => ::std::option::Option::Some(FileFlag::MH_PREBOUND),
            "MH_SPLIT_SEGS" => ::std::option::Option::Some(FileFlag::MH_SPLIT_SEGS),
            "MH_LAZY_INIT" => ::std::option::Option::Some(FileFlag::MH_LAZY_INIT),
            "MH_TWOLEVEL" => ::std::option::Option::Some(FileFlag::MH_TWOLEVEL),
            "MH_FORCE_FLAT" => ::std::option::Option::Some(FileFlag::MH_FORCE_FLAT),
            "MH_NOMULTIDEFS" => ::std::option::Option::Some(FileFlag::MH_NOMULTIDEFS),
            "MH_NOFIXPREBINDING" => ::std::option::Option::Some(FileFlag::MH_NOFIXPREBINDING),
            "MH_PREBINDABLE" => ::std::option::Option::Some(FileFlag::MH_PREBINDABLE),
            "MH_ALLMODSBOUND" => ::std::option::Option::Some(FileFlag::MH_ALLMODSBOUND),
            "MH_SUBSECTIONS_VIA_SYMBOLS" => ::std::option::Option::Some(FileFlag::MH_SUBSECTIONS_VIA_SYMBOLS),
            "MH_CANONICAL" => ::std::option::Option::Some(FileFlag::MH_CANONICAL),
            "MH_WEAK_DEFINES" => ::std::option::Option::Some(FileFlag::MH_WEAK_DEFINES),
            "MH_BINDS_TO_WEAK" => ::std::option::Option::Some(FileFlag::MH_BINDS_TO_WEAK),
            "MH_ALLOW_STACK_EXECUTION" => ::std::option::Option::Some(FileFlag::MH_ALLOW_STACK_EXECUTION),
            "MH_ROOT_SAFE" => ::std::option::Option::Some(FileFlag::MH_ROOT_SAFE),
            "MH_SETUID_SAFE" => ::std::option::Option::Some(FileFlag::MH_SETUID_SAFE),
            "MH_NO_REEXPORTED_DYLIBS" => ::std::option::Option::Some(FileFlag::MH_NO_REEXPORTED_DYLIBS),
            "MH_PIE" => ::std::option::Option::Some(FileFlag::MH_PIE),
            "MH_DEAD_STRIPPABLE_DYLIB" => ::std::option::Option::Some(FileFlag::MH_DEAD_STRIPPABLE_DYLIB),
            "MH_HAS_TLV_DESCRIPTORS" => ::std::option::Option::Some(FileFlag::MH_HAS_TLV_DESCRIPTORS),
            "MH_NO_HEAP_EXECUTION" => ::std::option::Option::Some(FileFlag::MH_NO_HEAP_EXECUTION),
            "MH_APP_EXTENSION_SAFE" => ::std::option::Option::Some(FileFlag::MH_APP_EXTENSION_SAFE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [FileFlag] = &[
        FileFlag::MH_NOUNDEFS,
        FileFlag::MH_INCRLINK,
        FileFlag::MH_DYLDLINK,
        FileFlag::MH_BINDATLOAD,
        FileFlag::MH_PREBOUND,
        FileFlag::MH_SPLIT_SEGS,
        FileFlag::MH_LAZY_INIT,
        FileFlag::MH_TWOLEVEL,
        FileFlag::MH_FORCE_FLAT,
        FileFlag::MH_NOMULTIDEFS,
        FileFlag::MH_NOFIXPREBINDING,
        FileFlag::MH_PREBINDABLE,
        FileFlag::MH_ALLMODSBOUND,
        FileFlag::MH_SUBSECTIONS_VIA_SYMBOLS,
        FileFlag::MH_CANONICAL,
        FileFlag::MH_WEAK_DEFINES,
        FileFlag::MH_BINDS_TO_WEAK,
        FileFlag::MH_ALLOW_STACK_EXECUTION,
        FileFlag::MH_ROOT_SAFE,
        FileFlag::MH_SETUID_SAFE,
        FileFlag::MH_NO_REEXPORTED_DYLIBS,
        FileFlag::MH_PIE,
        FileFlag::MH_DEAD_STRIPPABLE_DYLIB,
        FileFlag::MH_HAS_TLV_DESCRIPTORS,
        FileFlag::MH_NO_HEAP_EXECUTION,
        FileFlag::MH_APP_EXTENSION_SAFE,
    ];
}

impl ::protobuf::EnumFull for FileFlag {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("FileFlag").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            FileFlag::MH_NOUNDEFS => 0,
            FileFlag::MH_INCRLINK => 1,
            FileFlag::MH_DYLDLINK => 2,
            FileFlag::MH_BINDATLOAD => 3,
            FileFlag::MH_PREBOUND => 4,
            FileFlag::MH_SPLIT_SEGS => 5,
            FileFlag::MH_LAZY_INIT => 6,
            FileFlag::MH_TWOLEVEL => 7,
            FileFlag::MH_FORCE_FLAT => 8,
            FileFlag::MH_NOMULTIDEFS => 9,
            FileFlag::MH_NOFIXPREBINDING => 10,
            FileFlag::MH_PREBINDABLE => 11,
            FileFlag::MH_ALLMODSBOUND => 12,
            FileFlag::MH_SUBSECTIONS_VIA_SYMBOLS => 13,
            FileFlag::MH_CANONICAL => 14,
            FileFlag::MH_WEAK_DEFINES => 15,
            FileFlag::MH_BINDS_TO_WEAK => 16,
            FileFlag::MH_ALLOW_STACK_EXECUTION => 17,
            FileFlag::MH_ROOT_SAFE => 18,
            FileFlag::MH_SETUID_SAFE => 19,
            FileFlag::MH_NO_REEXPORTED_DYLIBS => 20,
            FileFlag::MH_PIE => 21,
            FileFlag::MH_DEAD_STRIPPABLE_DYLIB => 22,
            FileFlag::MH_HAS_TLV_DESCRIPTORS => 23,
            FileFlag::MH_NO_HEAP_EXECUTION => 24,
            FileFlag::MH_APP_EXTENSION_SAFE => 25,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for FileFlag {
    fn default() -> Self {
        FileFlag::MH_NOUNDEFS
    }
}

impl FileFlag {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<FileFlag>("FileFlag")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:macho.SegmentFlag)
pub enum SegmentFlag {
    // @@protoc_insertion_point(enum_value:macho.SegmentFlag.SG_HIGHVM)
    SG_HIGHVM = 1,
    // @@protoc_insertion_point(enum_value:macho.SegmentFlag.SG_FVMLIB)
    SG_FVMLIB = 2,
    // @@protoc_insertion_point(enum_value:macho.SegmentFlag.SG_NORELOC)
    SG_NORELOC = 4,
    // @@protoc_insertion_point(enum_value:macho.SegmentFlag.SG_PROTECTED_VERSION_1)
    SG_PROTECTED_VERSION_1 = 8,
}

impl ::protobuf::Enum for SegmentFlag {
    const NAME: &'static str = "SegmentFlag";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SegmentFlag> {
        match value {
            1 => ::std::option::Option::Some(SegmentFlag::SG_HIGHVM),
            2 => ::std::option::Option::Some(SegmentFlag::SG_FVMLIB),
            4 => ::std::option::Option::Some(SegmentFlag::SG_NORELOC),
            8 => ::std::option::Option::Some(SegmentFlag::SG_PROTECTED_VERSION_1),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SegmentFlag> {
        match str {
            "SG_HIGHVM" => ::std::option::Option::Some(SegmentFlag::SG_HIGHVM),
            "SG_FVMLIB" => ::std::option::Option::Some(SegmentFlag::SG_FVMLIB),
            "SG_NORELOC" => ::std::option::Option::Some(SegmentFlag::SG_NORELOC),
            "SG_PROTECTED_VERSION_1" => ::std::option::Option::Some(SegmentFlag::SG_PROTECTED_VERSION_1),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SegmentFlag] = &[
        SegmentFlag::SG_HIGHVM,
        SegmentFlag::SG_FVMLIB,
        SegmentFlag::SG_NORELOC,
        SegmentFlag::SG_PROTECTED_VERSION_1,
    ];
}

impl ::protobuf::EnumFull for SegmentFlag {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SegmentFlag").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            SegmentFlag::SG_HIGHVM => 0,
            SegmentFlag::SG_FVMLIB => 1,
            SegmentFlag::SG_NORELOC => 2,
            SegmentFlag::SG_PROTECTED_VERSION_1 => 3,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for SegmentFlag {
    fn default() -> Self {
        SegmentFlag::SG_HIGHVM
    }
}

impl SegmentFlag {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SegmentFlag>("SegmentFlag")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:macho.SectionFlagMask)
pub enum SectionFlagMask {
    // @@protoc_insertion_point(enum_value:macho.SectionFlagMask.SECTION_TYPE)
    SECTION_TYPE = 255,
    // @@protoc_insertion_point(enum_value:macho.SectionFlagMask.SECTION_ATTRIBUTES)
    SECTION_ATTRIBUTES = 0,
}

impl ::protobuf::Enum for SectionFlagMask {
    const NAME: &'static str = "SectionFlagMask";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SectionFlagMask> {
        match value {
            255 => ::std::option::Option::Some(SectionFlagMask::SECTION_TYPE),
            0 => ::std::option::Option::Some(SectionFlagMask::SECTION_ATTRIBUTES),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SectionFlagMask> {
        match str {
            "SECTION_TYPE" => ::std::option::Option::Some(SectionFlagMask::SECTION_TYPE),
            "SECTION_ATTRIBUTES" => ::std::option::Option::Some(SectionFlagMask::SECTION_ATTRIBUTES),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SectionFlagMask] = &[
        SectionFlagMask::SECTION_TYPE,
        SectionFlagMask::SECTION_ATTRIBUTES,
    ];
}

impl ::protobuf::EnumFull for SectionFlagMask {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SectionFlagMask").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            SectionFlagMask::SECTION_TYPE => 0,
            SectionFlagMask::SECTION_ATTRIBUTES => 1,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for SectionFlagMask {
    fn default() -> Self {
        SectionFlagMask::SECTION_TYPE
    }
}

impl SectionFlagMask {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SectionFlagMask>("SectionFlagMask")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:macho.SectionType)
pub enum SectionType {
    // @@protoc_insertion_point(enum_value:macho.SectionType.S_REGULAR)
    S_REGULAR = 0,
    // @@protoc_insertion_point(enum_value:macho.SectionType.S_ZEROFILL)
    S_ZEROFILL = 1,
    // @@protoc_insertion_point(enum_value:macho.SectionType.S_CSTRING_LITERALS)
    S_CSTRING_LITERALS = 2,
    // @@protoc_insertion_point(enum_value:macho.SectionType.S_4BYTE_LITERALS)
    S_4BYTE_LITERALS = 3,
    // @@protoc_insertion_point(enum_value:macho.SectionType.S_8BYTE_LITERALS)
    S_8BYTE_LITERALS = 4,
    // @@protoc_insertion_point(enum_value:macho.SectionType.S_LITERAL_POINTERS)
    S_LITERAL_POINTERS = 5,
    // @@protoc_insertion_point(enum_value:macho.SectionType.S_NON_LAZY_SYMBOL_POINTERS)
    S_NON_LAZY_SYMBOL_POINTERS = 6,
    // @@protoc_insertion_point(enum_value:macho.SectionType.S_LAZY_SYMBOL_POINTERS)
    S_LAZY_SYMBOL_POINTERS = 7,
    // @@protoc_insertion_point(enum_value:macho.SectionType.S_SYMBOL_STUBS)
    S_SYMBOL_STUBS = 8,
    // @@protoc_insertion_point(enum_value:macho.SectionType.S_MOD_INIT_FUNC_POINTERS)
    S_MOD_INIT_FUNC_POINTERS = 9,
    // @@protoc_insertion_point(enum_value:macho.SectionType.S_MOD_TERM_FUNC_POINTERS)
    S_MOD_TERM_FUNC_POINTERS = 10,
    // @@protoc_insertion_point(enum_value:macho.SectionType.S_COALESCED)
    S_COALESCED = 11,
    // @@protoc_insertion_point(enum_value:macho.SectionType.S_GB_ZEROFILL)
    S_GB_ZEROFILL = 12,
    // @@protoc_insertion_point(enum_value:macho.SectionType.S_INTERPOSING)
    S_INTERPOSING = 13,
    // @@protoc_insertion_point(enum_value:macho.SectionType.S_16BYTE_LITERALS)
    S_16BYTE_LITERALS = 14,
    // @@protoc_insertion_point(enum_value:macho.SectionType.S_DTRACE_DOF)
    S_DTRACE_DOF = 15,
    // @@protoc_insertion_point(enum_value:macho.SectionType.S_LAZY_DYLIB_SYMBOL_POINTERS)
    S_LAZY_DYLIB_SYMBOL_POINTERS = 16,
    // @@protoc_insertion_point(enum_value:macho.SectionType.S_THREAD_LOCAL_REGULAR)
    S_THREAD_LOCAL_REGULAR = 17,
    // @@protoc_insertion_point(enum_value:macho.SectionType.S_THREAD_LOCAL_ZEROFILL)
    S_THREAD_LOCAL_ZEROFILL = 18,
    // @@protoc_insertion_point(enum_value:macho.SectionType.S_THREAD_LOCAL_VARIABLES)
    S_THREAD_LOCAL_VARIABLES = 19,
    // @@protoc_insertion_point(enum_value:macho.SectionType.S_THREAD_LOCAL_VARIABLE_POINTERS)
    S_THREAD_LOCAL_VARIABLE_POINTERS = 20,
    // @@protoc_insertion_point(enum_value:macho.SectionType.S_THREAD_LOCAL_INIT_FUNCTION_POINTERS)
    S_THREAD_LOCAL_INIT_FUNCTION_POINTERS = 21,
}

impl ::protobuf::Enum for SectionType {
    const NAME: &'static str = "SectionType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SectionType> {
        match value {
            0 => ::std::option::Option::Some(SectionType::S_REGULAR),
            1 => ::std::option::Option::Some(SectionType::S_ZEROFILL),
            2 => ::std::option::Option::Some(SectionType::S_CSTRING_LITERALS),
            3 => ::std::option::Option::Some(SectionType::S_4BYTE_LITERALS),
            4 => ::std::option::Option::Some(SectionType::S_8BYTE_LITERALS),
            5 => ::std::option::Option::Some(SectionType::S_LITERAL_POINTERS),
            6 => ::std::option::Option::Some(SectionType::S_NON_LAZY_SYMBOL_POINTERS),
            7 => ::std::option::Option::Some(SectionType::S_LAZY_SYMBOL_POINTERS),
            8 => ::std::option::Option::Some(SectionType::S_SYMBOL_STUBS),
            9 => ::std::option::Option::Some(SectionType::S_MOD_INIT_FUNC_POINTERS),
            10 => ::std::option::Option::Some(SectionType::S_MOD_TERM_FUNC_POINTERS),
            11 => ::std::option::Option::Some(SectionType::S_COALESCED),
            12 => ::std::option::Option::Some(SectionType::S_GB_ZEROFILL),
            13 => ::std::option::Option::Some(SectionType::S_INTERPOSING),
            14 => ::std::option::Option::Some(SectionType::S_16BYTE_LITERALS),
            15 => ::std::option::Option::Some(SectionType::S_DTRACE_DOF),
            16 => ::std::option::Option::Some(SectionType::S_LAZY_DYLIB_SYMBOL_POINTERS),
            17 => ::std::option::Option::Some(SectionType::S_THREAD_LOCAL_REGULAR),
            18 => ::std::option::Option::Some(SectionType::S_THREAD_LOCAL_ZEROFILL),
            19 => ::std::option::Option::Some(SectionType::S_THREAD_LOCAL_VARIABLES),
            20 => ::std::option::Option::Some(SectionType::S_THREAD_LOCAL_VARIABLE_POINTERS),
            21 => ::std::option::Option::Some(SectionType::S_THREAD_LOCAL_INIT_FUNCTION_POINTERS),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SectionType> {
        match str {
            "S_REGULAR" => ::std::option::Option::Some(SectionType::S_REGULAR),
            "S_ZEROFILL" => ::std::option::Option::Some(SectionType::S_ZEROFILL),
            "S_CSTRING_LITERALS" => ::std::option::Option::Some(SectionType::S_CSTRING_LITERALS),
            "S_4BYTE_LITERALS" => ::std::option::Option::Some(SectionType::S_4BYTE_LITERALS),
            "S_8BYTE_LITERALS" => ::std::option::Option::Some(SectionType::S_8BYTE_LITERALS),
            "S_LITERAL_POINTERS" => ::std::option::Option::Some(SectionType::S_LITERAL_POINTERS),
            "S_NON_LAZY_SYMBOL_POINTERS" => ::std::option::Option::Some(SectionType::S_NON_LAZY_SYMBOL_POINTERS),
            "S_LAZY_SYMBOL_POINTERS" => ::std::option::Option::Some(SectionType::S_LAZY_SYMBOL_POINTERS),
            "S_SYMBOL_STUBS" => ::std::option::Option::Some(SectionType::S_SYMBOL_STUBS),
            "S_MOD_INIT_FUNC_POINTERS" => ::std::option::Option::Some(SectionType::S_MOD_INIT_FUNC_POINTERS),
            "S_MOD_TERM_FUNC_POINTERS" => ::std::option::Option::Some(SectionType::S_MOD_TERM_FUNC_POINTERS),
            "S_COALESCED" => ::std::option::Option::Some(SectionType::S_COALESCED),
            "S_GB_ZEROFILL" => ::std::option::Option::Some(SectionType::S_GB_ZEROFILL),
            "S_INTERPOSING" => ::std::option::Option::Some(SectionType::S_INTERPOSING),
            "S_16BYTE_LITERALS" => ::std::option::Option::Some(SectionType::S_16BYTE_LITERALS),
            "S_DTRACE_DOF" => ::std::option::Option::Some(SectionType::S_DTRACE_DOF),
            "S_LAZY_DYLIB_SYMBOL_POINTERS" => ::std::option::Option::Some(SectionType::S_LAZY_DYLIB_SYMBOL_POINTERS),
            "S_THREAD_LOCAL_REGULAR" => ::std::option::Option::Some(SectionType::S_THREAD_LOCAL_REGULAR),
            "S_THREAD_LOCAL_ZEROFILL" => ::std::option::Option::Some(SectionType::S_THREAD_LOCAL_ZEROFILL),
            "S_THREAD_LOCAL_VARIABLES" => ::std::option::Option::Some(SectionType::S_THREAD_LOCAL_VARIABLES),
            "S_THREAD_LOCAL_VARIABLE_POINTERS" => ::std::option::Option::Some(SectionType::S_THREAD_LOCAL_VARIABLE_POINTERS),
            "S_THREAD_LOCAL_INIT_FUNCTION_POINTERS" => ::std::option::Option::Some(SectionType::S_THREAD_LOCAL_INIT_FUNCTION_POINTERS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SectionType] = &[
        SectionType::S_REGULAR,
        SectionType::S_ZEROFILL,
        SectionType::S_CSTRING_LITERALS,
        SectionType::S_4BYTE_LITERALS,
        SectionType::S_8BYTE_LITERALS,
        SectionType::S_LITERAL_POINTERS,
        SectionType::S_NON_LAZY_SYMBOL_POINTERS,
        SectionType::S_LAZY_SYMBOL_POINTERS,
        SectionType::S_SYMBOL_STUBS,
        SectionType::S_MOD_INIT_FUNC_POINTERS,
        SectionType::S_MOD_TERM_FUNC_POINTERS,
        SectionType::S_COALESCED,
        SectionType::S_GB_ZEROFILL,
        SectionType::S_INTERPOSING,
        SectionType::S_16BYTE_LITERALS,
        SectionType::S_DTRACE_DOF,
        SectionType::S_LAZY_DYLIB_SYMBOL_POINTERS,
        SectionType::S_THREAD_LOCAL_REGULAR,
        SectionType::S_THREAD_LOCAL_ZEROFILL,
        SectionType::S_THREAD_LOCAL_VARIABLES,
        SectionType::S_THREAD_LOCAL_VARIABLE_POINTERS,
        SectionType::S_THREAD_LOCAL_INIT_FUNCTION_POINTERS,
    ];
}

impl ::protobuf::EnumFull for SectionType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SectionType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for SectionType {
    fn default() -> Self {
        SectionType::S_REGULAR
    }
}

impl SectionType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SectionType>("SectionType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:macho.SectionAttributes)
pub enum SectionAttributes {
    // @@protoc_insertion_point(enum_value:macho.SectionAttributes.S_ATTR_PURE_INSTRUCTIONS)
    S_ATTR_PURE_INSTRUCTIONS = 0,
    // @@protoc_insertion_point(enum_value:macho.SectionAttributes.S_ATTR_NO_TOC)
    S_ATTR_NO_TOC = 1073741824,
    // @@protoc_insertion_point(enum_value:macho.SectionAttributes.S_ATTR_STRIP_STATIC_SYMS)
    S_ATTR_STRIP_STATIC_SYMS = 536870912,
    // @@protoc_insertion_point(enum_value:macho.SectionAttributes.S_ATTR_NO_DEAD_STRIP)
    S_ATTR_NO_DEAD_STRIP = 268435456,
    // @@protoc_insertion_point(enum_value:macho.SectionAttributes.S_ATTR_LIVE_SUPPORT)
    S_ATTR_LIVE_SUPPORT = 134217728,
    // @@protoc_insertion_point(enum_value:macho.SectionAttributes.S_ATTR_SELF_MODIFYING_CODE)
    S_ATTR_SELF_MODIFYING_CODE = 67108864,
    // @@protoc_insertion_point(enum_value:macho.SectionAttributes.S_ATTR_DEBUG)
    S_ATTR_DEBUG = 33554432,
    // @@protoc_insertion_point(enum_value:macho.SectionAttributes.S_ATTR_SOME_INSTRUCTIONS)
    S_ATTR_SOME_INSTRUCTIONS = 1024,
    // @@protoc_insertion_point(enum_value:macho.SectionAttributes.S_ATTR_EXT_RELOC)
    S_ATTR_EXT_RELOC = 512,
    // @@protoc_insertion_point(enum_value:macho.SectionAttributes.S_ATTR_LOC_RELOC)
    S_ATTR_LOC_RELOC = 256,
}

impl ::protobuf::Enum for SectionAttributes {
    const NAME: &'static str = "SectionAttributes";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SectionAttributes> {
        match value {
            0 => ::std::option::Option::Some(SectionAttributes::S_ATTR_PURE_INSTRUCTIONS),
            1073741824 => ::std::option::Option::Some(SectionAttributes::S_ATTR_NO_TOC),
            536870912 => ::std::option::Option::Some(SectionAttributes::S_ATTR_STRIP_STATIC_SYMS),
            268435456 => ::std::option::Option::Some(SectionAttributes::S_ATTR_NO_DEAD_STRIP),
            134217728 => ::std::option::Option::Some(SectionAttributes::S_ATTR_LIVE_SUPPORT),
            67108864 => ::std::option::Option::Some(SectionAttributes::S_ATTR_SELF_MODIFYING_CODE),
            33554432 => ::std::option::Option::Some(SectionAttributes::S_ATTR_DEBUG),
            1024 => ::std::option::Option::Some(SectionAttributes::S_ATTR_SOME_INSTRUCTIONS),
            512 => ::std::option::Option::Some(SectionAttributes::S_ATTR_EXT_RELOC),
            256 => ::std::option::Option::Some(SectionAttributes::S_ATTR_LOC_RELOC),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SectionAttributes> {
        match str {
            "S_ATTR_PURE_INSTRUCTIONS" => ::std::option::Option::Some(SectionAttributes::S_ATTR_PURE_INSTRUCTIONS),
            "S_ATTR_NO_TOC" => ::std::option::Option::Some(SectionAttributes::S_ATTR_NO_TOC),
            "S_ATTR_STRIP_STATIC_SYMS" => ::std::option::Option::Some(SectionAttributes::S_ATTR_STRIP_STATIC_SYMS),
            "S_ATTR_NO_DEAD_STRIP" => ::std::option::Option::Some(SectionAttributes::S_ATTR_NO_DEAD_STRIP),
            "S_ATTR_LIVE_SUPPORT" => ::std::option::Option::Some(SectionAttributes::S_ATTR_LIVE_SUPPORT),
            "S_ATTR_SELF_MODIFYING_CODE" => ::std::option::Option::Some(SectionAttributes::S_ATTR_SELF_MODIFYING_CODE),
            "S_ATTR_DEBUG" => ::std::option::Option::Some(SectionAttributes::S_ATTR_DEBUG),
            "S_ATTR_SOME_INSTRUCTIONS" => ::std::option::Option::Some(SectionAttributes::S_ATTR_SOME_INSTRUCTIONS),
            "S_ATTR_EXT_RELOC" => ::std::option::Option::Some(SectionAttributes::S_ATTR_EXT_RELOC),
            "S_ATTR_LOC_RELOC" => ::std::option::Option::Some(SectionAttributes::S_ATTR_LOC_RELOC),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SectionAttributes] = &[
        SectionAttributes::S_ATTR_PURE_INSTRUCTIONS,
        SectionAttributes::S_ATTR_NO_TOC,
        SectionAttributes::S_ATTR_STRIP_STATIC_SYMS,
        SectionAttributes::S_ATTR_NO_DEAD_STRIP,
        SectionAttributes::S_ATTR_LIVE_SUPPORT,
        SectionAttributes::S_ATTR_SELF_MODIFYING_CODE,
        SectionAttributes::S_ATTR_DEBUG,
        SectionAttributes::S_ATTR_SOME_INSTRUCTIONS,
        SectionAttributes::S_ATTR_EXT_RELOC,
        SectionAttributes::S_ATTR_LOC_RELOC,
    ];
}

impl ::protobuf::EnumFull for SectionAttributes {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SectionAttributes").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            SectionAttributes::S_ATTR_PURE_INSTRUCTIONS => 0,
            SectionAttributes::S_ATTR_NO_TOC => 1,
            SectionAttributes::S_ATTR_STRIP_STATIC_SYMS => 2,
            SectionAttributes::S_ATTR_NO_DEAD_STRIP => 3,
            SectionAttributes::S_ATTR_LIVE_SUPPORT => 4,
            SectionAttributes::S_ATTR_SELF_MODIFYING_CODE => 5,
            SectionAttributes::S_ATTR_DEBUG => 6,
            SectionAttributes::S_ATTR_SOME_INSTRUCTIONS => 7,
            SectionAttributes::S_ATTR_EXT_RELOC => 8,
            SectionAttributes::S_ATTR_LOC_RELOC => 9,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for SectionAttributes {
    fn default() -> Self {
        SectionAttributes::S_ATTR_PURE_INSTRUCTIONS
    }
}

impl SectionAttributes {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SectionAttributes>("SectionAttributes")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:macho.DeviceType)
pub enum DeviceType {
    // @@protoc_insertion_point(enum_value:macho.DeviceType.MACOSX)
    MACOSX = 36,
    // @@protoc_insertion_point(enum_value:macho.DeviceType.IPHONEOS)
    IPHONEOS = 37,
    // @@protoc_insertion_point(enum_value:macho.DeviceType.TVOS)
    TVOS = 47,
    // @@protoc_insertion_point(enum_value:macho.DeviceType.WATCHOS)
    WATCHOS = 48,
}

impl ::protobuf::Enum for DeviceType {
    const NAME: &'static str = "DeviceType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DeviceType> {
        match value {
            36 => ::std::option::Option::Some(DeviceType::MACOSX),
            37 => ::std::option::Option::Some(DeviceType::IPHONEOS),
            47 => ::std::option::Option::Some(DeviceType::TVOS),
            48 => ::std::option::Option::Some(DeviceType::WATCHOS),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DeviceType> {
        match str {
            "MACOSX" => ::std::option::Option::Some(DeviceType::MACOSX),
            "IPHONEOS" => ::std::option::Option::Some(DeviceType::IPHONEOS),
            "TVOS" => ::std::option::Option::Some(DeviceType::TVOS),
            "WATCHOS" => ::std::option::Option::Some(DeviceType::WATCHOS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DeviceType] = &[
        DeviceType::MACOSX,
        DeviceType::IPHONEOS,
        DeviceType::TVOS,
        DeviceType::WATCHOS,
    ];
}

impl ::protobuf::EnumFull for DeviceType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DeviceType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            DeviceType::MACOSX => 0,
            DeviceType::IPHONEOS => 1,
            DeviceType::TVOS => 2,
            DeviceType::WATCHOS => 3,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for DeviceType {
    fn default() -> Self {
        DeviceType::MACOSX
    }
}

impl DeviceType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DeviceType>("DeviceType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0bmacho.proto\x12\x05macho\x1a\nyara.proto\"c\n\nMinVersion\x12)\n\
    \x06device\x18\x01\x20\x01(\x0e2\x11.macho.DeviceTypeR\x06device\x12\x18\
    \n\x07version\x18\x02\x20\x01(\tR\x07version\x12\x10\n\x03sdk\x18\x03\
    \x20\x01(\tR\x03sdk\"\x92\x01\n\x0cBuildVersion\x12\x1a\n\x08platform\
    \x18\x01\x20\x01(\rR\x08platform\x12\x14\n\x05minos\x18\x02\x20\x01(\tR\
    \x05minos\x12\x10\n\x03sdk\x18\x03\x20\x01(\tR\x03sdk\x12\x16\n\x06ntool\
    s\x18\x04\x20\x01(\rR\x06ntools\x12&\n\x05tools\x18\x05\x20\x03(\x0b2\
    \x10.macho.BuildToolR\x05tools\"9\n\tBuildTool\x12\x12\n\x04tool\x18\x01\
    \x20\x01(\rR\x04tool\x12\x18\n\x07version\x18\x02\x20\x01(\tR\x07version\
    \"D\n\x0cLinkedItData\x12\x18\n\x07dataoff\x18\x01\x20\x01(\rR\x07dataof\
    f\x12\x1a\n\x08datasize\x18\x02\x20\x01(\rR\x08datasize\"e\n\x0bCertific\
    ate\x12\x16\n\x06issuer\x18\x01\x20\x02(\tR\x06issuer\x12\x18\n\x07subje\
    ct\x18\x02\x20\x02(\tR\x07subject\x12$\n\x0eis_self_signed\x18\x03\x20\
    \x02(\x08R\x0cisSelfSigned\"\xa0\x01\n\x05Dylib\x12\x12\n\x04name\x18\
    \x01\x20\x02(\x0cR\x04name\x12%\n\ttimestamp\x18\x02\x20\x02(\rR\ttimest\
    ampB\x07\x82\x93\x19\x03*\x01t\x123\n\x15compatibility_version\x18\x03\
    \x20\x02(\tR\x14compatibilityVersion\x12'\n\x0fcurrent_version\x18\x04\
    \x20\x02(\tR\x0ecurrentVersion\"\xd6\x02\n\x08DyldInfo\x12\x1d\n\nrebase\
    _off\x18\x01\x20\x01(\rR\trebaseOff\x12\x1f\n\x0brebase_size\x18\x02\x20\
    \x01(\rR\nrebaseSize\x12\x19\n\x08bind_off\x18\x03\x20\x01(\rR\x07bindOf\
    f\x12\x1b\n\tbind_size\x18\x04\x20\x01(\rR\x08bindSize\x12\"\n\rweak_bin\
    d_off\x18\x05\x20\x01(\rR\x0bweakBindOff\x12$\n\x0eweak_bind_size\x18\
    \x06\x20\x01(\rR\x0cweakBindSize\x12\"\n\rlazy_bind_off\x18\x07\x20\x01(\
    \rR\x0blazyBindOff\x12$\n\x0elazy_bind_size\x18\x08\x20\x01(\rR\x0clazyB\
    indSize\x12\x1d\n\nexport_off\x18\t\x20\x01(\rR\texportOff\x12\x1f\n\x0b\
    export_size\x18\n\x20\x01(\rR\nexportSize\"|\n\x05Nlist\x12\x15\n\x06n_s\
    trx\x18\x01\x20\x01(\rR\x05nStrx\x12\x15\n\x06n_type\x18\x02\x20\x01(\rR\
    \x05nType\x12\x15\n\x06n_sect\x18\x03\x20\x01(\rR\x05nSect\x12\x15\n\x06\
    n_desc\x18\x04\x20\x01(\rR\x05nDesc\x12\x17\n\x07n_value\x18\x05\x20\x01\
    (\x04R\x06nValue\"\xa8\x01\n\x06Symtab\x12\x16\n\x06symoff\x18\x01\x20\
    \x01(\rR\x06symoff\x12\x14\n\x05nsyms\x18\x02\x20\x01(\rR\x05nsyms\x12\
    \x16\n\x06stroff\x18\x03\x20\x01(\rR\x06stroff\x12\x18\n\x07strsize\x18\
    \x04\x20\x01(\rR\x07strsize\x12\x18\n\x07entries\x18\x05\x20\x03(\x0cR\
    \x07entries\x12$\n\x06nlists\x18\x06\x20\x03(\x0b2\x0c.macho.NlistR\x06n\
    lists\"\xaa\x04\n\x08Dysymtab\x12\x1c\n\tilocalsym\x18\x03\x20\x01(\rR\t\
    ilocalsym\x12\x1c\n\tnlocalsym\x18\x04\x20\x01(\rR\tnlocalsym\x12\x1e\n\
    \niextdefsym\x18\x05\x20\x01(\rR\niextdefsym\x12\x1e\n\nnextdefsym\x18\
    \x06\x20\x01(\rR\nnextdefsym\x12\x1c\n\tiundefsym\x18\x07\x20\x01(\rR\ti\
    undefsym\x12\x1c\n\tnundefsym\x18\x08\x20\x01(\rR\tnundefsym\x12\x16\n\
    \x06tocoff\x18\t\x20\x01(\rR\x06tocoff\x12\x12\n\x04ntoc\x18\n\x20\x01(\
    \rR\x04ntoc\x12\x1c\n\tmodtaboff\x18\x0b\x20\x01(\rR\tmodtaboff\x12\x18\
    \n\x07nmodtab\x18\x0c\x20\x01(\rR\x07nmodtab\x12\"\n\x0cextrefsymoff\x18\
    \r\x20\x01(\rR\x0cextrefsymoff\x12\x20\n\x0bnextrefsyms\x18\x0e\x20\x01(\
    \rR\x0bnextrefsyms\x12&\n\x0eindirectsymoff\x18\x0f\x20\x01(\rR\x0eindir\
    ectsymoff\x12$\n\rnindirectsyms\x18\x10\x20\x01(\rR\rnindirectsyms\x12\
    \x1c\n\textreloff\x18\x11\x20\x01(\rR\textreloff\x12\x18\n\x07nextrel\
    \x18\x12\x20\x01(\rR\x07nextrel\x12\x1c\n\tlocreloff\x18\x13\x20\x01(\rR\
    \tlocreloff\x12\x18\n\x07nlocrel\x18\x14\x20\x01(\rR\x07nlocrel\"\xd0\
    \x02\n\x07Section\x12\x18\n\x07segname\x18\x01\x20\x01(\x0cR\x07segname\
    \x12\x1a\n\x08sectname\x18\x02\x20\x01(\x0cR\x08sectname\x12\x1b\n\x04ad\
    dr\x18\x03\x20\x01(\x04R\x04addrB\x07\x82\x93\x19\x03*\x01x\x12\x1b\n\
    \x04size\x18\x04\x20\x01(\x04R\x04sizeB\x07\x82\x93\x19\x03*\x01x\x12\
    \x16\n\x06offset\x18\x05\x20\x01(\rR\x06offset\x12\x14\n\x05align\x18\
    \x06\x20\x01(\rR\x05align\x12\x16\n\x06reloff\x18\x07\x20\x01(\rR\x06rel\
    off\x12\x16\n\x06nreloc\x18\x08\x20\x01(\rR\x06nreloc\x12\x1d\n\x05flags\
    \x18\t\x20\x01(\rR\x05flagsB\x07\x82\x93\x19\x03*\x01x\x12\x1c\n\treserv\
    ed1\x18\n\x20\x01(\rR\treserved1\x12\x1c\n\treserved2\x18\x0b\x20\x01(\r\
    R\treserved2\x12\x1c\n\treserved3\x18\x0c\x20\x01(\rR\treserved3\"\xd6\
    \x02\n\x07Segment\x12\x18\n\x07segname\x18\x03\x20\x01(\x0cR\x07segname\
    \x12\x1f\n\x06vmaddr\x18\x04\x20\x01(\x04R\x06vmaddrB\x07\x82\x93\x19\
    \x03*\x01x\x12\x1f\n\x06vmsize\x18\x05\x20\x01(\x04R\x06vmsizeB\x07\x82\
    \x93\x19\x03*\x01x\x12\x18\n\x07fileoff\x18\x06\x20\x01(\x04R\x07fileoff\
    \x12\x1a\n\x08filesize\x18\x07\x20\x01(\x04R\x08filesize\x12!\n\x07maxpr\
    ot\x18\x08\x20\x01(\rR\x07maxprotB\x07\x82\x93\x19\x03*\x01x\x12#\n\x08i\
    nitprot\x18\t\x20\x01(\rR\x08initprotB\x07\x82\x93\x19\x03*\x01x\x12\x16\
    \n\x06nsects\x18\n\x20\x01(\rR\x06nsects\x12-\n\x05flags\x18\x0b\x20\x01\
    (\rR\x05flagsB\x17\x82\x93\x19\x13*\x11flags:SegmentFlag\x12*\n\x08secti\
    ons\x18\x0c\x20\x03(\x0b2\x0e.macho.SectionR\x08sections\"\xb3\x01\n\x07\
    FatArch\x12!\n\x07cputype\x18\x01\x20\x01(\rR\x07cputypeB\x07\x82\x93\
    \x19\x03*\x01x\x12'\n\ncpusubtype\x18\x02\x20\x01(\rR\ncpusubtypeB\x07\
    \x82\x93\x19\x03*\x01x\x12\x16\n\x06offset\x18\x03\x20\x01(\x04R\x06offs\
    et\x12\x12\n\x04size\x18\x04\x20\x01(\x04R\x04size\x12\x14\n\x05align\
    \x18\x05\x20\x01(\rR\x05align\x12\x1a\n\x08reserved\x18\x06\x20\x01(\rR\
    \x08reserved\"\x81\t\n\x04File\x12\x1d\n\x05magic\x18\x01\x20\x01(\rR\
    \x05magicB\x07\x82\x93\x19\x03*\x01x\x12!\n\x07cputype\x18\x02\x20\x01(\
    \rR\x07cputypeB\x07\x82\x93\x19\x03*\x01x\x12'\n\ncpusubtype\x18\x03\x20\
    \x01(\rR\ncpusubtypeB\x07\x82\x93\x19\x03*\x01x\x12\x1a\n\x08filetype\
    \x18\x04\x20\x01(\rR\x08filetype\x12\x14\n\x05ncmds\x18\x05\x20\x01(\rR\
    \x05ncmds\x12\x1e\n\nsizeofcmds\x18\x06\x20\x01(\rR\nsizeofcmds\x12*\n\
    \x05flags\x18\x07\x20\x01(\rR\x05flagsB\x14\x82\x93\x19\x10*\x0eflags:Fi\
    leFlag\x12\x1a\n\x08reserved\x18\x08\x20\x01(\rR\x08reserved\x12|\n\x12n\
    umber_of_segments\x18\t\x20\x01(\x04R\x10numberOfSegmentsBN\x82\x93\x19J\
    2H\n\x18this\x20field\x20is\x20deprecated\x12\x1cuse\x20`segments.len()`\
    \x20instead\x1a\x0esegments.len()\x12%\n\x0edynamic_linker\x18\n\x20\x01\
    (\x0cR\rdynamicLinker\x12\x1f\n\x0bentry_point\x18\x0b\x20\x01(\x04R\nen\
    tryPoint\x12\x1d\n\nstack_size\x18\x0c\x20\x01(\x04R\tstackSize\x12%\n\
    \x0esource_version\x18\r\x20\x01(\tR\rsourceVersion\x12*\n\x08segments\
    \x18\x0e\x20\x03(\x0b2\x0e.macho.SegmentR\x08segments\x12$\n\x06dylibs\
    \x18\x0f\x20\x03(\x0b2\x0c.macho.DylibR\x06dylibs\x12\x16\n\x06rpaths\
    \x18\x10\x20\x03(\x0cR\x06rpaths\x12\"\n\x0centitlements\x18\x11\x20\x03\
    (\tR\x0centitlements\x12%\n\x06symtab\x18\x12\x20\x01(\x0b2\r.macho.Symt\
    abR\x06symtab\x12+\n\x08dysymtab\x18\x13\x20\x01(\x0b2\x0f.macho.Dysymta\
    bR\x08dysymtab\x12,\n\tdyld_info\x18\x14\x20\x01(\x0b2\x0f.macho.DyldInf\
    oR\x08dyldInfo\x12C\n\x13code_signature_data\x18\x15\x20\x01(\x0b2\x13.m\
    acho.LinkedItDataR\x11codeSignatureData\x126\n\x0ccertificates\x18\x16\
    \x20\x03(\x0b2\x12.macho.CertificateR\x0ccertificates\x12\x12\n\x04uuid\
    \x18\x17\x20\x01(\tR\x04uuid\x128\n\rbuild_version\x18\x18\x20\x01(\x0b2\
    \x13.macho.BuildVersionR\x0cbuildVersion\x122\n\x0bmin_version\x18\x19\
    \x20\x01(\x0b2\x11.macho.MinVersionR\nminVersion\x12\x18\n\x07exports\
    \x18\x1a\x20\x03(\tR\x07exports\x12\x18\n\x07imports\x18\x1b\x20\x03(\tR\
    \x07imports\x12%\n\x0elinker_options\x18\x1c\x20\x03(\x0cR\rlinkerOption\
    s\"\x8b\n\n\x05Macho\x12\x1d\n\x05magic\x18\x01\x20\x01(\rR\x05magicB\
    \x07\x82\x93\x19\x03*\x01x\x12!\n\x07cputype\x18\x02\x20\x01(\rR\x07cput\
    ypeB\x07\x82\x93\x19\x03*\x01x\x12'\n\ncpusubtype\x18\x03\x20\x01(\rR\nc\
    pusubtypeB\x07\x82\x93\x19\x03*\x01x\x12\x1a\n\x08filetype\x18\x04\x20\
    \x01(\rR\x08filetype\x12\x14\n\x05ncmds\x18\x05\x20\x01(\rR\x05ncmds\x12\
    \x1e\n\nsizeofcmds\x18\x06\x20\x01(\rR\nsizeofcmds\x12\x1d\n\x05flags\
    \x18\x07\x20\x01(\rR\x05flagsB\x07\x82\x93\x19\x03*\x01x\x12\x1a\n\x08re\
    served\x18\x08\x20\x01(\rR\x08reserved\x12\x82\x01\n\x12number_of_segmen\
    ts\x18\t\x20\x01(\x04R\x10numberOfSegmentsBT\x82\x93\x19P2N\n\x18this\
    \x20field\x20is\x20deprecated\x12\"use\x20`macho.segments.len()`\x20inst\
    ead\x1a\x0esegments.len()\x12%\n\x0edynamic_linker\x18\n\x20\x01(\x0cR\r\
    dynamicLinker\x12\x1f\n\x0bentry_point\x18\x0b\x20\x01(\x04R\nentryPoint\
    \x12\x1d\n\nstack_size\x18\x0c\x20\x01(\x04R\tstackSize\x12%\n\x0esource\
    _version\x18\r\x20\x01(\tR\rsourceVersion\x12%\n\x06symtab\x18\x0e\x20\
    \x01(\x0b2\r.macho.SymtabR\x06symtab\x12+\n\x08dysymtab\x18\x0f\x20\x01(\
    \x0b2\x0f.macho.DysymtabR\x08dysymtab\x12C\n\x13code_signature_data\x18\
    \x10\x20\x01(\x0b2\x13.macho.LinkedItDataR\x11codeSignatureData\x12*\n\
    \x08segments\x18\x11\x20\x03(\x0b2\x0e.macho.SegmentR\x08segments\x12$\n\
    \x06dylibs\x18\x12\x20\x03(\x0b2\x0c.macho.DylibR\x06dylibs\x12,\n\tdyld\
    _info\x18\x13\x20\x01(\x0b2\x0f.macho.DyldInfoR\x08dyldInfo\x12\x16\n\
    \x06rpaths\x18\x14\x20\x03(\x0cR\x06rpaths\x12\"\n\x0centitlements\x18\
    \x15\x20\x03(\tR\x0centitlements\x126\n\x0ccertificates\x18\x16\x20\x03(\
    \x0b2\x12.macho.CertificateR\x0ccertificates\x12\x12\n\x04uuid\x18\x17\
    \x20\x01(\tR\x04uuid\x128\n\rbuild_version\x18\x18\x20\x01(\x0b2\x13.mac\
    ho.BuildVersionR\x0cbuildVersion\x122\n\x0bmin_version\x18\x19\x20\x01(\
    \x0b2\x11.macho.MinVersionR\nminVersion\x12\x18\n\x07exports\x18\x1a\x20\
    \x03(\tR\x07exports\x12\x18\n\x07imports\x18\x1b\x20\x03(\tR\x07imports\
    \x12%\n\x0elinker_options\x18\x1c\x20\x03(\x0cR\rlinkerOptions\x12$\n\tf\
    at_magic\x18\x1d\x20\x01(\rR\x08fatMagicB\x07\x82\x93\x19\x03*\x01x\x12\
    \x1b\n\tnfat_arch\x18\x1e\x20\x01(\rR\x08nfatArch\x12)\n\x08fat_arch\x18\
    \x1f\x20\x03(\x0b2\x0e.macho.FatArchR\x07fatArch\x12\x1f\n\x04file\x18\
    \x20\x20\x03(\x0b2\x0b.macho.FileR\x04file*~\n\x06Header\x12\x18\n\x08MH\
    _MAGIC\x10\0\x1a\n\x9a\x93\x19\x06\x08\xce\xf5\xb7\xf7\x0f\x12\x18\n\x08\
    MH_CIGAM\x10\x01\x1a\n\x9a\x93\x19\x06\x08\xfe\xdb\xeb\xf7\x0c\x12\x1b\n\
    \x0bMH_MAGIC_64\x10\x02\x1a\n\x9a\x93\x19\x06\x08\xcf\xf5\xb7\xf7\x0f\
    \x12\x1b\n\x0bMH_CIGAM_64\x10\x03\x1a\n\x9a\x93\x19\x06\x08\xfe\xdb\xeb\
    \xff\x0c\x1a\x06\x92\x93\x19\x02\x10\x01*\x85\x01\n\tFatHeader\x12\x19\n\
    \tFAT_MAGIC\x10\0\x1a\n\x9a\x93\x19\x06\x08\xbe\xf5\xfa\xd7\x0c\x12\x19\
    \n\tFAT_CIGAM\x10\x01\x1a\n\x9a\x93\x19\x06\x08\xca\xfd\xeb\xf5\x0b\x12\
    \x1c\n\x0cFAT_MAGIC_64\x10\x02\x1a\n\x9a\x93\x19\x06\x08\xbf\xf5\xfa\xd7\
    \x0c\x12\x1c\n\x0cFAT_CIGAM_64\x10\x03\x1a\n\x9a\x93\x19\x06\x08\xca\xfd\
    \xeb\xfd\x0b\x1a\x06\x92\x93\x19\x02\x10\x01*M\n\tMask64Bit\x12\x15\n\
    \x0eCPU_ARCH_ABI64\x10\x80\x80\x80\x08\x12!\n\x11CPU_SUBTYPE_LIB64\x10\0\
    \x1a\n\x9a\x93\x19\x06\x08\x80\x80\x80\x80\x08\x1a\x06\x92\x93\x19\x02\
    \x10\x01*\xfe\x01\n\x07CpuType\x12\x14\n\x10CPU_TYPE_MC680X0\x10\x06\x12\
    \x10\n\x0cCPU_TYPE_X86\x10\x07\x12\x16\n\x0fCPU_TYPE_X86_64\x10\x87\x80\
    \x80\x08\x12\x11\n\rCPU_TYPE_MIPS\x10\x08\x12\x14\n\x10CPU_TYPE_MC98000\
    \x10\n\x12\x10\n\x0cCPU_TYPE_ARM\x10\x0c\x12\x15\n\x0eCPU_TYPE_ARM64\x10\
    \x8c\x80\x80\x08\x12\x14\n\x10CPU_TYPE_MC88000\x10\r\x12\x12\n\x0eCPU_TY\
    PE_SPARC\x10\x0e\x12\x14\n\x10CPU_TYPE_POWERPC\x10\x12\x12\x19\n\x12CPU_\
    TYPE_POWERPC64\x10\x92\x80\x80\x08\x1a\x06\x92\x93\x19\x02\x10\x01*(\n\
    \x0bCpuI386Type\x12\x11\n\rCPU_TYPE_I386\x10\x07\x1a\x06\x92\x93\x19\x02\
    \x10\x01*\xad\x02\n\x0fCpuIntelSubType\x12\x1f\n\x1bCPU_SUBTYPE_INTEL_MO\
    DEL_ALL\x10\0\x12\x13\n\x0fCPU_SUBTYPE_386\x10\x03\x12\x13\n\x0fCPU_SUBT\
    YPE_486\x10\x04\x12\x16\n\x11CPU_SUBTYPE_486SX\x10\x84\x01\x12\x13\n\x0f\
    CPU_SUBTYPE_586\x10\x05\x12\x17\n\x13CPU_SUBTYPE_CELERON\x10g\x12\x1e\n\
    \x1aCPU_SUBTYPE_CELERON_MOBILE\x10w\x12\x17\n\x13CPU_SUBTYPE_ITANIUM\x10\
    \x0b\x12\x19\n\x15CPU_SUBTYPE_ITANIUM_2\x10\x1b\x12\x14\n\x10CPU_SUBTYPE\
    _XEON\x10\x0c\x12\x17\n\x13CPU_SUBTYPE_XEON_MP\x10\x1c\x1a\x06\x92\x93\
    \x19\x02\x10\x01*2\n\x0eCpuI386SubType\x12\x18\n\x14CPU_SUBTYPE_I386_ALL\
    \x10\x03\x1a\x06\x92\x93\x19\x02\x10\x01*3\n\rCpuX86SubType\x12\x1a\n\
    \x16CPU_SUBTYPE_X86_64_ALL\x10\x03\x1a\x06\x92\x93\x19\x02\x10\x01*\xb0\
    \x02\n\x16CpuIntelPentiumSubType\x12\x14\n\x10CPU_SUBTYPE_PENT\x10\x05\
    \x12\x17\n\x13CPU_SUBTYPE_PENTPRO\x10\x16\x12\x19\n\x15CPU_SUBTYPE_PENTI\
    I_M3\x106\x12\x19\n\x15CPU_SUBTYPE_PENTII_M5\x10V\x12\x19\n\x15CPU_SUBTY\
    PE_PENTIUM_3\x10\x08\x12\x1b\n\x17CPU_SUBTYPE_PENTIUM_3_M\x10\x18\x12\
    \x1e\n\x1aCPU_SUBTYPE_PENTIUM_3_XEON\x10(\x12\x19\n\x15CPU_SUBTYPE_PENTI\
    UM_M\x10\t\x12\x19\n\x15CPU_SUBTYPE_PENTIUM_4\x10\n\x12\x1b\n\x17CPU_SUB\
    TYPE_PENTIUM_4_M\x10\x1a\x1a\x06\x92\x93\x19\x02\x10\x01*\xc4\x02\n\rCpu\
    ArmSubType\x12\x17\n\x13CPU_SUBTYPE_ARM_ALL\x10\0\x12\x17\n\x13CPU_SUBTY\
    PE_ARM_V4T\x10\x05\x12\x16\n\x12CPU_SUBTYPE_ARM_V6\x10\x06\x12\x16\n\x12\
    CPU_SUBTYPE_ARM_V5\x10\x07\x12\x1a\n\x16CPU_SUBTYPE_ARM_XSCALE\x10\x08\
    \x12\x16\n\x12CPU_SUBTYPE_ARM_V7\x10\t\x12\x17\n\x13CPU_SUBTYPE_ARM_V7F\
    \x10\n\x12\x17\n\x13CPU_SUBTYPE_ARM_V7S\x10\x0b\x12\x17\n\x13CPU_SUBTYPE\
    _ARM_V7K\x10\x0c\x12\x17\n\x13CPU_SUBTYPE_ARM_V6M\x10\x0e\x12\x17\n\x13C\
    PU_SUBTYPE_ARM_V7M\x10\x0f\x12\x18\n\x14CPU_SUBTYPE_ARM_V7EM\x10\x10\x1a\
    \x06\x92\x93\x19\x02\x10\x01*O\n\x0fCpuArm64SubType\x12\x19\n\x15CPU_SUB\
    TYPE_ARM_V5TEJ\x10\x07\x12\x19\n\x15CPU_SUBTYPE_ARM64_ALL\x10\0\x1a\x06\
    \x92\x93\x19\x02\x10\x01*4\n\x0fCpuSparcSubType\x12\x19\n\x15CPU_SUBTYPE\
    _SPARC_ALL\x10\0\x1a\x06\x92\x93\x19\x02\x10\x01*\x9a\x03\n\x11CpuPowerP\
    CSubType\x12\x1b\n\x17CPU_SUBTYPE_POWERPC_ALL\x10\0\x12\x1b\n\x17CPU_SUB\
    TYPE_POWERPC_601\x10\x01\x12\x1b\n\x17CPU_SUBTYPE_POWERPC_602\x10\x02\
    \x12\x1b\n\x17CPU_SUBTYPE_POWERPC_603\x10\x03\x12\x1c\n\x18CPU_SUBTYPE_P\
    OWERPC_603e\x10\x04\x12\x1d\n\x19CPU_SUBTYPE_POWERPC_603ev\x10\x05\x12\
    \x1b\n\x17CPU_SUBTYPE_POWERPC_604\x10\x06\x12\x1c\n\x18CPU_SUBTYPE_POWER\
    PC_604e\x10\x07\x12\x1b\n\x17CPU_SUBTYPE_POWERPC_620\x10\x08\x12\x1b\n\
    \x17CPU_SUBTYPE_POWERPC_750\x10\t\x12\x1c\n\x18CPU_SUBTYPE_POWERPC_7400\
    \x10\n\x12\x1c\n\x18CPU_SUBTYPE_POWERPC_7450\x10\x0b\x12\x1b\n\x17CPU_SU\
    BTYPE_POWERPC_970\x10d\x1a\x06\x92\x93\x19\x02\x10\x01*M\n\x0cCpuMcSubTy\
    pe\x12\x1c\n\x18CPU_SUBTYPE_MC980000_ALL\x10\0\x12\x17\n\x13CPU_SUBTYPE_\
    MC98601\x10\x01\x1a\x06\x92\x93\x19\x02\x10\x01*\xbf\x01\n\x08FileType\
    \x12\r\n\tMH_OBJECT\x10\x01\x12\x0e\n\nMH_EXECUTE\x10\x02\x12\r\n\tMH_FV\
    MLIB\x10\x03\x12\x0b\n\x07MH_CORE\x10\x04\x12\x0e\n\nMH_PRELOAD\x10\x05\
    \x12\x0c\n\x08MH_DYLIB\x10\x06\x12\x0f\n\x0bMH_DYLINKER\x10\x07\x12\r\n\
    \tMH_BUNDLE\x10\x08\x12\x11\n\rMH_DYLIB_STUB\x10\t\x12\x0b\n\x07MH_DSYM\
    \x10\n\x12\x12\n\x0eMH_KEXT_BUNDLE\x10\x0b\x1a\x06\x92\x93\x19\x02\x10\
    \x01*\xe4\x04\n\x08FileFlag\x12\x0f\n\x0bMH_NOUNDEFS\x10\x01\x12\x0f\n\
    \x0bMH_INCRLINK\x10\x02\x12\x0f\n\x0bMH_DYLDLINK\x10\x04\x12\x11\n\rMH_B\
    INDATLOAD\x10\x08\x12\x0f\n\x0bMH_PREBOUND\x10\x10\x12\x11\n\rMH_SPLIT_S\
    EGS\x10\x20\x12\x10\n\x0cMH_LAZY_INIT\x10@\x12\x10\n\x0bMH_TWOLEVEL\x10\
    \x80\x01\x12\x12\n\rMH_FORCE_FLAT\x10\x80\x02\x12\x13\n\x0eMH_NOMULTIDEF\
    S\x10\x80\x04\x12\x17\n\x12MH_NOFIXPREBINDING\x10\x80\x08\x12\x13\n\x0eM\
    H_PREBINDABLE\x10\x80\x10\x12\x14\n\x0fMH_ALLMODSBOUND\x10\x80\x20\x12\
    \x1f\n\x1aMH_SUBSECTIONS_VIA_SYMBOLS\x10\x80@\x12\x12\n\x0cMH_CANONICAL\
    \x10\x80\x80\x01\x12\x15\n\x0fMH_WEAK_DEFINES\x10\x80\x80\x02\x12\x16\n\
    \x10MH_BINDS_TO_WEAK\x10\x80\x80\x04\x12\x1e\n\x18MH_ALLOW_STACK_EXECUTI\
    ON\x10\x80\x80\x08\x12\x12\n\x0cMH_ROOT_SAFE\x10\x80\x80\x10\x12\x14\n\
    \x0eMH_SETUID_SAFE\x10\x80\x80\x20\x12\x1d\n\x17MH_NO_REEXPORTED_DYLIBS\
    \x10\x80\x80@\x12\r\n\x06MH_PIE\x10\x80\x80\x80\x01\x12\x1f\n\x18MH_DEAD\
    _STRIPPABLE_DYLIB\x10\x80\x80\x80\x02\x12\x1d\n\x16MH_HAS_TLV_DESCRIPTOR\
    S\x10\x80\x80\x80\x04\x12\x1b\n\x14MH_NO_HEAP_EXECUTION\x10\x80\x80\x80\
    \x08\x12\x1c\n\x15MH_APP_EXTENSION_SAFE\x10\x80\x80\x80\x10\x1a\x06\x92\
    \x93\x19\x02\x10\x01*_\n\x0bSegmentFlag\x12\r\n\tSG_HIGHVM\x10\x01\x12\r\
    \n\tSG_FVMLIB\x10\x02\x12\x0e\n\nSG_NORELOC\x10\x04\x12\x1a\n\x16SG_PROT\
    ECTED_VERSION_1\x10\x08\x1a\x06\x92\x93\x19\x02\x10\x01*P\n\x0fSectionFl\
    agMask\x12\x11\n\x0cSECTION_TYPE\x10\xff\x01\x12\"\n\x12SECTION_ATTRIBUT\
    ES\x10\0\x1a\n\x9a\x93\x19\x06\x08\x80\xfe\xff\xff\x0f\x1a\x06\x92\x93\
    \x19\x02\x10\x01*\xc6\x04\n\x0bSectionType\x12\r\n\tS_REGULAR\x10\0\x12\
    \x0e\n\nS_ZEROFILL\x10\x01\x12\x16\n\x12S_CSTRING_LITERALS\x10\x02\x12\
    \x14\n\x10S_4BYTE_LITERALS\x10\x03\x12\x14\n\x10S_8BYTE_LITERALS\x10\x04\
    \x12\x16\n\x12S_LITERAL_POINTERS\x10\x05\x12\x1e\n\x1aS_NON_LAZY_SYMBOL_\
    POINTERS\x10\x06\x12\x1a\n\x16S_LAZY_SYMBOL_POINTERS\x10\x07\x12\x12\n\
    \x0eS_SYMBOL_STUBS\x10\x08\x12\x1c\n\x18S_MOD_INIT_FUNC_POINTERS\x10\t\
    \x12\x1c\n\x18S_MOD_TERM_FUNC_POINTERS\x10\n\x12\x0f\n\x0bS_COALESCED\
    \x10\x0b\x12\x11\n\rS_GB_ZEROFILL\x10\x0c\x12\x11\n\rS_INTERPOSING\x10\r\
    \x12\x15\n\x11S_16BYTE_LITERALS\x10\x0e\x12\x10\n\x0cS_DTRACE_DOF\x10\
    \x0f\x12\x20\n\x1cS_LAZY_DYLIB_SYMBOL_POINTERS\x10\x10\x12\x1a\n\x16S_TH\
    READ_LOCAL_REGULAR\x10\x11\x12\x1b\n\x17S_THREAD_LOCAL_ZEROFILL\x10\x12\
    \x12\x1c\n\x18S_THREAD_LOCAL_VARIABLES\x10\x13\x12$\n\x20S_THREAD_LOCAL_\
    VARIABLE_POINTERS\x10\x14\x12)\n%S_THREAD_LOCAL_INIT_FUNCTION_POINTERS\
    \x10\x15\x1a\x06\x92\x93\x19\x02\x10\x01*\xbd\x02\n\x11SectionAttributes\
    \x12(\n\x18S_ATTR_PURE_INSTRUCTIONS\x10\0\x1a\n\x9a\x93\x19\x06\x08\x80\
    \x80\x80\x80\x08\x12\x15\n\rS_ATTR_NO_TOC\x10\x80\x80\x80\x80\x04\x12\
    \x20\n\x18S_ATTR_STRIP_STATIC_SYMS\x10\x80\x80\x80\x80\x02\x12\x1c\n\x14\
    S_ATTR_NO_DEAD_STRIP\x10\x80\x80\x80\x80\x01\x12\x1a\n\x13S_ATTR_LIVE_SU\
    PPORT\x10\x80\x80\x80@\x12!\n\x1aS_ATTR_SELF_MODIFYING_CODE\x10\x80\x80\
    \x80\x20\x12\x13\n\x0cS_ATTR_DEBUG\x10\x80\x80\x80\x10\x12\x1d\n\x18S_AT\
    TR_SOME_INSTRUCTIONS\x10\x80\x08\x12\x15\n\x10S_ATTR_EXT_RELOC\x10\x80\
    \x04\x12\x15\n\x10S_ATTR_LOC_RELOC\x10\x80\x02\x1a\x06\x92\x93\x19\x02\
    \x10\x01*E\n\nDeviceType\x12\n\n\x06MACOSX\x10$\x12\x0c\n\x08IPHONEOS\
    \x10%\x12\x08\n\x04TVOS\x10/\x12\x0b\n\x07WATCHOS\x100\x1a\x06\x92\x93\
    \x19\x02\x10\x01B-\xfa\x92\x19)\n\x05macho\x12\x0bmacho.Macho\x1a\x05mac\
    ho\"\x0cmacho-moduleb\x06proto2\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::yara::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(15);
            messages.push(MinVersion::generated_message_descriptor_data());
            messages.push(BuildVersion::generated_message_descriptor_data());
            messages.push(BuildTool::generated_message_descriptor_data());
            messages.push(LinkedItData::generated_message_descriptor_data());
            messages.push(Certificate::generated_message_descriptor_data());
            messages.push(Dylib::generated_message_descriptor_data());
            messages.push(DyldInfo::generated_message_descriptor_data());
            messages.push(Nlist::generated_message_descriptor_data());
            messages.push(Symtab::generated_message_descriptor_data());
            messages.push(Dysymtab::generated_message_descriptor_data());
            messages.push(Section::generated_message_descriptor_data());
            messages.push(Segment::generated_message_descriptor_data());
            messages.push(FatArch::generated_message_descriptor_data());
            messages.push(File::generated_message_descriptor_data());
            messages.push(Macho::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(21);
            enums.push(Header::generated_enum_descriptor_data());
            enums.push(FatHeader::generated_enum_descriptor_data());
            enums.push(Mask64Bit::generated_enum_descriptor_data());
            enums.push(CpuType::generated_enum_descriptor_data());
            enums.push(CpuI386Type::generated_enum_descriptor_data());
            enums.push(CpuIntelSubType::generated_enum_descriptor_data());
            enums.push(CpuI386SubType::generated_enum_descriptor_data());
            enums.push(CpuX86SubType::generated_enum_descriptor_data());
            enums.push(CpuIntelPentiumSubType::generated_enum_descriptor_data());
            enums.push(CpuArmSubType::generated_enum_descriptor_data());
            enums.push(CpuArm64SubType::generated_enum_descriptor_data());
            enums.push(CpuSparcSubType::generated_enum_descriptor_data());
            enums.push(CpuPowerPCSubType::generated_enum_descriptor_data());
            enums.push(CpuMcSubType::generated_enum_descriptor_data());
            enums.push(FileType::generated_enum_descriptor_data());
            enums.push(FileFlag::generated_enum_descriptor_data());
            enums.push(SegmentFlag::generated_enum_descriptor_data());
            enums.push(SectionFlagMask::generated_enum_descriptor_data());
            enums.push(SectionType::generated_enum_descriptor_data());
            enums.push(SectionAttributes::generated_enum_descriptor_data());
            enums.push(DeviceType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
