// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `test_proto2.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

// @@protoc_insertion_point(message:test_proto2.TestProto2)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TestProto2 {
    // message fields
    // @@protoc_insertion_point(field:test_proto2.TestProto2.int32_zero)
    pub int32_zero: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.int64_zero)
    pub int64_zero: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.sint32_zero)
    pub sint32_zero: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.sint64_zero)
    pub sint64_zero: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.uint32_zero)
    pub uint32_zero: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.uint64_zero)
    pub uint64_zero: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.fixed32_zero)
    pub fixed32_zero: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.fixed64_zero)
    pub fixed64_zero: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.sfixed32_zero)
    pub sfixed32_zero: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.sfixed64_zero)
    pub sfixed64_zero: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.float_zero)
    pub float_zero: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.double_zero)
    pub double_zero: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.int32_one)
    pub int32_one: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.int64_one)
    pub int64_one: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.sint32_one)
    pub sint32_one: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.sint64_one)
    pub sint64_one: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.uint32_one)
    pub uint32_one: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.uint64_one)
    pub uint64_one: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.fixed32_one)
    pub fixed32_one: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.fixed64_one)
    pub fixed64_one: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.sfixed32_one)
    pub sfixed32_one: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.sfixed64_one)
    pub sfixed64_one: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.float_one)
    pub float_one: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.double_one)
    pub double_one: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.int32_undef)
    pub int32_undef: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.int64_undef)
    pub int64_undef: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.sint32_undef)
    pub sint32_undef: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.sint64_undef)
    pub sint64_undef: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.uint32_undef)
    pub uint32_undef: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.uint64_undef)
    pub uint64_undef: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.fixed32_undef)
    pub fixed32_undef: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.fixed64_undef)
    pub fixed64_undef: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.sfixed32_undef)
    pub sfixed32_undef: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.sfixed64_undef)
    pub sfixed64_undef: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.float_undef)
    pub float_undef: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.double_undef)
    pub double_undef: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.string_foo)
    pub string_foo: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.string_bar)
    pub string_bar: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.string_undef)
    pub string_undef: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.bytes_foo)
    pub bytes_foo: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.bytes_bar)
    pub bytes_bar: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.bytes_raw)
    pub bytes_raw: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.bytes_undef)
    pub bytes_undef: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.enumeration)
    pub enumeration: ::std::option::Option<::protobuf::EnumOrUnknown<test_proto2::Enumeration>>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.nested)
    pub nested: ::protobuf::MessageField<NestedProto2>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.array_int64)
    pub array_int64: ::std::vec::Vec<i64>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.array_float)
    pub array_float: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.array_bool)
    pub array_bool: ::std::vec::Vec<bool>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.array_string)
    pub array_string: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.array_struct)
    pub array_struct: ::std::vec::Vec<NestedProto2>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.map_string_struct)
    pub map_string_struct: ::std::collections::HashMap<::std::string::String, NestedProto2>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.map_string_int64)
    pub map_string_int64: ::std::collections::HashMap<::std::string::String, i64>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.map_string_string)
    pub map_string_string: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.map_string_bool)
    pub map_string_bool: ::std::collections::HashMap<::std::string::String, bool>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.map_string_float)
    pub map_string_float: ::std::collections::HashMap<::std::string::String, f32>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.map_int64_struct)
    pub map_int64_struct: ::std::collections::HashMap<i64, NestedProto2>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.map_int64_int64)
    pub map_int64_int64: ::std::collections::HashMap<i64, i64>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.map_int64_string)
    pub map_int64_string: ::std::collections::HashMap<i64, ::std::string::String>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.map_int64_bool)
    pub map_int64_bool: ::std::collections::HashMap<i64, bool>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.map_int64_float)
    pub map_int64_float: ::std::collections::HashMap<i64, f32>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.timestamp)
    pub timestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.bool_proto)
    pub bool_proto: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.ignored)
    pub ignored: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.file_size)
    pub file_size: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.requires_foo_and_bar)
    pub requires_foo_and_bar: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.deprecated)
    pub deprecated: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:test_proto2.TestProto2.metadata)
    pub metadata: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:test_proto2.TestProto2.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TestProto2 {
    fn default() -> &'a TestProto2 {
        <TestProto2 as ::protobuf::Message>::default_instance()
    }
}

impl TestProto2 {
    pub fn new() -> TestProto2 {
        ::std::default::Default::default()
    }

    // required int32 int32_zero = 1;

    pub fn int32_zero(&self) -> i32 {
        self.int32_zero.unwrap_or(0)
    }

    pub fn clear_int32_zero(&mut self) {
        self.int32_zero = ::std::option::Option::None;
    }

    pub fn has_int32_zero(&self) -> bool {
        self.int32_zero.is_some()
    }

    // Param is passed by value, moved
    pub fn set_int32_zero(&mut self, v: i32) {
        self.int32_zero = ::std::option::Option::Some(v);
    }

    // required int64 int64_zero = 2;

    pub fn int64_zero(&self) -> i64 {
        self.int64_zero.unwrap_or(0)
    }

    pub fn clear_int64_zero(&mut self) {
        self.int64_zero = ::std::option::Option::None;
    }

    pub fn has_int64_zero(&self) -> bool {
        self.int64_zero.is_some()
    }

    // Param is passed by value, moved
    pub fn set_int64_zero(&mut self, v: i64) {
        self.int64_zero = ::std::option::Option::Some(v);
    }

    // required sint32 sint32_zero = 3;

    pub fn sint32_zero(&self) -> i32 {
        self.sint32_zero.unwrap_or(0)
    }

    pub fn clear_sint32_zero(&mut self) {
        self.sint32_zero = ::std::option::Option::None;
    }

    pub fn has_sint32_zero(&self) -> bool {
        self.sint32_zero.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sint32_zero(&mut self, v: i32) {
        self.sint32_zero = ::std::option::Option::Some(v);
    }

    // required sint64 sint64_zero = 4;

    pub fn sint64_zero(&self) -> i64 {
        self.sint64_zero.unwrap_or(0)
    }

    pub fn clear_sint64_zero(&mut self) {
        self.sint64_zero = ::std::option::Option::None;
    }

    pub fn has_sint64_zero(&self) -> bool {
        self.sint64_zero.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sint64_zero(&mut self, v: i64) {
        self.sint64_zero = ::std::option::Option::Some(v);
    }

    // required uint32 uint32_zero = 5;

    pub fn uint32_zero(&self) -> u32 {
        self.uint32_zero.unwrap_or(0)
    }

    pub fn clear_uint32_zero(&mut self) {
        self.uint32_zero = ::std::option::Option::None;
    }

    pub fn has_uint32_zero(&self) -> bool {
        self.uint32_zero.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uint32_zero(&mut self, v: u32) {
        self.uint32_zero = ::std::option::Option::Some(v);
    }

    // required uint64 uint64_zero = 6;

    pub fn uint64_zero(&self) -> u64 {
        self.uint64_zero.unwrap_or(0)
    }

    pub fn clear_uint64_zero(&mut self) {
        self.uint64_zero = ::std::option::Option::None;
    }

    pub fn has_uint64_zero(&self) -> bool {
        self.uint64_zero.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uint64_zero(&mut self, v: u64) {
        self.uint64_zero = ::std::option::Option::Some(v);
    }

    // required fixed32 fixed32_zero = 7;

    pub fn fixed32_zero(&self) -> u32 {
        self.fixed32_zero.unwrap_or(0)
    }

    pub fn clear_fixed32_zero(&mut self) {
        self.fixed32_zero = ::std::option::Option::None;
    }

    pub fn has_fixed32_zero(&self) -> bool {
        self.fixed32_zero.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fixed32_zero(&mut self, v: u32) {
        self.fixed32_zero = ::std::option::Option::Some(v);
    }

    // required fixed64 fixed64_zero = 8;

    pub fn fixed64_zero(&self) -> u64 {
        self.fixed64_zero.unwrap_or(0)
    }

    pub fn clear_fixed64_zero(&mut self) {
        self.fixed64_zero = ::std::option::Option::None;
    }

    pub fn has_fixed64_zero(&self) -> bool {
        self.fixed64_zero.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fixed64_zero(&mut self, v: u64) {
        self.fixed64_zero = ::std::option::Option::Some(v);
    }

    // required sfixed32 sfixed32_zero = 9;

    pub fn sfixed32_zero(&self) -> i32 {
        self.sfixed32_zero.unwrap_or(0)
    }

    pub fn clear_sfixed32_zero(&mut self) {
        self.sfixed32_zero = ::std::option::Option::None;
    }

    pub fn has_sfixed32_zero(&self) -> bool {
        self.sfixed32_zero.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sfixed32_zero(&mut self, v: i32) {
        self.sfixed32_zero = ::std::option::Option::Some(v);
    }

    // required sfixed64 sfixed64_zero = 10;

    pub fn sfixed64_zero(&self) -> i64 {
        self.sfixed64_zero.unwrap_or(0)
    }

    pub fn clear_sfixed64_zero(&mut self) {
        self.sfixed64_zero = ::std::option::Option::None;
    }

    pub fn has_sfixed64_zero(&self) -> bool {
        self.sfixed64_zero.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sfixed64_zero(&mut self, v: i64) {
        self.sfixed64_zero = ::std::option::Option::Some(v);
    }

    // required float float_zero = 11;

    pub fn float_zero(&self) -> f32 {
        self.float_zero.unwrap_or(0.)
    }

    pub fn clear_float_zero(&mut self) {
        self.float_zero = ::std::option::Option::None;
    }

    pub fn has_float_zero(&self) -> bool {
        self.float_zero.is_some()
    }

    // Param is passed by value, moved
    pub fn set_float_zero(&mut self, v: f32) {
        self.float_zero = ::std::option::Option::Some(v);
    }

    // required double double_zero = 12;

    pub fn double_zero(&self) -> f64 {
        self.double_zero.unwrap_or(0.)
    }

    pub fn clear_double_zero(&mut self) {
        self.double_zero = ::std::option::Option::None;
    }

    pub fn has_double_zero(&self) -> bool {
        self.double_zero.is_some()
    }

    // Param is passed by value, moved
    pub fn set_double_zero(&mut self, v: f64) {
        self.double_zero = ::std::option::Option::Some(v);
    }

    // required int32 int32_one = 21;

    pub fn int32_one(&self) -> i32 {
        self.int32_one.unwrap_or(0)
    }

    pub fn clear_int32_one(&mut self) {
        self.int32_one = ::std::option::Option::None;
    }

    pub fn has_int32_one(&self) -> bool {
        self.int32_one.is_some()
    }

    // Param is passed by value, moved
    pub fn set_int32_one(&mut self, v: i32) {
        self.int32_one = ::std::option::Option::Some(v);
    }

    // required int64 int64_one = 22;

    pub fn int64_one(&self) -> i64 {
        self.int64_one.unwrap_or(0)
    }

    pub fn clear_int64_one(&mut self) {
        self.int64_one = ::std::option::Option::None;
    }

    pub fn has_int64_one(&self) -> bool {
        self.int64_one.is_some()
    }

    // Param is passed by value, moved
    pub fn set_int64_one(&mut self, v: i64) {
        self.int64_one = ::std::option::Option::Some(v);
    }

    // required sint32 sint32_one = 23;

    pub fn sint32_one(&self) -> i32 {
        self.sint32_one.unwrap_or(0)
    }

    pub fn clear_sint32_one(&mut self) {
        self.sint32_one = ::std::option::Option::None;
    }

    pub fn has_sint32_one(&self) -> bool {
        self.sint32_one.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sint32_one(&mut self, v: i32) {
        self.sint32_one = ::std::option::Option::Some(v);
    }

    // required sint64 sint64_one = 24;

    pub fn sint64_one(&self) -> i64 {
        self.sint64_one.unwrap_or(0)
    }

    pub fn clear_sint64_one(&mut self) {
        self.sint64_one = ::std::option::Option::None;
    }

    pub fn has_sint64_one(&self) -> bool {
        self.sint64_one.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sint64_one(&mut self, v: i64) {
        self.sint64_one = ::std::option::Option::Some(v);
    }

    // required uint32 uint32_one = 25;

    pub fn uint32_one(&self) -> u32 {
        self.uint32_one.unwrap_or(0)
    }

    pub fn clear_uint32_one(&mut self) {
        self.uint32_one = ::std::option::Option::None;
    }

    pub fn has_uint32_one(&self) -> bool {
        self.uint32_one.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uint32_one(&mut self, v: u32) {
        self.uint32_one = ::std::option::Option::Some(v);
    }

    // required uint64 uint64_one = 26;

    pub fn uint64_one(&self) -> u64 {
        self.uint64_one.unwrap_or(0)
    }

    pub fn clear_uint64_one(&mut self) {
        self.uint64_one = ::std::option::Option::None;
    }

    pub fn has_uint64_one(&self) -> bool {
        self.uint64_one.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uint64_one(&mut self, v: u64) {
        self.uint64_one = ::std::option::Option::Some(v);
    }

    // required fixed32 fixed32_one = 27;

    pub fn fixed32_one(&self) -> u32 {
        self.fixed32_one.unwrap_or(0)
    }

    pub fn clear_fixed32_one(&mut self) {
        self.fixed32_one = ::std::option::Option::None;
    }

    pub fn has_fixed32_one(&self) -> bool {
        self.fixed32_one.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fixed32_one(&mut self, v: u32) {
        self.fixed32_one = ::std::option::Option::Some(v);
    }

    // required fixed64 fixed64_one = 28;

    pub fn fixed64_one(&self) -> u64 {
        self.fixed64_one.unwrap_or(0)
    }

    pub fn clear_fixed64_one(&mut self) {
        self.fixed64_one = ::std::option::Option::None;
    }

    pub fn has_fixed64_one(&self) -> bool {
        self.fixed64_one.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fixed64_one(&mut self, v: u64) {
        self.fixed64_one = ::std::option::Option::Some(v);
    }

    // required sfixed32 sfixed32_one = 29;

    pub fn sfixed32_one(&self) -> i32 {
        self.sfixed32_one.unwrap_or(0)
    }

    pub fn clear_sfixed32_one(&mut self) {
        self.sfixed32_one = ::std::option::Option::None;
    }

    pub fn has_sfixed32_one(&self) -> bool {
        self.sfixed32_one.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sfixed32_one(&mut self, v: i32) {
        self.sfixed32_one = ::std::option::Option::Some(v);
    }

    // required sfixed64 sfixed64_one = 30;

    pub fn sfixed64_one(&self) -> i64 {
        self.sfixed64_one.unwrap_or(0)
    }

    pub fn clear_sfixed64_one(&mut self) {
        self.sfixed64_one = ::std::option::Option::None;
    }

    pub fn has_sfixed64_one(&self) -> bool {
        self.sfixed64_one.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sfixed64_one(&mut self, v: i64) {
        self.sfixed64_one = ::std::option::Option::Some(v);
    }

    // required float float_one = 31;

    pub fn float_one(&self) -> f32 {
        self.float_one.unwrap_or(0.)
    }

    pub fn clear_float_one(&mut self) {
        self.float_one = ::std::option::Option::None;
    }

    pub fn has_float_one(&self) -> bool {
        self.float_one.is_some()
    }

    // Param is passed by value, moved
    pub fn set_float_one(&mut self, v: f32) {
        self.float_one = ::std::option::Option::Some(v);
    }

    // required double double_one = 32;

    pub fn double_one(&self) -> f64 {
        self.double_one.unwrap_or(0.)
    }

    pub fn clear_double_one(&mut self) {
        self.double_one = ::std::option::Option::None;
    }

    pub fn has_double_one(&self) -> bool {
        self.double_one.is_some()
    }

    // Param is passed by value, moved
    pub fn set_double_one(&mut self, v: f64) {
        self.double_one = ::std::option::Option::Some(v);
    }

    // optional int32 int32_undef = 41;

    pub fn int32_undef(&self) -> i32 {
        self.int32_undef.unwrap_or(0)
    }

    pub fn clear_int32_undef(&mut self) {
        self.int32_undef = ::std::option::Option::None;
    }

    pub fn has_int32_undef(&self) -> bool {
        self.int32_undef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_int32_undef(&mut self, v: i32) {
        self.int32_undef = ::std::option::Option::Some(v);
    }

    // optional int64 int64_undef = 42;

    pub fn int64_undef(&self) -> i64 {
        self.int64_undef.unwrap_or(0)
    }

    pub fn clear_int64_undef(&mut self) {
        self.int64_undef = ::std::option::Option::None;
    }

    pub fn has_int64_undef(&self) -> bool {
        self.int64_undef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_int64_undef(&mut self, v: i64) {
        self.int64_undef = ::std::option::Option::Some(v);
    }

    // optional sint32 sint32_undef = 43;

    pub fn sint32_undef(&self) -> i32 {
        self.sint32_undef.unwrap_or(0)
    }

    pub fn clear_sint32_undef(&mut self) {
        self.sint32_undef = ::std::option::Option::None;
    }

    pub fn has_sint32_undef(&self) -> bool {
        self.sint32_undef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sint32_undef(&mut self, v: i32) {
        self.sint32_undef = ::std::option::Option::Some(v);
    }

    // optional sint64 sint64_undef = 44;

    pub fn sint64_undef(&self) -> i64 {
        self.sint64_undef.unwrap_or(0)
    }

    pub fn clear_sint64_undef(&mut self) {
        self.sint64_undef = ::std::option::Option::None;
    }

    pub fn has_sint64_undef(&self) -> bool {
        self.sint64_undef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sint64_undef(&mut self, v: i64) {
        self.sint64_undef = ::std::option::Option::Some(v);
    }

    // optional uint32 uint32_undef = 45;

    pub fn uint32_undef(&self) -> u32 {
        self.uint32_undef.unwrap_or(0)
    }

    pub fn clear_uint32_undef(&mut self) {
        self.uint32_undef = ::std::option::Option::None;
    }

    pub fn has_uint32_undef(&self) -> bool {
        self.uint32_undef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uint32_undef(&mut self, v: u32) {
        self.uint32_undef = ::std::option::Option::Some(v);
    }

    // optional uint64 uint64_undef = 46;

    pub fn uint64_undef(&self) -> u64 {
        self.uint64_undef.unwrap_or(0)
    }

    pub fn clear_uint64_undef(&mut self) {
        self.uint64_undef = ::std::option::Option::None;
    }

    pub fn has_uint64_undef(&self) -> bool {
        self.uint64_undef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uint64_undef(&mut self, v: u64) {
        self.uint64_undef = ::std::option::Option::Some(v);
    }

    // optional fixed32 fixed32_undef = 47;

    pub fn fixed32_undef(&self) -> u32 {
        self.fixed32_undef.unwrap_or(0)
    }

    pub fn clear_fixed32_undef(&mut self) {
        self.fixed32_undef = ::std::option::Option::None;
    }

    pub fn has_fixed32_undef(&self) -> bool {
        self.fixed32_undef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fixed32_undef(&mut self, v: u32) {
        self.fixed32_undef = ::std::option::Option::Some(v);
    }

    // optional fixed64 fixed64_undef = 48;

    pub fn fixed64_undef(&self) -> u64 {
        self.fixed64_undef.unwrap_or(0)
    }

    pub fn clear_fixed64_undef(&mut self) {
        self.fixed64_undef = ::std::option::Option::None;
    }

    pub fn has_fixed64_undef(&self) -> bool {
        self.fixed64_undef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fixed64_undef(&mut self, v: u64) {
        self.fixed64_undef = ::std::option::Option::Some(v);
    }

    // optional sfixed32 sfixed32_undef = 49;

    pub fn sfixed32_undef(&self) -> i32 {
        self.sfixed32_undef.unwrap_or(0)
    }

    pub fn clear_sfixed32_undef(&mut self) {
        self.sfixed32_undef = ::std::option::Option::None;
    }

    pub fn has_sfixed32_undef(&self) -> bool {
        self.sfixed32_undef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sfixed32_undef(&mut self, v: i32) {
        self.sfixed32_undef = ::std::option::Option::Some(v);
    }

    // optional sfixed64 sfixed64_undef = 50;

    pub fn sfixed64_undef(&self) -> i64 {
        self.sfixed64_undef.unwrap_or(0)
    }

    pub fn clear_sfixed64_undef(&mut self) {
        self.sfixed64_undef = ::std::option::Option::None;
    }

    pub fn has_sfixed64_undef(&self) -> bool {
        self.sfixed64_undef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sfixed64_undef(&mut self, v: i64) {
        self.sfixed64_undef = ::std::option::Option::Some(v);
    }

    // optional float float_undef = 51;

    pub fn float_undef(&self) -> f32 {
        self.float_undef.unwrap_or(0.)
    }

    pub fn clear_float_undef(&mut self) {
        self.float_undef = ::std::option::Option::None;
    }

    pub fn has_float_undef(&self) -> bool {
        self.float_undef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_float_undef(&mut self, v: f32) {
        self.float_undef = ::std::option::Option::Some(v);
    }

    // optional double double_undef = 52;

    pub fn double_undef(&self) -> f64 {
        self.double_undef.unwrap_or(0.)
    }

    pub fn clear_double_undef(&mut self) {
        self.double_undef = ::std::option::Option::None;
    }

    pub fn has_double_undef(&self) -> bool {
        self.double_undef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_double_undef(&mut self, v: f64) {
        self.double_undef = ::std::option::Option::Some(v);
    }

    // required string string_foo = 61;

    pub fn string_foo(&self) -> &str {
        match self.string_foo.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_string_foo(&mut self) {
        self.string_foo = ::std::option::Option::None;
    }

    pub fn has_string_foo(&self) -> bool {
        self.string_foo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_foo(&mut self, v: ::std::string::String) {
        self.string_foo = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_foo(&mut self) -> &mut ::std::string::String {
        if self.string_foo.is_none() {
            self.string_foo = ::std::option::Option::Some(::std::string::String::new());
        }
        self.string_foo.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_foo(&mut self) -> ::std::string::String {
        self.string_foo.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string string_bar = 62;

    pub fn string_bar(&self) -> &str {
        match self.string_bar.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_string_bar(&mut self) {
        self.string_bar = ::std::option::Option::None;
    }

    pub fn has_string_bar(&self) -> bool {
        self.string_bar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_bar(&mut self, v: ::std::string::String) {
        self.string_bar = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_bar(&mut self) -> &mut ::std::string::String {
        if self.string_bar.is_none() {
            self.string_bar = ::std::option::Option::Some(::std::string::String::new());
        }
        self.string_bar.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_bar(&mut self) -> ::std::string::String {
        self.string_bar.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string string_undef = 63;

    pub fn string_undef(&self) -> &str {
        match self.string_undef.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_string_undef(&mut self) {
        self.string_undef = ::std::option::Option::None;
    }

    pub fn has_string_undef(&self) -> bool {
        self.string_undef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_undef(&mut self, v: ::std::string::String) {
        self.string_undef = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_undef(&mut self) -> &mut ::std::string::String {
        if self.string_undef.is_none() {
            self.string_undef = ::std::option::Option::Some(::std::string::String::new());
        }
        self.string_undef.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_undef(&mut self) -> ::std::string::String {
        self.string_undef.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required bytes bytes_foo = 64;

    pub fn bytes_foo(&self) -> &[u8] {
        match self.bytes_foo.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_bytes_foo(&mut self) {
        self.bytes_foo = ::std::option::Option::None;
    }

    pub fn has_bytes_foo(&self) -> bool {
        self.bytes_foo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_foo(&mut self, v: ::std::vec::Vec<u8>) {
        self.bytes_foo = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bytes_foo(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.bytes_foo.is_none() {
            self.bytes_foo = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.bytes_foo.as_mut().unwrap()
    }

    // Take field
    pub fn take_bytes_foo(&mut self) -> ::std::vec::Vec<u8> {
        self.bytes_foo.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes bytes_bar = 65;

    pub fn bytes_bar(&self) -> &[u8] {
        match self.bytes_bar.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_bytes_bar(&mut self) {
        self.bytes_bar = ::std::option::Option::None;
    }

    pub fn has_bytes_bar(&self) -> bool {
        self.bytes_bar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_bar(&mut self, v: ::std::vec::Vec<u8>) {
        self.bytes_bar = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bytes_bar(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.bytes_bar.is_none() {
            self.bytes_bar = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.bytes_bar.as_mut().unwrap()
    }

    // Take field
    pub fn take_bytes_bar(&mut self) -> ::std::vec::Vec<u8> {
        self.bytes_bar.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes bytes_raw = 66;

    pub fn bytes_raw(&self) -> &[u8] {
        match self.bytes_raw.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_bytes_raw(&mut self) {
        self.bytes_raw = ::std::option::Option::None;
    }

    pub fn has_bytes_raw(&self) -> bool {
        self.bytes_raw.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_raw(&mut self, v: ::std::vec::Vec<u8>) {
        self.bytes_raw = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bytes_raw(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.bytes_raw.is_none() {
            self.bytes_raw = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.bytes_raw.as_mut().unwrap()
    }

    // Take field
    pub fn take_bytes_raw(&mut self) -> ::std::vec::Vec<u8> {
        self.bytes_raw.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes bytes_undef = 67;

    pub fn bytes_undef(&self) -> &[u8] {
        match self.bytes_undef.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_bytes_undef(&mut self) {
        self.bytes_undef = ::std::option::Option::None;
    }

    pub fn has_bytes_undef(&self) -> bool {
        self.bytes_undef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_undef(&mut self, v: ::std::vec::Vec<u8>) {
        self.bytes_undef = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bytes_undef(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.bytes_undef.is_none() {
            self.bytes_undef = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.bytes_undef.as_mut().unwrap()
    }

    // Take field
    pub fn take_bytes_undef(&mut self) -> ::std::vec::Vec<u8> {
        self.bytes_undef.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .test_proto2.TestProto2.Enumeration enumeration = 100;

    pub fn enumeration(&self) -> test_proto2::Enumeration {
        match self.enumeration {
            Some(e) => e.enum_value_or(test_proto2::Enumeration::ITEM_0),
            None => test_proto2::Enumeration::ITEM_0,
        }
    }

    pub fn clear_enumeration(&mut self) {
        self.enumeration = ::std::option::Option::None;
    }

    pub fn has_enumeration(&self) -> bool {
        self.enumeration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enumeration(&mut self, v: test_proto2::Enumeration) {
        self.enumeration = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int64 timestamp = 305;

    pub fn timestamp(&self) -> i64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional bool bool_proto = 350;

    pub fn bool_proto(&self) -> bool {
        self.bool_proto.unwrap_or(false)
    }

    pub fn clear_bool_proto(&mut self) {
        self.bool_proto = ::std::option::Option::None;
    }

    pub fn has_bool_proto(&self) -> bool {
        self.bool_proto.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bool_proto(&mut self, v: bool) {
        self.bool_proto = ::std::option::Option::Some(v);
    }

    // optional bool ignored = 351;

    pub fn ignored(&self) -> bool {
        self.ignored.unwrap_or(false)
    }

    pub fn clear_ignored(&mut self) {
        self.ignored = ::std::option::Option::None;
    }

    pub fn has_ignored(&self) -> bool {
        self.ignored.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ignored(&mut self, v: bool) {
        self.ignored = ::std::option::Option::Some(v);
    }

    // optional uint64 file_size = 400;

    pub fn file_size(&self) -> u64 {
        self.file_size.unwrap_or(0)
    }

    pub fn clear_file_size(&mut self) {
        self.file_size = ::std::option::Option::None;
    }

    pub fn has_file_size(&self) -> bool {
        self.file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: u64) {
        self.file_size = ::std::option::Option::Some(v);
    }

    // optional uint64 requires_foo_and_bar = 500;

    pub fn requires_foo_and_bar(&self) -> u64 {
        self.requires_foo_and_bar.unwrap_or(0)
    }

    pub fn clear_requires_foo_and_bar(&mut self) {
        self.requires_foo_and_bar = ::std::option::Option::None;
    }

    pub fn has_requires_foo_and_bar(&self) -> bool {
        self.requires_foo_and_bar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requires_foo_and_bar(&mut self, v: u64) {
        self.requires_foo_and_bar = ::std::option::Option::Some(v);
    }

    // optional string deprecated = 501;

    pub fn deprecated(&self) -> &str {
        match self.deprecated.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_deprecated(&mut self) {
        self.deprecated = ::std::option::Option::None;
    }

    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated(&mut self, v: ::std::string::String) {
        self.deprecated = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deprecated(&mut self) -> &mut ::std::string::String {
        if self.deprecated.is_none() {
            self.deprecated = ::std::option::Option::Some(::std::string::String::new());
        }
        self.deprecated.as_mut().unwrap()
    }

    // Take field
    pub fn take_deprecated(&mut self) -> ::std::string::String {
        self.deprecated.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes metadata = 502;

    pub fn metadata(&self) -> &[u8] {
        match self.metadata.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_metadata(&mut self) {
        self.metadata = ::std::option::Option::None;
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
        self.metadata = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.metadata.is_none() {
            self.metadata = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
        self.metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(67);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "int32_zero",
            |m: &TestProto2| { &m.int32_zero },
            |m: &mut TestProto2| { &mut m.int32_zero },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "int64_zero",
            |m: &TestProto2| { &m.int64_zero },
            |m: &mut TestProto2| { &mut m.int64_zero },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sint32_zero",
            |m: &TestProto2| { &m.sint32_zero },
            |m: &mut TestProto2| { &mut m.sint32_zero },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sint64_zero",
            |m: &TestProto2| { &m.sint64_zero },
            |m: &mut TestProto2| { &mut m.sint64_zero },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uint32_zero",
            |m: &TestProto2| { &m.uint32_zero },
            |m: &mut TestProto2| { &mut m.uint32_zero },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uint64_zero",
            |m: &TestProto2| { &m.uint64_zero },
            |m: &mut TestProto2| { &mut m.uint64_zero },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fixed32_zero",
            |m: &TestProto2| { &m.fixed32_zero },
            |m: &mut TestProto2| { &mut m.fixed32_zero },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fixed64_zero",
            |m: &TestProto2| { &m.fixed64_zero },
            |m: &mut TestProto2| { &mut m.fixed64_zero },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sfixed32_zero",
            |m: &TestProto2| { &m.sfixed32_zero },
            |m: &mut TestProto2| { &mut m.sfixed32_zero },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sfixed64_zero",
            |m: &TestProto2| { &m.sfixed64_zero },
            |m: &mut TestProto2| { &mut m.sfixed64_zero },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "float_zero",
            |m: &TestProto2| { &m.float_zero },
            |m: &mut TestProto2| { &mut m.float_zero },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "double_zero",
            |m: &TestProto2| { &m.double_zero },
            |m: &mut TestProto2| { &mut m.double_zero },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "int32_one",
            |m: &TestProto2| { &m.int32_one },
            |m: &mut TestProto2| { &mut m.int32_one },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "int64_one",
            |m: &TestProto2| { &m.int64_one },
            |m: &mut TestProto2| { &mut m.int64_one },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sint32_one",
            |m: &TestProto2| { &m.sint32_one },
            |m: &mut TestProto2| { &mut m.sint32_one },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sint64_one",
            |m: &TestProto2| { &m.sint64_one },
            |m: &mut TestProto2| { &mut m.sint64_one },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uint32_one",
            |m: &TestProto2| { &m.uint32_one },
            |m: &mut TestProto2| { &mut m.uint32_one },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uint64_one",
            |m: &TestProto2| { &m.uint64_one },
            |m: &mut TestProto2| { &mut m.uint64_one },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fixed32_one",
            |m: &TestProto2| { &m.fixed32_one },
            |m: &mut TestProto2| { &mut m.fixed32_one },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fixed64_one",
            |m: &TestProto2| { &m.fixed64_one },
            |m: &mut TestProto2| { &mut m.fixed64_one },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sfixed32_one",
            |m: &TestProto2| { &m.sfixed32_one },
            |m: &mut TestProto2| { &mut m.sfixed32_one },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sfixed64_one",
            |m: &TestProto2| { &m.sfixed64_one },
            |m: &mut TestProto2| { &mut m.sfixed64_one },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "float_one",
            |m: &TestProto2| { &m.float_one },
            |m: &mut TestProto2| { &mut m.float_one },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "double_one",
            |m: &TestProto2| { &m.double_one },
            |m: &mut TestProto2| { &mut m.double_one },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "int32_undef",
            |m: &TestProto2| { &m.int32_undef },
            |m: &mut TestProto2| { &mut m.int32_undef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "int64_undef",
            |m: &TestProto2| { &m.int64_undef },
            |m: &mut TestProto2| { &mut m.int64_undef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sint32_undef",
            |m: &TestProto2| { &m.sint32_undef },
            |m: &mut TestProto2| { &mut m.sint32_undef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sint64_undef",
            |m: &TestProto2| { &m.sint64_undef },
            |m: &mut TestProto2| { &mut m.sint64_undef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uint32_undef",
            |m: &TestProto2| { &m.uint32_undef },
            |m: &mut TestProto2| { &mut m.uint32_undef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uint64_undef",
            |m: &TestProto2| { &m.uint64_undef },
            |m: &mut TestProto2| { &mut m.uint64_undef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fixed32_undef",
            |m: &TestProto2| { &m.fixed32_undef },
            |m: &mut TestProto2| { &mut m.fixed32_undef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fixed64_undef",
            |m: &TestProto2| { &m.fixed64_undef },
            |m: &mut TestProto2| { &mut m.fixed64_undef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sfixed32_undef",
            |m: &TestProto2| { &m.sfixed32_undef },
            |m: &mut TestProto2| { &mut m.sfixed32_undef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sfixed64_undef",
            |m: &TestProto2| { &m.sfixed64_undef },
            |m: &mut TestProto2| { &mut m.sfixed64_undef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "float_undef",
            |m: &TestProto2| { &m.float_undef },
            |m: &mut TestProto2| { &mut m.float_undef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "double_undef",
            |m: &TestProto2| { &m.double_undef },
            |m: &mut TestProto2| { &mut m.double_undef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "string_foo",
            |m: &TestProto2| { &m.string_foo },
            |m: &mut TestProto2| { &mut m.string_foo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "string_bar",
            |m: &TestProto2| { &m.string_bar },
            |m: &mut TestProto2| { &mut m.string_bar },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "string_undef",
            |m: &TestProto2| { &m.string_undef },
            |m: &mut TestProto2| { &mut m.string_undef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bytes_foo",
            |m: &TestProto2| { &m.bytes_foo },
            |m: &mut TestProto2| { &mut m.bytes_foo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bytes_bar",
            |m: &TestProto2| { &m.bytes_bar },
            |m: &mut TestProto2| { &mut m.bytes_bar },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bytes_raw",
            |m: &TestProto2| { &m.bytes_raw },
            |m: &mut TestProto2| { &mut m.bytes_raw },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bytes_undef",
            |m: &TestProto2| { &m.bytes_undef },
            |m: &mut TestProto2| { &mut m.bytes_undef },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "enumeration",
            |m: &TestProto2| { &m.enumeration },
            |m: &mut TestProto2| { &mut m.enumeration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NestedProto2>(
            "nested",
            |m: &TestProto2| { &m.nested },
            |m: &mut TestProto2| { &mut m.nested },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "array_int64",
            |m: &TestProto2| { &m.array_int64 },
            |m: &mut TestProto2| { &mut m.array_int64 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "array_float",
            |m: &TestProto2| { &m.array_float },
            |m: &mut TestProto2| { &mut m.array_float },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "array_bool",
            |m: &TestProto2| { &m.array_bool },
            |m: &mut TestProto2| { &mut m.array_bool },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "array_string",
            |m: &TestProto2| { &m.array_string },
            |m: &mut TestProto2| { &mut m.array_string },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "array_struct",
            |m: &TestProto2| { &m.array_struct },
            |m: &mut TestProto2| { &mut m.array_struct },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "map_string_struct",
            |m: &TestProto2| { &m.map_string_struct },
            |m: &mut TestProto2| { &mut m.map_string_struct },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "map_string_int64",
            |m: &TestProto2| { &m.map_string_int64 },
            |m: &mut TestProto2| { &mut m.map_string_int64 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "map_string_string",
            |m: &TestProto2| { &m.map_string_string },
            |m: &mut TestProto2| { &mut m.map_string_string },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "map_string_bool",
            |m: &TestProto2| { &m.map_string_bool },
            |m: &mut TestProto2| { &mut m.map_string_bool },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "map_string_float",
            |m: &TestProto2| { &m.map_string_float },
            |m: &mut TestProto2| { &mut m.map_string_float },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "map_int64_struct",
            |m: &TestProto2| { &m.map_int64_struct },
            |m: &mut TestProto2| { &mut m.map_int64_struct },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "map_int64_int64",
            |m: &TestProto2| { &m.map_int64_int64 },
            |m: &mut TestProto2| { &mut m.map_int64_int64 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "map_int64_string",
            |m: &TestProto2| { &m.map_int64_string },
            |m: &mut TestProto2| { &mut m.map_int64_string },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "map_int64_bool",
            |m: &TestProto2| { &m.map_int64_bool },
            |m: &mut TestProto2| { &mut m.map_int64_bool },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "map_int64_float",
            |m: &TestProto2| { &m.map_int64_float },
            |m: &mut TestProto2| { &mut m.map_int64_float },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &TestProto2| { &m.timestamp },
            |m: &mut TestProto2| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bool_proto",
            |m: &TestProto2| { &m.bool_proto },
            |m: &mut TestProto2| { &mut m.bool_proto },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ignored",
            |m: &TestProto2| { &m.ignored },
            |m: &mut TestProto2| { &mut m.ignored },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_size",
            |m: &TestProto2| { &m.file_size },
            |m: &mut TestProto2| { &mut m.file_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "requires_foo_and_bar",
            |m: &TestProto2| { &m.requires_foo_and_bar },
            |m: &mut TestProto2| { &mut m.requires_foo_and_bar },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deprecated",
            |m: &TestProto2| { &m.deprecated },
            |m: &mut TestProto2| { &mut m.deprecated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "metadata",
            |m: &TestProto2| { &m.metadata },
            |m: &mut TestProto2| { &mut m.metadata },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TestProto2>(
            "TestProto2",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TestProto2 {
    const NAME: &'static str = "TestProto2";

    fn is_initialized(&self) -> bool {
        if self.int32_zero.is_none() {
            return false;
        }
        if self.int64_zero.is_none() {
            return false;
        }
        if self.sint32_zero.is_none() {
            return false;
        }
        if self.sint64_zero.is_none() {
            return false;
        }
        if self.uint32_zero.is_none() {
            return false;
        }
        if self.uint64_zero.is_none() {
            return false;
        }
        if self.fixed32_zero.is_none() {
            return false;
        }
        if self.fixed64_zero.is_none() {
            return false;
        }
        if self.sfixed32_zero.is_none() {
            return false;
        }
        if self.sfixed64_zero.is_none() {
            return false;
        }
        if self.float_zero.is_none() {
            return false;
        }
        if self.double_zero.is_none() {
            return false;
        }
        if self.int32_one.is_none() {
            return false;
        }
        if self.int64_one.is_none() {
            return false;
        }
        if self.sint32_one.is_none() {
            return false;
        }
        if self.sint64_one.is_none() {
            return false;
        }
        if self.uint32_one.is_none() {
            return false;
        }
        if self.uint64_one.is_none() {
            return false;
        }
        if self.fixed32_one.is_none() {
            return false;
        }
        if self.fixed64_one.is_none() {
            return false;
        }
        if self.sfixed32_one.is_none() {
            return false;
        }
        if self.sfixed64_one.is_none() {
            return false;
        }
        if self.float_one.is_none() {
            return false;
        }
        if self.double_one.is_none() {
            return false;
        }
        if self.string_foo.is_none() {
            return false;
        }
        if self.string_bar.is_none() {
            return false;
        }
        if self.bytes_foo.is_none() {
            return false;
        }
        if self.bytes_bar.is_none() {
            return false;
        }
        if self.bytes_raw.is_none() {
            return false;
        }
        for v in &self.nested {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.array_struct {
            if !v.is_initialized() {
                return false;
            }
        };
        // TODO: check map values are initialized
        // TODO: check map values are initialized
        // TODO: check map values are initialized
        // TODO: check map values are initialized
        // TODO: check map values are initialized
        // TODO: check map values are initialized
        // TODO: check map values are initialized
        // TODO: check map values are initialized
        // TODO: check map values are initialized
        // TODO: check map values are initialized
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.int32_zero = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.int64_zero = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.sint32_zero = ::std::option::Option::Some(is.read_sint32()?);
                },
                32 => {
                    self.sint64_zero = ::std::option::Option::Some(is.read_sint64()?);
                },
                40 => {
                    self.uint32_zero = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.uint64_zero = ::std::option::Option::Some(is.read_uint64()?);
                },
                61 => {
                    self.fixed32_zero = ::std::option::Option::Some(is.read_fixed32()?);
                },
                65 => {
                    self.fixed64_zero = ::std::option::Option::Some(is.read_fixed64()?);
                },
                77 => {
                    self.sfixed32_zero = ::std::option::Option::Some(is.read_sfixed32()?);
                },
                81 => {
                    self.sfixed64_zero = ::std::option::Option::Some(is.read_sfixed64()?);
                },
                93 => {
                    self.float_zero = ::std::option::Option::Some(is.read_float()?);
                },
                97 => {
                    self.double_zero = ::std::option::Option::Some(is.read_double()?);
                },
                168 => {
                    self.int32_one = ::std::option::Option::Some(is.read_int32()?);
                },
                176 => {
                    self.int64_one = ::std::option::Option::Some(is.read_int64()?);
                },
                184 => {
                    self.sint32_one = ::std::option::Option::Some(is.read_sint32()?);
                },
                192 => {
                    self.sint64_one = ::std::option::Option::Some(is.read_sint64()?);
                },
                200 => {
                    self.uint32_one = ::std::option::Option::Some(is.read_uint32()?);
                },
                208 => {
                    self.uint64_one = ::std::option::Option::Some(is.read_uint64()?);
                },
                221 => {
                    self.fixed32_one = ::std::option::Option::Some(is.read_fixed32()?);
                },
                225 => {
                    self.fixed64_one = ::std::option::Option::Some(is.read_fixed64()?);
                },
                237 => {
                    self.sfixed32_one = ::std::option::Option::Some(is.read_sfixed32()?);
                },
                241 => {
                    self.sfixed64_one = ::std::option::Option::Some(is.read_sfixed64()?);
                },
                253 => {
                    self.float_one = ::std::option::Option::Some(is.read_float()?);
                },
                257 => {
                    self.double_one = ::std::option::Option::Some(is.read_double()?);
                },
                328 => {
                    self.int32_undef = ::std::option::Option::Some(is.read_int32()?);
                },
                336 => {
                    self.int64_undef = ::std::option::Option::Some(is.read_int64()?);
                },
                344 => {
                    self.sint32_undef = ::std::option::Option::Some(is.read_sint32()?);
                },
                352 => {
                    self.sint64_undef = ::std::option::Option::Some(is.read_sint64()?);
                },
                360 => {
                    self.uint32_undef = ::std::option::Option::Some(is.read_uint32()?);
                },
                368 => {
                    self.uint64_undef = ::std::option::Option::Some(is.read_uint64()?);
                },
                381 => {
                    self.fixed32_undef = ::std::option::Option::Some(is.read_fixed32()?);
                },
                385 => {
                    self.fixed64_undef = ::std::option::Option::Some(is.read_fixed64()?);
                },
                397 => {
                    self.sfixed32_undef = ::std::option::Option::Some(is.read_sfixed32()?);
                },
                401 => {
                    self.sfixed64_undef = ::std::option::Option::Some(is.read_sfixed64()?);
                },
                413 => {
                    self.float_undef = ::std::option::Option::Some(is.read_float()?);
                },
                417 => {
                    self.double_undef = ::std::option::Option::Some(is.read_double()?);
                },
                490 => {
                    self.string_foo = ::std::option::Option::Some(is.read_string()?);
                },
                498 => {
                    self.string_bar = ::std::option::Option::Some(is.read_string()?);
                },
                506 => {
                    self.string_undef = ::std::option::Option::Some(is.read_string()?);
                },
                514 => {
                    self.bytes_foo = ::std::option::Option::Some(is.read_bytes()?);
                },
                522 => {
                    self.bytes_bar = ::std::option::Option::Some(is.read_bytes()?);
                },
                530 => {
                    self.bytes_raw = ::std::option::Option::Some(is.read_bytes()?);
                },
                538 => {
                    self.bytes_undef = ::std::option::Option::Some(is.read_bytes()?);
                },
                800 => {
                    self.enumeration = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                818 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.nested)?;
                },
                1202 => {
                    is.read_repeated_packed_int64_into(&mut self.array_int64)?;
                },
                1200 => {
                    self.array_int64.push(is.read_int64()?);
                },
                1210 => {
                    is.read_repeated_packed_float_into(&mut self.array_float)?;
                },
                1213 => {
                    self.array_float.push(is.read_float()?);
                },
                1218 => {
                    is.read_repeated_packed_bool_into(&mut self.array_bool)?;
                },
                1216 => {
                    self.array_bool.push(is.read_bool()?);
                },
                1226 => {
                    self.array_string.push(is.read_string()?);
                },
                1234 => {
                    self.array_struct.push(is.read_message()?);
                },
                1602 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.map_string_struct.insert(key, value);
                },
                1610 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            16 => value = is.read_int64()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.map_string_int64.insert(key, value);
                },
                1618 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.map_string_string.insert(key, value);
                },
                1626 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            16 => value = is.read_bool()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.map_string_bool.insert(key, value);
                },
                1634 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            21 => value = is.read_float()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.map_string_float.insert(key, value);
                },
                2402 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => key = is.read_int64()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.map_int64_struct.insert(key, value);
                },
                2410 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => key = is.read_int64()?,
                            16 => value = is.read_int64()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.map_int64_int64.insert(key, value);
                },
                2418 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => key = is.read_int64()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.map_int64_string.insert(key, value);
                },
                2426 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => key = is.read_int64()?,
                            16 => value = is.read_bool()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.map_int64_bool.insert(key, value);
                },
                2434 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => key = is.read_int64()?,
                            21 => value = is.read_float()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.map_int64_float.insert(key, value);
                },
                2440 => {
                    self.timestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                2800 => {
                    self.bool_proto = ::std::option::Option::Some(is.read_bool()?);
                },
                2808 => {
                    self.ignored = ::std::option::Option::Some(is.read_bool()?);
                },
                3200 => {
                    self.file_size = ::std::option::Option::Some(is.read_uint64()?);
                },
                4000 => {
                    self.requires_foo_and_bar = ::std::option::Option::Some(is.read_uint64()?);
                },
                4010 => {
                    self.deprecated = ::std::option::Option::Some(is.read_string()?);
                },
                4018 => {
                    self.metadata = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.int32_zero {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.int64_zero {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.sint32_zero {
            my_size += ::protobuf::rt::sint32_size(3, v);
        }
        if let Some(v) = self.sint64_zero {
            my_size += ::protobuf::rt::sint64_size(4, v);
        }
        if let Some(v) = self.uint32_zero {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.uint64_zero {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.fixed32_zero {
            my_size += 1 + 4;
        }
        if let Some(v) = self.fixed64_zero {
            my_size += 1 + 8;
        }
        if let Some(v) = self.sfixed32_zero {
            my_size += 1 + 4;
        }
        if let Some(v) = self.sfixed64_zero {
            my_size += 1 + 8;
        }
        if let Some(v) = self.float_zero {
            my_size += 1 + 4;
        }
        if let Some(v) = self.double_zero {
            my_size += 1 + 8;
        }
        if let Some(v) = self.int32_one {
            my_size += ::protobuf::rt::int32_size(21, v);
        }
        if let Some(v) = self.int64_one {
            my_size += ::protobuf::rt::int64_size(22, v);
        }
        if let Some(v) = self.sint32_one {
            my_size += ::protobuf::rt::sint32_size(23, v);
        }
        if let Some(v) = self.sint64_one {
            my_size += ::protobuf::rt::sint64_size(24, v);
        }
        if let Some(v) = self.uint32_one {
            my_size += ::protobuf::rt::uint32_size(25, v);
        }
        if let Some(v) = self.uint64_one {
            my_size += ::protobuf::rt::uint64_size(26, v);
        }
        if let Some(v) = self.fixed32_one {
            my_size += 2 + 4;
        }
        if let Some(v) = self.fixed64_one {
            my_size += 2 + 8;
        }
        if let Some(v) = self.sfixed32_one {
            my_size += 2 + 4;
        }
        if let Some(v) = self.sfixed64_one {
            my_size += 2 + 8;
        }
        if let Some(v) = self.float_one {
            my_size += 2 + 4;
        }
        if let Some(v) = self.double_one {
            my_size += 2 + 8;
        }
        if let Some(v) = self.int32_undef {
            my_size += ::protobuf::rt::int32_size(41, v);
        }
        if let Some(v) = self.int64_undef {
            my_size += ::protobuf::rt::int64_size(42, v);
        }
        if let Some(v) = self.sint32_undef {
            my_size += ::protobuf::rt::sint32_size(43, v);
        }
        if let Some(v) = self.sint64_undef {
            my_size += ::protobuf::rt::sint64_size(44, v);
        }
        if let Some(v) = self.uint32_undef {
            my_size += ::protobuf::rt::uint32_size(45, v);
        }
        if let Some(v) = self.uint64_undef {
            my_size += ::protobuf::rt::uint64_size(46, v);
        }
        if let Some(v) = self.fixed32_undef {
            my_size += 2 + 4;
        }
        if let Some(v) = self.fixed64_undef {
            my_size += 2 + 8;
        }
        if let Some(v) = self.sfixed32_undef {
            my_size += 2 + 4;
        }
        if let Some(v) = self.sfixed64_undef {
            my_size += 2 + 8;
        }
        if let Some(v) = self.float_undef {
            my_size += 2 + 4;
        }
        if let Some(v) = self.double_undef {
            my_size += 2 + 8;
        }
        if let Some(v) = self.string_foo.as_ref() {
            my_size += ::protobuf::rt::string_size(61, &v);
        }
        if let Some(v) = self.string_bar.as_ref() {
            my_size += ::protobuf::rt::string_size(62, &v);
        }
        if let Some(v) = self.string_undef.as_ref() {
            my_size += ::protobuf::rt::string_size(63, &v);
        }
        if let Some(v) = self.bytes_foo.as_ref() {
            my_size += ::protobuf::rt::bytes_size(64, &v);
        }
        if let Some(v) = self.bytes_bar.as_ref() {
            my_size += ::protobuf::rt::bytes_size(65, &v);
        }
        if let Some(v) = self.bytes_raw.as_ref() {
            my_size += ::protobuf::rt::bytes_size(66, &v);
        }
        if let Some(v) = self.bytes_undef.as_ref() {
            my_size += ::protobuf::rt::bytes_size(67, &v);
        }
        if let Some(v) = self.enumeration {
            my_size += ::protobuf::rt::int32_size(100, v.value());
        }
        if let Some(v) = self.nested.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.array_int64 {
            my_size += ::protobuf::rt::int64_size(150, *value);
        };
        my_size += 6 * self.array_float.len() as u64;
        my_size += 3 * self.array_bool.len() as u64;
        for value in &self.array_string {
            my_size += ::protobuf::rt::string_size(153, &value);
        };
        for value in &self.array_struct {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for (k, v) in &self.map_string_struct {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.map_string_int64 {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::int64_size(2, *v);
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.map_string_string {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.map_string_bool {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += 1 + 1;
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.map_string_float {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += 1 + 4;
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.map_int64_struct {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::int64_size(1, *k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.map_int64_int64 {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::int64_size(1, *k);
            entry_size += ::protobuf::rt::int64_size(2, *v);
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.map_int64_string {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::int64_size(1, *k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.map_int64_bool {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::int64_size(1, *k);
            entry_size += 1 + 1;
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.map_int64_float {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::int64_size(1, *k);
            entry_size += 1 + 4;
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::int64_size(305, v);
        }
        if let Some(v) = self.bool_proto {
            my_size += 2 + 1;
        }
        if let Some(v) = self.ignored {
            my_size += 2 + 1;
        }
        if let Some(v) = self.file_size {
            my_size += ::protobuf::rt::uint64_size(400, v);
        }
        if let Some(v) = self.requires_foo_and_bar {
            my_size += ::protobuf::rt::uint64_size(500, v);
        }
        if let Some(v) = self.deprecated.as_ref() {
            my_size += ::protobuf::rt::string_size(501, &v);
        }
        if let Some(v) = self.metadata.as_ref() {
            my_size += ::protobuf::rt::bytes_size(502, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.int32_zero {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.int64_zero {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.sint32_zero {
            os.write_sint32(3, v)?;
        }
        if let Some(v) = self.sint64_zero {
            os.write_sint64(4, v)?;
        }
        if let Some(v) = self.uint32_zero {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.uint64_zero {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.fixed32_zero {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.fixed64_zero {
            os.write_fixed64(8, v)?;
        }
        if let Some(v) = self.sfixed32_zero {
            os.write_sfixed32(9, v)?;
        }
        if let Some(v) = self.sfixed64_zero {
            os.write_sfixed64(10, v)?;
        }
        if let Some(v) = self.float_zero {
            os.write_float(11, v)?;
        }
        if let Some(v) = self.double_zero {
            os.write_double(12, v)?;
        }
        if let Some(v) = self.int32_one {
            os.write_int32(21, v)?;
        }
        if let Some(v) = self.int64_one {
            os.write_int64(22, v)?;
        }
        if let Some(v) = self.sint32_one {
            os.write_sint32(23, v)?;
        }
        if let Some(v) = self.sint64_one {
            os.write_sint64(24, v)?;
        }
        if let Some(v) = self.uint32_one {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.uint64_one {
            os.write_uint64(26, v)?;
        }
        if let Some(v) = self.fixed32_one {
            os.write_fixed32(27, v)?;
        }
        if let Some(v) = self.fixed64_one {
            os.write_fixed64(28, v)?;
        }
        if let Some(v) = self.sfixed32_one {
            os.write_sfixed32(29, v)?;
        }
        if let Some(v) = self.sfixed64_one {
            os.write_sfixed64(30, v)?;
        }
        if let Some(v) = self.float_one {
            os.write_float(31, v)?;
        }
        if let Some(v) = self.double_one {
            os.write_double(32, v)?;
        }
        if let Some(v) = self.int32_undef {
            os.write_int32(41, v)?;
        }
        if let Some(v) = self.int64_undef {
            os.write_int64(42, v)?;
        }
        if let Some(v) = self.sint32_undef {
            os.write_sint32(43, v)?;
        }
        if let Some(v) = self.sint64_undef {
            os.write_sint64(44, v)?;
        }
        if let Some(v) = self.uint32_undef {
            os.write_uint32(45, v)?;
        }
        if let Some(v) = self.uint64_undef {
            os.write_uint64(46, v)?;
        }
        if let Some(v) = self.fixed32_undef {
            os.write_fixed32(47, v)?;
        }
        if let Some(v) = self.fixed64_undef {
            os.write_fixed64(48, v)?;
        }
        if let Some(v) = self.sfixed32_undef {
            os.write_sfixed32(49, v)?;
        }
        if let Some(v) = self.sfixed64_undef {
            os.write_sfixed64(50, v)?;
        }
        if let Some(v) = self.float_undef {
            os.write_float(51, v)?;
        }
        if let Some(v) = self.double_undef {
            os.write_double(52, v)?;
        }
        if let Some(v) = self.string_foo.as_ref() {
            os.write_string(61, v)?;
        }
        if let Some(v) = self.string_bar.as_ref() {
            os.write_string(62, v)?;
        }
        if let Some(v) = self.string_undef.as_ref() {
            os.write_string(63, v)?;
        }
        if let Some(v) = self.bytes_foo.as_ref() {
            os.write_bytes(64, v)?;
        }
        if let Some(v) = self.bytes_bar.as_ref() {
            os.write_bytes(65, v)?;
        }
        if let Some(v) = self.bytes_raw.as_ref() {
            os.write_bytes(66, v)?;
        }
        if let Some(v) = self.bytes_undef.as_ref() {
            os.write_bytes(67, v)?;
        }
        if let Some(v) = self.enumeration {
            os.write_enum(100, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.nested.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(102, v, os)?;
        }
        for v in &self.array_int64 {
            os.write_int64(150, *v)?;
        };
        for v in &self.array_float {
            os.write_float(151, *v)?;
        };
        for v in &self.array_bool {
            os.write_bool(152, *v)?;
        };
        for v in &self.array_string {
            os.write_string(153, &v)?;
        };
        for v in &self.array_struct {
            ::protobuf::rt::write_message_field_with_cached_size(154, v, os)?;
        };
        for (k, v) in &self.map_string_struct {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(1602)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.map_string_int64 {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::int64_size(2, *v);
            os.write_raw_varint32(1610)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_int64(2, *v)?;
        };
        for (k, v) in &self.map_string_string {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(1618)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        for (k, v) in &self.map_string_bool {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += 1 + 1;
            os.write_raw_varint32(1626)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_bool(2, *v)?;
        };
        for (k, v) in &self.map_string_float {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += 1 + 4;
            os.write_raw_varint32(1634)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_float(2, *v)?;
        };
        for (k, v) in &self.map_int64_struct {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::int64_size(1, *k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(2402)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_int64(1, *k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.map_int64_int64 {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::int64_size(1, *k);
            entry_size += ::protobuf::rt::int64_size(2, *v);
            os.write_raw_varint32(2410)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_int64(1, *k)?;
            os.write_int64(2, *v)?;
        };
        for (k, v) in &self.map_int64_string {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::int64_size(1, *k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(2418)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_int64(1, *k)?;
            os.write_string(2, &v)?;
        };
        for (k, v) in &self.map_int64_bool {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::int64_size(1, *k);
            entry_size += 1 + 1;
            os.write_raw_varint32(2426)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_int64(1, *k)?;
            os.write_bool(2, *v)?;
        };
        for (k, v) in &self.map_int64_float {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::int64_size(1, *k);
            entry_size += 1 + 4;
            os.write_raw_varint32(2434)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_int64(1, *k)?;
            os.write_float(2, *v)?;
        };
        if let Some(v) = self.timestamp {
            os.write_int64(305, v)?;
        }
        if let Some(v) = self.bool_proto {
            os.write_bool(350, v)?;
        }
        if let Some(v) = self.ignored {
            os.write_bool(351, v)?;
        }
        if let Some(v) = self.file_size {
            os.write_uint64(400, v)?;
        }
        if let Some(v) = self.requires_foo_and_bar {
            os.write_uint64(500, v)?;
        }
        if let Some(v) = self.deprecated.as_ref() {
            os.write_string(501, v)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            os.write_bytes(502, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TestProto2 {
        TestProto2::new()
    }

    fn clear(&mut self) {
        self.int32_zero = ::std::option::Option::None;
        self.int64_zero = ::std::option::Option::None;
        self.sint32_zero = ::std::option::Option::None;
        self.sint64_zero = ::std::option::Option::None;
        self.uint32_zero = ::std::option::Option::None;
        self.uint64_zero = ::std::option::Option::None;
        self.fixed32_zero = ::std::option::Option::None;
        self.fixed64_zero = ::std::option::Option::None;
        self.sfixed32_zero = ::std::option::Option::None;
        self.sfixed64_zero = ::std::option::Option::None;
        self.float_zero = ::std::option::Option::None;
        self.double_zero = ::std::option::Option::None;
        self.int32_one = ::std::option::Option::None;
        self.int64_one = ::std::option::Option::None;
        self.sint32_one = ::std::option::Option::None;
        self.sint64_one = ::std::option::Option::None;
        self.uint32_one = ::std::option::Option::None;
        self.uint64_one = ::std::option::Option::None;
        self.fixed32_one = ::std::option::Option::None;
        self.fixed64_one = ::std::option::Option::None;
        self.sfixed32_one = ::std::option::Option::None;
        self.sfixed64_one = ::std::option::Option::None;
        self.float_one = ::std::option::Option::None;
        self.double_one = ::std::option::Option::None;
        self.int32_undef = ::std::option::Option::None;
        self.int64_undef = ::std::option::Option::None;
        self.sint32_undef = ::std::option::Option::None;
        self.sint64_undef = ::std::option::Option::None;
        self.uint32_undef = ::std::option::Option::None;
        self.uint64_undef = ::std::option::Option::None;
        self.fixed32_undef = ::std::option::Option::None;
        self.fixed64_undef = ::std::option::Option::None;
        self.sfixed32_undef = ::std::option::Option::None;
        self.sfixed64_undef = ::std::option::Option::None;
        self.float_undef = ::std::option::Option::None;
        self.double_undef = ::std::option::Option::None;
        self.string_foo = ::std::option::Option::None;
        self.string_bar = ::std::option::Option::None;
        self.string_undef = ::std::option::Option::None;
        self.bytes_foo = ::std::option::Option::None;
        self.bytes_bar = ::std::option::Option::None;
        self.bytes_raw = ::std::option::Option::None;
        self.bytes_undef = ::std::option::Option::None;
        self.enumeration = ::std::option::Option::None;
        self.nested.clear();
        self.array_int64.clear();
        self.array_float.clear();
        self.array_bool.clear();
        self.array_string.clear();
        self.array_struct.clear();
        self.map_string_struct.clear();
        self.map_string_int64.clear();
        self.map_string_string.clear();
        self.map_string_bool.clear();
        self.map_string_float.clear();
        self.map_int64_struct.clear();
        self.map_int64_int64.clear();
        self.map_int64_string.clear();
        self.map_int64_bool.clear();
        self.map_int64_float.clear();
        self.timestamp = ::std::option::Option::None;
        self.bool_proto = ::std::option::Option::None;
        self.ignored = ::std::option::Option::None;
        self.file_size = ::std::option::Option::None;
        self.requires_foo_and_bar = ::std::option::Option::None;
        self.deprecated = ::std::option::Option::None;
        self.metadata = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TestProto2 {
        static instance: ::protobuf::rt::Lazy<TestProto2> = ::protobuf::rt::Lazy::new();
        instance.get(TestProto2::new)
    }
}

impl ::protobuf::MessageFull for TestProto2 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TestProto2").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TestProto2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestProto2 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TestProto2`
pub mod test_proto2 {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:test_proto2.TestProto2.Enumeration)
    pub enum Enumeration {
        // @@protoc_insertion_point(enum_value:test_proto2.TestProto2.Enumeration.ITEM_0)
        ITEM_0 = 0,
        // @@protoc_insertion_point(enum_value:test_proto2.TestProto2.Enumeration.ITEM_1)
        ITEM_1 = 1,
        // @@protoc_insertion_point(enum_value:test_proto2.TestProto2.Enumeration.ITEM_2)
        ITEM_2 = 2,
        // @@protoc_insertion_point(enum_value:test_proto2.TestProto2.Enumeration.ITEM_3)
        ITEM_3 = 3,
    }

    impl ::protobuf::Enum for Enumeration {
        const NAME: &'static str = "Enumeration";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Enumeration> {
            match value {
                0 => ::std::option::Option::Some(Enumeration::ITEM_0),
                1 => ::std::option::Option::Some(Enumeration::ITEM_1),
                2 => ::std::option::Option::Some(Enumeration::ITEM_2),
                3 => ::std::option::Option::Some(Enumeration::ITEM_3),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Enumeration> {
            match str {
                "ITEM_0" => ::std::option::Option::Some(Enumeration::ITEM_0),
                "ITEM_1" => ::std::option::Option::Some(Enumeration::ITEM_1),
                "ITEM_2" => ::std::option::Option::Some(Enumeration::ITEM_2),
                "ITEM_3" => ::std::option::Option::Some(Enumeration::ITEM_3),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Enumeration] = &[
            Enumeration::ITEM_0,
            Enumeration::ITEM_1,
            Enumeration::ITEM_2,
            Enumeration::ITEM_3,
        ];
    }

    impl ::protobuf::EnumFull for Enumeration {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("TestProto2.Enumeration").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Enumeration {
        fn default() -> Self {
            Enumeration::ITEM_0
        }
    }

    impl Enumeration {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Enumeration>("TestProto2.Enumeration")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:test_proto2.TestProto2.Enumeration2)
    pub enum Enumeration2 {
        // @@protoc_insertion_point(enum_value:test_proto2.TestProto2.Enumeration2.ITEM_4)
        ITEM_4 = 0,
        // @@protoc_insertion_point(enum_value:test_proto2.TestProto2.Enumeration2.ITEM_5)
        ITEM_5 = 1,
    }

    impl ::protobuf::Enum for Enumeration2 {
        const NAME: &'static str = "Enumeration2";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Enumeration2> {
            match value {
                0 => ::std::option::Option::Some(Enumeration2::ITEM_4),
                1 => ::std::option::Option::Some(Enumeration2::ITEM_5),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Enumeration2> {
            match str {
                "ITEM_4" => ::std::option::Option::Some(Enumeration2::ITEM_4),
                "ITEM_5" => ::std::option::Option::Some(Enumeration2::ITEM_5),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Enumeration2] = &[
            Enumeration2::ITEM_4,
            Enumeration2::ITEM_5,
        ];
    }

    impl ::protobuf::EnumFull for Enumeration2 {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("TestProto2.Enumeration2").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Enumeration2 {
        fn default() -> Self {
            Enumeration2::ITEM_4
        }
    }

    impl Enumeration2 {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Enumeration2>("TestProto2.Enumeration2")
        }
    }
}

// @@protoc_insertion_point(message:test_proto2.NestedProto2)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NestedProto2 {
    // message fields
    // @@protoc_insertion_point(field:test_proto2.NestedProto2.nested_int32_zero)
    pub nested_int32_zero: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:test_proto2.NestedProto2.nested_int64_zero)
    pub nested_int64_zero: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:test_proto2.NestedProto2.nested_int32_one)
    pub nested_int32_one: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:test_proto2.NestedProto2.nested_int64_one)
    pub nested_int64_one: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:test_proto2.NestedProto2.nested_bool)
    pub nested_bool: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:test_proto2.NestedProto2.nested_string)
    pub nested_string: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:test_proto2.NestedProto2.nested_array_int64)
    pub nested_array_int64: ::std::vec::Vec<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:test_proto2.NestedProto2.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NestedProto2 {
    fn default() -> &'a NestedProto2 {
        <NestedProto2 as ::protobuf::Message>::default_instance()
    }
}

impl NestedProto2 {
    pub fn new() -> NestedProto2 {
        ::std::default::Default::default()
    }

    // optional int32 nested_int32_zero = 1;

    pub fn nested_int32_zero(&self) -> i32 {
        self.nested_int32_zero.unwrap_or(0)
    }

    pub fn clear_nested_int32_zero(&mut self) {
        self.nested_int32_zero = ::std::option::Option::None;
    }

    pub fn has_nested_int32_zero(&self) -> bool {
        self.nested_int32_zero.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nested_int32_zero(&mut self, v: i32) {
        self.nested_int32_zero = ::std::option::Option::Some(v);
    }

    // optional int64 nested_int64_zero = 2;

    pub fn nested_int64_zero(&self) -> i64 {
        self.nested_int64_zero.unwrap_or(0)
    }

    pub fn clear_nested_int64_zero(&mut self) {
        self.nested_int64_zero = ::std::option::Option::None;
    }

    pub fn has_nested_int64_zero(&self) -> bool {
        self.nested_int64_zero.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nested_int64_zero(&mut self, v: i64) {
        self.nested_int64_zero = ::std::option::Option::Some(v);
    }

    // optional int32 nested_int32_one = 3;

    pub fn nested_int32_one(&self) -> i32 {
        self.nested_int32_one.unwrap_or(0)
    }

    pub fn clear_nested_int32_one(&mut self) {
        self.nested_int32_one = ::std::option::Option::None;
    }

    pub fn has_nested_int32_one(&self) -> bool {
        self.nested_int32_one.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nested_int32_one(&mut self, v: i32) {
        self.nested_int32_one = ::std::option::Option::Some(v);
    }

    // optional int64 nested_int64_one = 4;

    pub fn nested_int64_one(&self) -> i64 {
        self.nested_int64_one.unwrap_or(0)
    }

    pub fn clear_nested_int64_one(&mut self) {
        self.nested_int64_one = ::std::option::Option::None;
    }

    pub fn has_nested_int64_one(&self) -> bool {
        self.nested_int64_one.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nested_int64_one(&mut self, v: i64) {
        self.nested_int64_one = ::std::option::Option::Some(v);
    }

    // optional bool nested_bool = 5;

    pub fn nested_bool(&self) -> bool {
        self.nested_bool.unwrap_or(false)
    }

    pub fn clear_nested_bool(&mut self) {
        self.nested_bool = ::std::option::Option::None;
    }

    pub fn has_nested_bool(&self) -> bool {
        self.nested_bool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nested_bool(&mut self, v: bool) {
        self.nested_bool = ::std::option::Option::Some(v);
    }

    // optional string nested_string = 6;

    pub fn nested_string(&self) -> &str {
        match self.nested_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_nested_string(&mut self) {
        self.nested_string = ::std::option::Option::None;
    }

    pub fn has_nested_string(&self) -> bool {
        self.nested_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nested_string(&mut self, v: ::std::string::String) {
        self.nested_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nested_string(&mut self) -> &mut ::std::string::String {
        if self.nested_string.is_none() {
            self.nested_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.nested_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_nested_string(&mut self) -> ::std::string::String {
        self.nested_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nested_int32_zero",
            |m: &NestedProto2| { &m.nested_int32_zero },
            |m: &mut NestedProto2| { &mut m.nested_int32_zero },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nested_int64_zero",
            |m: &NestedProto2| { &m.nested_int64_zero },
            |m: &mut NestedProto2| { &mut m.nested_int64_zero },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nested_int32_one",
            |m: &NestedProto2| { &m.nested_int32_one },
            |m: &mut NestedProto2| { &mut m.nested_int32_one },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nested_int64_one",
            |m: &NestedProto2| { &m.nested_int64_one },
            |m: &mut NestedProto2| { &mut m.nested_int64_one },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nested_bool",
            |m: &NestedProto2| { &m.nested_bool },
            |m: &mut NestedProto2| { &mut m.nested_bool },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nested_string",
            |m: &NestedProto2| { &m.nested_string },
            |m: &mut NestedProto2| { &mut m.nested_string },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "nested_array_int64",
            |m: &NestedProto2| { &m.nested_array_int64 },
            |m: &mut NestedProto2| { &mut m.nested_array_int64 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NestedProto2>(
            "NestedProto2",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NestedProto2 {
    const NAME: &'static str = "NestedProto2";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.nested_int32_zero = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.nested_int64_zero = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.nested_int32_one = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.nested_int64_one = ::std::option::Option::Some(is.read_int64()?);
                },
                40 => {
                    self.nested_bool = ::std::option::Option::Some(is.read_bool()?);
                },
                50 => {
                    self.nested_string = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    is.read_repeated_packed_int64_into(&mut self.nested_array_int64)?;
                },
                56 => {
                    self.nested_array_int64.push(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.nested_int32_zero {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.nested_int64_zero {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.nested_int32_one {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.nested_int64_one {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        if let Some(v) = self.nested_bool {
            my_size += 1 + 1;
        }
        if let Some(v) = self.nested_string.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        for value in &self.nested_array_int64 {
            my_size += ::protobuf::rt::int64_size(7, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.nested_int32_zero {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.nested_int64_zero {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.nested_int32_one {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.nested_int64_one {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.nested_bool {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.nested_string.as_ref() {
            os.write_string(6, v)?;
        }
        for v in &self.nested_array_int64 {
            os.write_int64(7, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NestedProto2 {
        NestedProto2::new()
    }

    fn clear(&mut self) {
        self.nested_int32_zero = ::std::option::Option::None;
        self.nested_int64_zero = ::std::option::Option::None;
        self.nested_int32_one = ::std::option::Option::None;
        self.nested_int64_one = ::std::option::Option::None;
        self.nested_bool = ::std::option::Option::None;
        self.nested_string = ::std::option::Option::None;
        self.nested_array_int64.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NestedProto2 {
        static instance: NestedProto2 = NestedProto2 {
            nested_int32_zero: ::std::option::Option::None,
            nested_int64_zero: ::std::option::Option::None,
            nested_int32_one: ::std::option::Option::None,
            nested_int64_one: ::std::option::Option::None,
            nested_bool: ::std::option::Option::None,
            nested_string: ::std::option::Option::None,
            nested_array_int64: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NestedProto2 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NestedProto2").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NestedProto2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NestedProto2 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `NestedProto2`
pub mod nested_proto2 {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:test_proto2.NestedProto2.NestedEnumeration)
    pub enum NestedEnumeration {
        // @@protoc_insertion_point(enum_value:test_proto2.NestedProto2.NestedEnumeration.ITEM_0)
        ITEM_0 = 0,
        // @@protoc_insertion_point(enum_value:test_proto2.NestedProto2.NestedEnumeration.ITEM_1)
        ITEM_1 = 1,
    }

    impl ::protobuf::Enum for NestedEnumeration {
        const NAME: &'static str = "NestedEnumeration";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<NestedEnumeration> {
            match value {
                0 => ::std::option::Option::Some(NestedEnumeration::ITEM_0),
                1 => ::std::option::Option::Some(NestedEnumeration::ITEM_1),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<NestedEnumeration> {
            match str {
                "ITEM_0" => ::std::option::Option::Some(NestedEnumeration::ITEM_0),
                "ITEM_1" => ::std::option::Option::Some(NestedEnumeration::ITEM_1),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [NestedEnumeration] = &[
            NestedEnumeration::ITEM_0,
            NestedEnumeration::ITEM_1,
        ];
    }

    impl ::protobuf::EnumFull for NestedEnumeration {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("NestedProto2.NestedEnumeration").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for NestedEnumeration {
        fn default() -> Self {
            NestedEnumeration::ITEM_0
        }
    }

    impl NestedEnumeration {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<NestedEnumeration>("NestedProto2.NestedEnumeration")
        }
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:test_proto2.TopLevelEnumeration)
pub enum TopLevelEnumeration {
    // @@protoc_insertion_point(enum_value:test_proto2.TopLevelEnumeration.ITEM_0x1000)
    ITEM_0x1000 = 4096,
    // @@protoc_insertion_point(enum_value:test_proto2.TopLevelEnumeration.ITEM_0x2000)
    ITEM_0x2000 = 8192,
}

impl ::protobuf::Enum for TopLevelEnumeration {
    const NAME: &'static str = "TopLevelEnumeration";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TopLevelEnumeration> {
        match value {
            4096 => ::std::option::Option::Some(TopLevelEnumeration::ITEM_0x1000),
            8192 => ::std::option::Option::Some(TopLevelEnumeration::ITEM_0x2000),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<TopLevelEnumeration> {
        match str {
            "ITEM_0x1000" => ::std::option::Option::Some(TopLevelEnumeration::ITEM_0x1000),
            "ITEM_0x2000" => ::std::option::Option::Some(TopLevelEnumeration::ITEM_0x2000),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TopLevelEnumeration] = &[
        TopLevelEnumeration::ITEM_0x1000,
        TopLevelEnumeration::ITEM_0x2000,
    ];
}

impl ::protobuf::EnumFull for TopLevelEnumeration {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("TopLevelEnumeration").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            TopLevelEnumeration::ITEM_0x1000 => 0,
            TopLevelEnumeration::ITEM_0x2000 => 1,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for TopLevelEnumeration {
    fn default() -> Self {
        TopLevelEnumeration::ITEM_0x1000
    }
}

impl TopLevelEnumeration {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TopLevelEnumeration>("TopLevelEnumeration")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:test_proto2.InlineEnumeration)
pub enum InlineEnumeration {
    // @@protoc_insertion_point(enum_value:test_proto2.InlineEnumeration.INLINE_0x1000)
    INLINE_0x1000 = 4096,
    // @@protoc_insertion_point(enum_value:test_proto2.InlineEnumeration.INLINE_0x2000)
    INLINE_0x2000 = 8192,
}

impl ::protobuf::Enum for InlineEnumeration {
    const NAME: &'static str = "InlineEnumeration";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<InlineEnumeration> {
        match value {
            4096 => ::std::option::Option::Some(InlineEnumeration::INLINE_0x1000),
            8192 => ::std::option::Option::Some(InlineEnumeration::INLINE_0x2000),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<InlineEnumeration> {
        match str {
            "INLINE_0x1000" => ::std::option::Option::Some(InlineEnumeration::INLINE_0x1000),
            "INLINE_0x2000" => ::std::option::Option::Some(InlineEnumeration::INLINE_0x2000),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [InlineEnumeration] = &[
        InlineEnumeration::INLINE_0x1000,
        InlineEnumeration::INLINE_0x2000,
    ];
}

impl ::protobuf::EnumFull for InlineEnumeration {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("InlineEnumeration").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            InlineEnumeration::INLINE_0x1000 => 0,
            InlineEnumeration::INLINE_0x2000 => 1,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for InlineEnumeration {
    fn default() -> Self {
        InlineEnumeration::INLINE_0x1000
    }
}

impl InlineEnumeration {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<InlineEnumeration>("InlineEnumeration")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x11test_proto2.proto\x12\x0btest_proto2\x1a\nyara.proto\"\x9b\x1f\n\n\
    TestProto2\x12\x1d\n\nint32_zero\x18\x01\x20\x02(\x05R\tint32Zero\x12\
    \x1d\n\nint64_zero\x18\x02\x20\x02(\x03R\tint64Zero\x12\x1f\n\x0bsint32_\
    zero\x18\x03\x20\x02(\x11R\nsint32Zero\x12\x1f\n\x0bsint64_zero\x18\x04\
    \x20\x02(\x12R\nsint64Zero\x12\x1f\n\x0buint32_zero\x18\x05\x20\x02(\rR\
    \nuint32Zero\x12\x1f\n\x0buint64_zero\x18\x06\x20\x02(\x04R\nuint64Zero\
    \x12!\n\x0cfixed32_zero\x18\x07\x20\x02(\x07R\x0bfixed32Zero\x12!\n\x0cf\
    ixed64_zero\x18\x08\x20\x02(\x06R\x0bfixed64Zero\x12#\n\rsfixed32_zero\
    \x18\t\x20\x02(\x0fR\x0csfixed32Zero\x12#\n\rsfixed64_zero\x18\n\x20\x02\
    (\x10R\x0csfixed64Zero\x12\x1d\n\nfloat_zero\x18\x0b\x20\x02(\x02R\tfloa\
    tZero\x12\x1f\n\x0bdouble_zero\x18\x0c\x20\x02(\x01R\ndoubleZero\x12\x1b\
    \n\tint32_one\x18\x15\x20\x02(\x05R\x08int32One\x12\x1b\n\tint64_one\x18\
    \x16\x20\x02(\x03R\x08int64One\x12\x1d\n\nsint32_one\x18\x17\x20\x02(\
    \x11R\tsint32One\x12\x1d\n\nsint64_one\x18\x18\x20\x02(\x12R\tsint64One\
    \x12\x1d\n\nuint32_one\x18\x19\x20\x02(\rR\tuint32One\x12\x1d\n\nuint64_\
    one\x18\x1a\x20\x02(\x04R\tuint64One\x12\x1f\n\x0bfixed32_one\x18\x1b\
    \x20\x02(\x07R\nfixed32One\x12\x1f\n\x0bfixed64_one\x18\x1c\x20\x02(\x06\
    R\nfixed64One\x12!\n\x0csfixed32_one\x18\x1d\x20\x02(\x0fR\x0bsfixed32On\
    e\x12!\n\x0csfixed64_one\x18\x1e\x20\x02(\x10R\x0bsfixed64One\x12\x1b\n\
    \tfloat_one\x18\x1f\x20\x02(\x02R\x08floatOne\x12\x1d\n\ndouble_one\x18\
    \x20\x20\x02(\x01R\tdoubleOne\x12\x1f\n\x0bint32_undef\x18)\x20\x01(\x05\
    R\nint32Undef\x12\x1f\n\x0bint64_undef\x18*\x20\x01(\x03R\nint64Undef\
    \x12!\n\x0csint32_undef\x18+\x20\x01(\x11R\x0bsint32Undef\x12!\n\x0csint\
    64_undef\x18,\x20\x01(\x12R\x0bsint64Undef\x12!\n\x0cuint32_undef\x18-\
    \x20\x01(\rR\x0buint32Undef\x12!\n\x0cuint64_undef\x18.\x20\x01(\x04R\
    \x0buint64Undef\x12#\n\rfixed32_undef\x18/\x20\x01(\x07R\x0cfixed32Undef\
    \x12#\n\rfixed64_undef\x180\x20\x01(\x06R\x0cfixed64Undef\x12%\n\x0esfix\
    ed32_undef\x181\x20\x01(\x0fR\rsfixed32Undef\x12%\n\x0esfixed64_undef\
    \x182\x20\x01(\x10R\rsfixed64Undef\x12\x1f\n\x0bfloat_undef\x183\x20\x01\
    (\x02R\nfloatUndef\x12!\n\x0cdouble_undef\x184\x20\x01(\x01R\x0bdoubleUn\
    def\x12%\n\nstring_foo\x18=\x20\x02(\tR\tstringFooB\x06\x82\x93\x19\x02\
    \x20\x01\x12\x1d\n\nstring_bar\x18>\x20\x02(\tR\tstringBar\x12!\n\x0cstr\
    ing_undef\x18?\x20\x01(\tR\x0bstringUndef\x12\x1b\n\tbytes_foo\x18@\x20\
    \x02(\x0cR\x08bytesFoo\x12\x1b\n\tbytes_bar\x18A\x20\x02(\x0cR\x08bytesB\
    ar\x12\x1b\n\tbytes_raw\x18B\x20\x02(\x0cR\x08bytesRaw\x12\x1f\n\x0bbyte\
    s_undef\x18C\x20\x01(\x0cR\nbytesUndef\x12E\n\x0benumeration\x18d\x20\
    \x01(\x0e2#.test_proto2.TestProto2.EnumerationR\x0benumeration\x121\n\
    \x06nested\x18f\x20\x01(\x0b2\x19.test_proto2.NestedProto2R\x06nested\
    \x12\x20\n\x0barray_int64\x18\x96\x01\x20\x03(\x03R\narrayInt64\x12\x20\
    \n\x0barray_float\x18\x97\x01\x20\x03(\x02R\narrayFloat\x12\x1e\n\narray\
    _bool\x18\x98\x01\x20\x03(\x08R\tarrayBool\x12\"\n\x0carray_string\x18\
    \x99\x01\x20\x03(\tR\x0barrayString\x12=\n\x0carray_struct\x18\x9a\x01\
    \x20\x03(\x0b2\x19.test_proto2.NestedProto2R\x0barrayStruct\x12Y\n\x11ma\
    p_string_struct\x18\xc8\x01\x20\x03(\x0b2,.test_proto2.TestProto2.MapStr\
    ingStructEntryR\x0fmapStringStruct\x12V\n\x10map_string_int64\x18\xc9\
    \x01\x20\x03(\x0b2+.test_proto2.TestProto2.MapStringInt64EntryR\x0emapSt\
    ringInt64\x12Y\n\x11map_string_string\x18\xca\x01\x20\x03(\x0b2,.test_pr\
    oto2.TestProto2.MapStringStringEntryR\x0fmapStringString\x12S\n\x0fmap_s\
    tring_bool\x18\xcb\x01\x20\x03(\x0b2*.test_proto2.TestProto2.MapStringBo\
    olEntryR\rmapStringBool\x12V\n\x10map_string_float\x18\xcc\x01\x20\x03(\
    \x0b2+.test_proto2.TestProto2.MapStringFloatEntryR\x0emapStringFloat\x12\
    V\n\x10map_int64_struct\x18\xac\x02\x20\x03(\x0b2+.test_proto2.TestProto\
    2.MapInt64StructEntryR\x0emapInt64Struct\x12S\n\x0fmap_int64_int64\x18\
    \xad\x02\x20\x03(\x0b2*.test_proto2.TestProto2.MapInt64Int64EntryR\rmapI\
    nt64Int64\x12V\n\x10map_int64_string\x18\xae\x02\x20\x03(\x0b2+.test_pro\
    to2.TestProto2.MapInt64StringEntryR\x0emapInt64String\x12P\n\x0emap_int6\
    4_bool\x18\xaf\x02\x20\x03(\x0b2).test_proto2.TestProto2.MapInt64BoolEnt\
    ryR\x0cmapInt64Bool\x12S\n\x0fmap_int64_float\x18\xb0\x02\x20\x03(\x0b2*\
    .test_proto2.TestProto2.MapInt64FloatEntryR\rmapInt64Float\x12&\n\ttimes\
    tamp\x18\xb1\x02\x20\x01(\x03R\ttimestampB\x07\x82\x93\x19\x03*\x01t\x12\
    /\n\nbool_proto\x18\xde\x02\x20\x01(\x08R\tboolProtoB\x0f\x82\x93\x19\
    \x0b\n\tbool_yara\x12!\n\x07ignored\x18\xdf\x02\x20\x01(\x08R\x07ignored\
    B\x06\x82\x93\x19\x02\x10\x01\x12\x1c\n\tfile_size\x18\x90\x03\x20\x01(\
    \x04R\x08fileSize\x12\xe6\x01\n\x14requires_foo_and_bar\x18\xf4\x03\x20\
    \x01(\x04R\x11requiresFooAndBarB\xb3\x01\x82\x93\x19\xae\x01\x1a<\n\x0ff\
    oo\x20is\x20required\x12\x1fthis\x20field\x20was\x20used\x20without\x20f\
    oo\x1a\x03foo\x1a\x03FOO\x1a7\n\x0fbar\x20is\x20required\x12\x1fthis\x20\
    field\x20was\x20used\x20without\x20bar\x1a\x03bar\x1a5\n\x10baz\x20is\
    \x20forbidden\x12\x1cthis\x20field\x20was\x20used\x20with\x20baz\"\x03ba\
    z\x12J\n\ndeprecated\x18\xf5\x03\x20\x01(\tR\ndeprecatedB)\x82\x93\x19%2\
    #\n\tdon't\x20use\x12\x11use\x20`foo`\x20instead\x1a\x03foo\x12\x1b\n\
    \x08metadata\x18\xf6\x03\x20\x01(\x0cR\x08metadata\x1a]\n\x14MapStringSt\
    ructEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12/\n\x05value\
    \x18\x02\x20\x01(\x0b2\x19.test_proto2.NestedProto2R\x05value:\x028\x01\
    \x1aA\n\x13MapStringInt64Entry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03k\
    ey\x12\x14\n\x05value\x18\x02\x20\x01(\x03R\x05value:\x028\x01\x1aB\n\
    \x14MapStringStringEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a@\n\x12MapStri\
    ngBoolEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05val\
    ue\x18\x02\x20\x01(\x08R\x05value:\x028\x01\x1aA\n\x13MapStringFloatEntr\
    y\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\x02R\x05value:\x028\x01\x1a\\\n\x13MapInt64StructEntry\x12\x10\
    \n\x03key\x18\x01\x20\x01(\x03R\x03key\x12/\n\x05value\x18\x02\x20\x01(\
    \x0b2\x19.test_proto2.NestedProto2R\x05value:\x028\x01\x1a@\n\x12MapInt6\
    4Int64Entry\x12\x10\n\x03key\x18\x01\x20\x01(\x03R\x03key\x12\x14\n\x05v\
    alue\x18\x02\x20\x01(\x03R\x05value:\x028\x01\x1aA\n\x13MapInt64StringEn\
    try\x12\x10\n\x03key\x18\x01\x20\x01(\x03R\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value:\x028\x01\x1a?\n\x11MapInt64BoolEntry\x12\x10\
    \n\x03key\x18\x01\x20\x01(\x03R\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\x08R\x05value:\x028\x01\x1a@\n\x12MapInt64FloatEntry\x12\x10\n\x03\
    key\x18\x01\x20\x01(\x03R\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x02\
    R\x05value:\x028\x01\"\\\n\x0bEnumeration\x12\n\n\x06ITEM_0\x10\0\x12\n\
    \n\x06ITEM_1\x10\x01\x12\x18\n\x06ITEM_2\x10\x02\x1a\x0c\x9a\x93\x19\x08\
    \x08\xff\xff\xff\xff\xff\xff\x1f\x12\x1b\n\x06ITEM_3\x10\x03\x1a\x0f\x9a\
    \x93\x19\x0b\x08\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\"3\n\x0cEnumera\
    tion2\x12\n\n\x06ITEM_4\x10\0\x12\n\n\x06ITEM_5\x10\x01\x1a\x0b\x92\x93\
    \x19\x07\n\x05items\"\xdb\x02\n\x0cNestedProto2\x12*\n\x11nested_int32_z\
    ero\x18\x01\x20\x01(\x05R\x0fnestedInt32Zero\x12*\n\x11nested_int64_zero\
    \x18\x02\x20\x01(\x03R\x0fnestedInt64Zero\x12(\n\x10nested_int32_one\x18\
    \x03\x20\x01(\x05R\x0enestedInt32One\x12(\n\x10nested_int64_one\x18\x04\
    \x20\x01(\x03R\x0enestedInt64One\x12\x1f\n\x0bnested_bool\x18\x05\x20\
    \x01(\x08R\nnestedBool\x12#\n\rnested_string\x18\x06\x20\x01(\tR\x0cnest\
    edString\x12,\n\x12nested_array_int64\x18\x07\x20\x03(\x03R\x10nestedArr\
    ayInt64\"+\n\x11NestedEnumeration\x12\n\n\x06ITEM_0\x10\0\x12\n\n\x06ITE\
    M_1\x10\x01*9\n\x13TopLevelEnumeration\x12\x10\n\x0bITEM_0x1000\x10\x80\
    \x20\x12\x10\n\x0bITEM_0x2000\x10\x80@*C\n\x11InlineEnumeration\x12\x12\
    \n\rINLINE_0x1000\x10\x80\x20\x12\x12\n\rINLINE_0x2000\x10\x80@\x1a\x06\
    \x92\x93\x19\x02\x10\x01BJ\xfa\x92\x19F\n\x0btest_proto2\x12\x16test_pro\
    to2.TestProto2\x1a\x0btest_proto2\"\x12test_proto2-moduleb\x06proto2\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::yara::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(2);
            messages.push(TestProto2::generated_message_descriptor_data());
            messages.push(NestedProto2::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(5);
            enums.push(TopLevelEnumeration::generated_enum_descriptor_data());
            enums.push(InlineEnumeration::generated_enum_descriptor_data());
            enums.push(test_proto2::Enumeration::generated_enum_descriptor_data());
            enums.push(test_proto2::Enumeration2::generated_enum_descriptor_data());
            enums.push(nested_proto2::NestedEnumeration::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
