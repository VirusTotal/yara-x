syntax = "proto2";
import "yara.proto";

package dex;

option (yara.module_options) = {
    name : "dex",
    root_message: "dex.Dex",
    rust_module: "dex",
    cargo_feature: "dex-module"
};

// TODO: add documentation to the fields
message Dex {
    optional bool is_dex = 1;
    optional string module_name = 2;
    optional DexHeader header = 3;
    repeated StringItem string_items = 4;
    repeated StringItem types = 5;
    repeated ProtoItem protos = 6;
    repeated FieldItem fields = 7;
    repeated MethodItem methods = 8;
    repeated ClassItem classes = 9;
    optional MapList map_list = 10;
}

// https://source.android.com/docs/core/runtime/dex-format#header-item
message DexHeader {
    optional uint32 magic = 1 [(yara.field_options).fmt = "x"];
    // DEX version (35, 36, 37, ...)
    optional uint32 version = 2;
    optional uint32 checksum = 3 [(yara.field_options).fmt = "x"];
    optional string signature = 4;
    optional uint32 file_size = 5;
    optional uint32 header_size = 6 [(yara.field_options).fmt = "x"];
    optional uint32 endian_tag = 7 [(yara.field_options).fmt = "x"];
    optional uint32 link_size = 8;
    optional uint32 link_off = 9 [(yara.field_options).fmt = "x"];
    optional uint32 map_off = 10 [(yara.field_options).fmt = "x"];
    optional uint32 string_ids_size = 11;
    optional uint32 string_ids_off = 12 [(yara.field_options).fmt = "x"];
    optional uint32 type_ids_size = 13;
    optional uint32 type_ids_off = 14 [(yara.field_options).fmt = "x"];
    optional uint32 proto_ids_size = 15;
    optional uint32 proto_ids_off = 16 [(yara.field_options).fmt = "x"];
    optional uint32 field_ids_size = 17;
    optional uint32 field_ids_off = 18 [(yara.field_options).fmt = "x"];
    optional uint32 method_ids_size = 19;
    optional uint32 method_ids_off = 20 [(yara.field_options).fmt = "x"];
    optional uint32 class_defs_size = 21;
    optional uint32 class_defs_off = 22 [(yara.field_options).fmt = "x"];
    optional uint32 data_size = 23;
    optional uint32 data_off = 24 [(yara.field_options).fmt = "x"];
    optional uint32 container_size = 25;
    optional uint32 header_offset = 26 [(yara.field_options).fmt = "x"];
}

message StringItem {
    optional uint64 size = 0;
    optional string value = 1;
}

message ProtoItem {
    optional StringItem shorty = 0;
    optional StringItem return_type = 1;
    optional uint32 parameters_count = 2;
    repeated StringItem parameters = 3;
}

message FieldItem {
    optional StringItem class = 0;
    optional StringItem type = 1;
    optional StringItem name = 2;
}

message MethodItem {
    optional StringItem class = 0;
    optional ProtoItem proto = 1;
    optional StringItem name = 2;
}

message ClassItem {
    optional StringItem class = 0;
    optional uint32 access_flags = 1;
    optional StringItem superclass = 2;
    optional StringItem source_file = 3;
}

message MapList {
    optional uint32 size = 0;
    repeated MapItem items = 1;
}

message MapItem {
    optional TypeCode type = 0;
    optional uint32 unused = 1;
    optional uint32 size = 2;
    optional uint32 offset = 3 [(yara.field_options).fmt = "x"];
}

// TODO: maybe inline this flags
enum AccessFlag {
    ACC_PUBLIC = 0x1;
    ACC_PRIVATE = 0x2;
    ACC_PROTECTED = 0x4;
    ACC_STATIC = 0x8;
    ACC_FINAL = 0x10;
    ACC_SYNCHRONIZED = 0x20;
    // ACC_VOLATILE = 0x40;
    ACC_BRIDGE = 0x40;
    // ACC_TRANSIENT = 0x80;
    ACC_VARARGS = 0x80;
    ACC_NATIVE = 0x100;
    ACC_INTERFACE = 0x200;
    ACC_ABSTRACT = 0x400;
    ACC_STRICT = 0x800;
    ACC_SYNTHETIC = 0x1000;
    ACC_ANNOTATION = 0x2000;
    ACC_ENUM = 0x4000;
    ACC_CONSTRUCTOR = 0x10000;
    ACC_DECLARED_SYNCHRONIZED = 0x20000;
}

enum TypeCode {
    TYPE_HEADER_ITEM = 0x0000;
    TYPE_STRING_ID_ITEM = 0x0001;
    TYPE_TYPE_ID_ITEM = 0x0002;
    TYPE_PROTO_ID_ITEM = 0x0003;
    TYPE_FIELD_ID_ITEM = 0x0004;
    TYPE_METHOD_ID_ITEM = 0x0005;
    TYPE_CLASS_DEF_ITEM = 0x0006;
    TYPE_CALL_SITE_ID_ITEM = 0x0007;
    TYPE_METHOD_HANDLE_ITEM = 0x0008;
    TYPE_MAP_LIST = 0x1000;
    TYPE_TYPE_LIST = 0x1001;
    TYPE_ANNOTATION_SET_REF_LIST = 0x1002;
    TYPE_ANNOTATION_SET_ITEM = 0x1003;
    TYPE_CLASS_DATA_ITEM = 0x2000;
    TYPE_CODE_ITEM = 0x2001;
    TYPE_STRING_DATA_ITEM = 0x2002;
    TYPE_DEBUG_INFO_ITEM = 0x2003;
    TYPE_ANNOTATION_ITEM = 0x2004;
    TYPE_ENCODED_ARRAY_ITEM = 0x2005;
    TYPE_ANNOTATIONS_DIRECTORY_ITEM = 0x2006;
    TYPE_HIDDENAPI_CLASS_DATA_ITEM = 0xF000;
}

enum MethodHandle {
    METHOD_HANDLE_TYPE_STATIC_PUT = 0x00;
    METHOD_HANDLE_TYPE_STATIC_GET = 0x01;
    METHOD_HANDLE_TYPE_INSTANCE_PUT = 0x02;
    METHOD_HANDLE_TYPE_INSTANCE_GET = 0x03;
    METHOD_HANDLE_TYPE_INVOKE_STATIC = 0x04;
    METHOD_HANDLE_TYPE_INVOKE_INSTANCE = 0x05;
    METHOD_HANDLE_TYPE_INVOKE_CONSTRUCTOR = 0x06;
    METHOD_HANDLE_TYPE_INVOKE_DIRECT = 0x07;
    METHOD_HANDLE_TYPE_INVOKE_INTERFACE = 0x08;
}
